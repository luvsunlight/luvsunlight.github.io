<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Prozac’s blog</title>
  
  <subtitle>记录学习的技能和遇到的问题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-09T08:38:31.185Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Prozac</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zIndex为什么会无效</title>
    <link href="http://yoursite.com/2019/05/31/zIndex%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%97%A0%E6%95%88/"/>
    <id>http://yoursite.com/2019/05/31/zIndex为什么会无效/</id>
    <published>2019-05-31T14:24:01.000Z</published>
    <updated>2019-09-09T08:38:31.185Z</updated>
    
    <content type="html"><![CDATA[<p>在做项目的过程中遇到了这样的问题，即z-index为什么会有时候没有效果？</p><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们首先来看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index" target="_blank" rel="external">MDN</a>里，z-index是怎么描述的</p><blockquote><p>z-index 属性指定了一个具有定位属性的元素及其子代元素的 z-order。 当元素之间重叠的时候，z-order 决定哪一个元素覆盖在其余元素的上方显示。 通常来说 z-index 较大的元素会覆盖较小的一个。</p><p>对于一个已经定位的元素（即position属性值不是static的元素），z-index 属性指定：</p><p>元素在当前堆叠上下文中的堆叠层级。<br>元素是否创建一个新的本地堆叠上下文</p></blockquote><p>z-index 可以取值<code>auto</code>或者数字（auto会互相层叠，但是只要指定正的z-index，就会比auto高）</p><p>需要注意的是z-index需要是对有<code>position</code>不为<code>static</code>属性的元素才做效的</p><h1 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h1><p>该标签无<code>position</code>属性</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>添加position标签</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做项目的过程中遇到了这样的问题，即z-index为什么会有时候没有效果？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DIY Vue UI组件库之路</title>
    <link href="http://yoursite.com/2019/05/31/DIY-Vue-UI%E7%BB%84%E4%BB%B6%E5%BA%93%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/05/31/DIY-Vue-UI组件库之路/</id>
    <published>2019-05-31T14:24:01.000Z</published>
    <updated>2019-06-02T11:33:54.873Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写vue的项目多了，感觉越来越需要自己从头开始写一个UI组件库来系统地升华自己的能力</p></blockquote><a id="more"></a><h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><ul><li>vue</li><li>vuex</li><li>vueRouter</li><li>less</li></ul><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>首先使用vue-cli3.x来构建项目，因为是特别正式的项目，不是平时的业务开发，所以加入了单测和eslinit</p><h2 id="测试了下npm发布包的功能"><a href="#测试了下npm发布包的功能" class="headerlink" title="测试了下npm发布包的功能"></a>测试了下npm发布包的功能</h2><p>首先在npm官网注册账号，然后在本地项目文件夹下<code>npm login</code>,然后<code>npm publish --access public</code></p><p>注意npm的淘宝源是不行的，最好是使用<code>nrm</code>来管理npm源。常用操作<code>nrm ls</code>，<code>nrm use ***</code></p><h2 id="新建examples文件夹"><a href="#新建examples文件夹" class="headerlink" title="新建examples文件夹"></a>新建examples文件夹</h2><p>做组件库跟业务开发不一样，它主要的文件全部用来放库，展示页面应该另起一个文件夹，在根目录下新建examples文件夹，并且加入<code>main.js</code>,<code>app.vue</code>,<code>index.html</code></p><p>之前习惯的事用vuecli2.x，但是毕竟3.x才是潮流，这次还是用了3.x</p><p>在<code>package.json</code>里配置serve的属性， 将原来的serve改为<code>&quot;serve&quot;: &quot;vue-cli-service serve --open ./examples/main.js&quot;,</code>，这样就指定了新的入口文件，测试一下，ok</p><h2 id="文档的编写"><a href="#文档的编写" class="headerlink" title="文档的编写"></a>文档的编写</h2><p>直接采用<a href="https://github.com/docsifyjs/docsify" target="_blank" rel="external">docsify</a></p><p>配置挺复杂的，折腾了一天</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写vue的项目多了，感觉越来越需要自己从头开始写一个UI组件库来系统地升华自己的能力&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自定义vue-cli脚手架</title>
    <link href="http://yoursite.com/2019/03/25/%E8%87%AA%E5%AE%9A%E4%B9%89vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/03/25/自定义vue-cli脚手架/</id>
    <published>2019-03-25T05:48:13.000Z</published>
    <updated>2019-03-25T05:58:33.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为最近写了很多的vue小工程练手，但是越来越发现vuecli的webpack模板不够用了，每次重新构建的时候都需要花很多心思，花了一天的时间来研究和使用vuecli的自定义构建，非常好用</p></blockquote><a id="more"></a><h1 id="Fork一份标准库"><a href="#Fork一份标准库" class="headerlink" title="Fork一份标准库"></a>Fork一份标准库</h1><p>去<a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">vue-webpack模板</a>的标准库下fork一份，并且创建一份自己的分支</p><h1 id="在本地进行修改"><a href="#在本地进行修改" class="headerlink" title="在本地进行修改"></a>在本地进行修改</h1><p>将fork的项目clone到本地，进行修改</p><p>具体的步骤和解释参考<a href="https://segmentfault.com/a/1190000012074462" target="_blank" rel="external">这个文章</a></p><p>我只讲一下我做了哪些改动</p><h2 id="1-打开config-index-js中的autoOpenBrowser"><a href="#1-打开config-index-js中的autoOpenBrowser" class="headerlink" title="1 打开config/index.js中的autoOpenBrowser"></a>1 打开<code>config/index.js</code>中的autoOpenBrowser</h2><h2 id="2-editorConfig中调整indent-size为4，并且将其风格改为tab"><a href="#2-editorConfig中调整indent-size为4，并且将其风格改为tab" class="headerlink" title="2 .editorConfig中调整indent_size为4，并且将其风格改为tab"></a>2 <code>.editorConfig</code>中调整<code>indent_size</code>为4，并且将其风格改为tab</h2><h2 id="3-增加-vuex版块"><a href="#3-增加-vuex版块" class="headerlink" title="3 增加 vuex版块"></a>3 增加 <code>vuex</code>版块</h2><h2 id="4-增加mock和api版块"><a href="#4-增加mock和api版块" class="headerlink" title="4 增加mock和api版块"></a>4 增加mock和api版块</h2><h2 id="5-增加page版块"><a href="#5-增加page版块" class="headerlink" title="5 增加page版块"></a>5 增加page版块</h2><h2 id="6-增加less"><a href="#6-增加less" class="headerlink" title="6 增加less"></a>6 增加less</h2><h2 id="7-增加common文件夹，并且写了一些公共样式"><a href="#7-增加common文件夹，并且写了一些公共样式" class="headerlink" title="7 增加common文件夹，并且写了一些公共样式"></a>7 增加common文件夹，并且写了一些公共样式</h2><h2 id="8-增加less的全局变量"><a href="#8-增加less的全局变量" class="headerlink" title="8 增加less的全局变量"></a>8 增加less的全局变量</h2><p>参考<a href="https://blog.csdn.net/hani_wen/article/details/81007852" target="_blank" rel="external">这篇文章</a></p><blockquote><p>注意，增加的全部变量只能引用一个less文件，不能在这个文件里引用其他的文件</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因为最近写了很多的vue小工程练手，但是越来越发现vuecli的webpack模板不够用了，每次重新构建的时候都需要花很多心思，花了一天的时间来研究和使用vuecli的自定义构建，非常好用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术细节" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年新计划</title>
    <link href="http://yoursite.com/2019/02/18/2019%E5%B9%B4%E6%96%B0%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2019/02/18/2019年新计划/</id>
    <published>2019-02-18T02:49:33.000Z</published>
    <updated>2019-02-18T03:08:59.795Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>新的一年已经开始了，去年做的还不够好，新的一年在技术上还是应该多抓紧一些</p></blockquote><a id="more"></a><h1 id="1-研究生生活"><a href="#1-研究生生活" class="headerlink" title="1.研究生生活"></a>1.研究生生活</h1><ul><li>下个学期每天认真看论文，还有自己写论文，主题暂定为动物迁徙，主要是去认真看一些有意思的话题</li><li>公众号完善一下</li></ul><h1 id="2-生活方面"><a href="#2-生活方面" class="headerlink" title="2.生活方面"></a>2.生活方面</h1><ul><li>去蹭日语课，今年要达到日语N3的水平</li><li>上公开课（苏德超，赵林，周玄毅）</li><li>健身</li><li>学会基础的摄影</li><li>有闲暇的时间就去看书</li></ul><h1 id="3-编程方面"><a href="#3-编程方面" class="headerlink" title="3.编程方面"></a>3.编程方面</h1><ul><li>学习node的教程</li><li>看自己之前买的几本书，并且开始做笔记</li><li>微信的开发</li><li>极客时间上的教程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;新的一年已经开始了，去年做的还不够好，新的一年在技术上还是应该多抓紧一些&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js类型详解</title>
    <link href="http://yoursite.com/2018/09/29/js%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/09/29/js类型详解/</id>
    <published>2018-09-29T11:23:41.000Z</published>
    <updated>2018-09-29T14:33:34.453Z</updated>
    
    <content type="html"><![CDATA[<p>js的类型实际上是一个基本问题，但它总能在一些小的细节上给人困扰，这次就一口气把这个问题好好解决了</p><a id="more"></a><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="external">阮一峰的教程</a></li><li><a href="http://www.cnblogs.com/qiantuwuliang/archive/2010/01/12/1645302.html" target="_blank" rel="external">一个博客</a></li></ul><h1 id="js类型详解"><a href="#js类型详解" class="headerlink" title="js类型详解"></a>js类型详解</h1><blockquote><p>js分为基本类型和引用类型</p></blockquote><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型一共5种</p><h3 id="1-Undefined"><a href="#1-Undefined" class="headerlink" title="1.Undefined"></a>1.Undefined</h3><blockquote><p>使用var声明变量时，如果没有对其赋值就引用它就会产生undefined值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a</div><div class="line"></div><div class="line">a <span class="comment">// -&gt; undefined</span></div><div class="line"></div><div class="line">a == <span class="literal">undefined</span> <span class="comment">// -&gt; true</span></div><div class="line"></div><div class="line">c === <span class="literal">undefined</span> <span class="comment">// -&gt; true</span></div></pre></td></tr></table></figure><h3 id="2-Null"><a href="#2-Null" class="headerlink" title="2.Null"></a>2.Null</h3><blockquote><p>从逻辑上说，null值表示一个空对象指针，这也正是使用typeof来检测null会返回object的原因</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">null</span>)) <span class="comment">// -&gt; 'object'</span></div></pre></td></tr></table></figure><h3 id="3-boolean"><a href="#3-boolean" class="headerlink" title="3.boolean"></a>3.boolean</h3><h3 id="4-number"><a href="#4-number" class="headerlink" title="4.number"></a>4.number</h3><h3 id="5-string"><a href="#5-string" class="headerlink" title="5.string"></a>5.string</h3><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h3><h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h3><h3 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h3><h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h3><h3 id="Symbol类型（es6新加）"><a href="#Symbol类型（es6新加）" class="headerlink" title="Symbol类型（es6新加）"></a>Symbol类型（es6新加）</h3><h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><blockquote><p>ECMAScript提供了3种特殊的引用类型 Boolean，Number，String.也就是是它们三个实际上都是function的实例罢辽</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="string">"a"</span></div><div class="line"><span class="keyword">let</span> b = <span class="built_in">String</span>(<span class="string">"a"</span>)</div><div class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"a"</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a)) <span class="comment">// -&gt; "string"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(b)) <span class="comment">// -&gt; "string"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(c)) <span class="comment">// -&gt; "object"</span></div></pre></td></tr></table></figure><h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><h2 id="1-NaN的类型"><a href="#1-NaN的类型" class="headerlink" title="1.NaN的类型"></a>1.NaN的类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">NaN</span>))</div><div class="line"><span class="comment">// -&gt; 'number'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>)</div><div class="line"><span class="comment">// -&gt; false</span></div></pre></td></tr></table></figure><h3 id="2-Undefined和Null"><a href="#2-Undefined和Null" class="headerlink" title="2.Undefined和Null"></a>2.Undefined和Null</h3><blockquote><p>null表示此处不该有值，undefined表示此处应该有值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">null</span>)</div><div class="line"><span class="comment">// -&gt; true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="literal">null</span>)</div><div class="line"><span class="comment">// -&gt; false</span></div></pre></td></tr></table></figure><h3 id="3-和-的区别"><a href="#3-和-的区别" class="headerlink" title="3.== 和 === 的区别"></a>3.== 和 === 的区别</h3><blockquote><p>Show code</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">100</span> == <span class="string">"100"</span> <span class="comment">// -&gt; true</span></div><div class="line"><span class="number">100</span> === <span class="string">"100"</span> <span class="comment">// -&gt; false</span></div></pre></td></tr></table></figure><h4 id="3-1-判断规则"><a href="#3-1-判断规则" class="headerlink" title="3.1 === 判断规则"></a>3.1 === 判断规则</h4><p>首先要等号两边类型相同，然后才是值相同</p><h4 id="3-2-判断规则"><a href="#3-2-判断规则" class="headerlink" title="3.2 == 判断规则"></a>3.2 == 判断规则</h4><ul><li>如果两边存在boolean，string，number任意两者进行比较，优先转化为数字</li><li>null == undefined</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js的类型实际上是一个基本问题，但它总能在一些小的细节上给人困扰，这次就一口气把这个问题好好解决了&lt;/p&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2018/09/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/29/设计模式/</id>
    <published>2018-09-29T09:25:31.000Z</published>
    <updated>2018-09-29T11:16:37.641Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设计模式始终是一个巨大的话题，总是要涉及，干脆写一篇博客来进行总结那些常见的设计模式</p></blockquote><a id="more"></a><h1 id="构建函数模式"><a href="#构建函数模式" class="headerlink" title="构建函数模式"></a>构建函数模式</h1><blockquote><p>在es6中，这种模式和原型模式统一了，都是很好的设计模式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, gender, score) &#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">      <span class="keyword">this</span>.gender = gender;</div><div class="line">      <span class="keyword">this</span>.score = score;</div><div class="line">      <span class="keyword">this</span>.quality = <span class="number">100</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sumScore() &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.score + <span class="keyword">this</span>.quality;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> whh = <span class="keyword">new</span> Student(<span class="string">'王花花'</span>, <span class="string">'男'</span>, <span class="number">89</span>);</div><div class="line">  <span class="keyword">var</span> lsd = <span class="keyword">new</span> Student(<span class="string">'李拴蛋'</span>, <span class="string">'女'</span>, <span class="number">40</span>);</div><div class="line"></div><div class="line">  whh.score = <span class="number">100</span>;</div><div class="line">  <span class="built_in">console</span>.log(whh.name, whh.sumScore())</div><div class="line">  <span class="built_in">console</span>.log(lsd.name, lsd.sumScore())</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, gender, score) &#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">      <span class="keyword">this</span>.gender = gender;</div><div class="line">      <span class="keyword">this</span>.score = score;</div><div class="line">      <span class="keyword">this</span>.quality = <span class="number">100</span>;</div><div class="line"></div><div class="line">      <span class="keyword">this</span>.mount();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mount() &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h1 id="构建者模式"><a href="#构建者模式" class="headerlink" title="构建者模式"></a>构建者模式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> studentCount = <span class="number">0</span>;</div><div class="line"></div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">StudentBuilder</span> </span>&#123;</div><div class="line">   <span class="keyword">constructor</span>() &#123;</div><div class="line">     <span class="keyword">this</span>.student = <span class="keyword">new</span> Student();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   setName(name) &#123;</div><div class="line">     <span class="keyword">this</span>.student.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   setGender(gender) &#123;</div><div class="line">     <span class="keyword">if</span> (gender != <span class="string">'男'</span> &amp;&amp; gender != <span class="string">'女'</span>)</div><div class="line">       <span class="keyword">throw</span> <span class="string">'好玩不'</span>;</div><div class="line"></div><div class="line">     <span class="keyword">this</span>.student.gender = gender;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   setHairLength(hairLength) &#123;</div><div class="line">     <span class="keyword">if</span> (</div><div class="line">       (<span class="keyword">this</span>.student.gender == <span class="string">'男'</span> &amp;&amp; hairLength &gt; <span class="number">1</span>) ||</div><div class="line">       (<span class="keyword">this</span>.student.gender == <span class="string">'女'</span> &amp;&amp; hairLength &gt; <span class="number">25</span>)</div><div class="line">     ) <span class="keyword">throw</span> <span class="string">'回去剪头'</span>;</div><div class="line"></div><div class="line">     <span class="keyword">this</span>.student.hairLength = hairLength;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   build() &#123;</div><div class="line">     studentCount++;</div><div class="line">     <span class="built_in">console</span>.log(studentCount);</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.student;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">const</span> builder = <span class="keyword">new</span> StudentBuilder();</div><div class="line"> builder.setName(<span class="string">'王花花'</span>);</div><div class="line"> builder.setGender(<span class="string">'男'</span>);</div><div class="line"> builder.setHairLength(<span class="number">1</span>);</div><div class="line"> <span class="keyword">const</span> whh = builder.build();</div><div class="line"></div><div class="line"> <span class="keyword">const</span> builder2 = <span class="keyword">new</span> StudentBuilder();</div><div class="line"> builder2.setName(<span class="string">'李拴蛋'</span>);</div><div class="line"> builder2.setGender(<span class="string">'女'</span>);</div><div class="line"> builder2.setHairLength(<span class="number">20</span>);</div><div class="line"> <span class="keyword">const</span> lsd = builder2.build();</div><div class="line"></div><div class="line"> <span class="built_in">console</span>.log(lsd);</div></pre></td></tr></table></figure><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><blockquote><p>工厂模式的特点就是使用<strong>函数</strong>来封装特定接口的细节.它虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, subjects) &#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">      <span class="comment">// ...</span></div><div class="line"></div><div class="line">      <span class="comment">// 如果是文科生：['政治', '历史', '地理']</span></div><div class="line">      <span class="comment">// 如果是文科生：['数学', '物理', '化学']</span></div><div class="line">      <span class="keyword">this</span>.subjects = subjects;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">factory</span>(<span class="params">name, type</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'文科'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, [<span class="string">'政治'</span>, <span class="string">'历史'</span>, <span class="string">'地理'</span>])</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'理科'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, [<span class="string">'数学'</span>, <span class="string">'物理'</span>, <span class="string">'化学'</span>])</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'体育'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, [<span class="string">'长跑'</span>, <span class="string">'...'</span>])</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">throw</span> <span class="string">'没有这个专业，别瞎填'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> whh = factory(<span class="string">'王花花'</span>, <span class="string">'文科'</span>);</div><div class="line">  <span class="keyword">const</span> lsd = factory(<span class="string">'李拴蛋'</span>, <span class="string">'理科'</span>);</div><div class="line">  <span class="keyword">const</span> zks = factory(<span class="string">'赵可爽'</span>, <span class="string">'体育'</span>);</div><div class="line">  <span class="keyword">const</span> lbb = factory(<span class="string">'刘备备'</span>, <span class="string">'撒盐'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(whh);</div><div class="line">  <span class="built_in">console</span>.log(lsd);</div><div class="line">  <span class="built_in">console</span>.log(zks);</div></pre></td></tr></table></figure><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote><p>单例模式最突出的特点就是这个类只有一个实例，并且提供一个全局访问他的接口  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span> () &#123;</div><div class="line">    <span class="comment">// 如果不是第一次new（instance肯定是存在的）</span></div><div class="line">    <span class="keyword">if</span> (Resource.instance)</div><div class="line">      <span class="keyword">return</span> Resource.instance;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 否则（instance不存在）</span></div><div class="line">      <span class="comment">// 组装新对象</span></div><div class="line">      <span class="keyword">this</span>.balance = <span class="number">100</span>;</div><div class="line"></div><div class="line">      <span class="comment">// 将其存到Resource机器上</span></div><div class="line">      Resource.instance = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> r = <span class="keyword">new</span> Resource();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'r:'</span>, r);</div><div class="line">r.balance = <span class="number">50</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'r:'</span>, r);</div><div class="line"></div><div class="line"><span class="keyword">const</span> r2 = <span class="keyword">new</span> Resource();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'r2:'</span>, r2);</div><div class="line"></div><div class="line">r.balance = <span class="number">55</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'r2:'</span>, r2);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计模式始终是一个巨大的话题，总是要涉及，干脆写一篇博客来进行总结那些常见的设计模式&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>npm使用指南</title>
    <link href="http://yoursite.com/2018/09/27/npm%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/09/27/npm使用指南/</id>
    <published>2018-09-27T13:16:08.000Z</published>
    <updated>2018-10-05T02:32:28.248Z</updated>
    
    <content type="html"><![CDATA[<p>只要你做前端，就必定躲不开npm这个工具。这篇文章总结了npm的入门和对应的指令<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="npm是什么？"><a href="#npm是什么？" class="headerlink" title="npm是什么？"></a>npm是什么？</h2><p>要说npm是什么，首先要说<a href="http://nodejs.cn/" target="_blank" rel="external">node</a>是什么。</p><blockquote><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p></blockquote><p>处于安全性等方面的考虑，原本只能存在于浏览器环境的js存在诸多限制比如IO操作，或者是读取本地文件，nodejs的存在，让js可以在系统环境下运行，这大大提升了js的发挥空间</p><p>npm（node package manager）顾名思义即node的包管理工具</p><blockquote><p>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。<br>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p></blockquote><h1 id="npm-指令"><a href="#npm-指令" class="headerlink" title="npm 指令"></a>npm 指令</h1><p>注：</p><blockquote><p>在npm中，包（package）、模块（module）、依赖（dependency）说的都是一回事儿。</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>npm init</code> 初始化项目，其实就是创建一个package.json文件。</li><li><code>npm install</code> 安装所有项目依赖。</li><li><code>npm help xxx</code> 查看xxx命令的帮助信息。</li></ul><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><ul><li><code>npm -g install npm</code></li></ul><h2 id="设置npm配置"><a href="#设置npm配置" class="headerlink" title="设置npm配置"></a>设置npm配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config set &lt;key&gt; <span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span> [–global]</span></div></pre></td></tr></table></figure><h3 id="查看npm配置"><a href="#查看npm配置" class="headerlink" title="查看npm配置"></a>查看npm配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config ls</div></pre></td></tr></table></figure><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config set proxy=http:<span class="comment">//xx.xx.xx.xx:8080</span></div></pre></td></tr></table></figure><h3 id="设置npm的镜像源"><a href="#设置npm的镜像源" class="headerlink" title="设置npm的镜像源"></a>设置npm的镜像源</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config set registry https:<span class="comment">//registry.npm.taobao.org</span></div></pre></td></tr></table></figure><h2 id="发布项目到npm"><a href="#发布项目到npm" class="headerlink" title="发布项目到npm"></a>发布项目到npm</h2><p>1.在官网注册npm账号</p><p>2.用户验证，命令行执行</p><blockquote><p>npm adduser</p></blockquote><p>3.发布模块，在模块的根文件夹执行</p><blockquote><p>npm publish</p></blockquote><p>4.更新版本</p><blockquote><p>如果是git库时，会为新版本号创建一条提交信息，package版本号会自动递增。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm version <span class="number">0.0</span><span class="number">.4</span></div><div class="line">npm publish</div></pre></td></tr></table></figure><h2 id="npm-search-搜索（快捷方式：find-s）"><a href="#npm-search-搜索（快捷方式：find-s）" class="headerlink" title="npm search 搜索（快捷方式：find, s）"></a>npm search 搜索（快捷方式：find, s）</h2><ul><li><code>xxx</code> 搜索xxx 如：npm search jquery。</li></ul><h2 id="npm-install-安装-（快捷方式：i）"><a href="#npm-install-安装-（快捷方式：i）" class="headerlink" title="npm install 安装 （快捷方式：i）"></a>npm install 安装 （快捷方式：i）</h2><ul><li>xxx 搜索并安装xxx（局部）。安装多个依赖可用空格分割，如npm i jquery bootstrap。</li><li>xxx -g 搜索并安装xxx（全局）。安装多个同上。</li><li>xxx -D 安装并将依赖信息写在package.json中的devDependencies中。</li><li>快捷方式 i均可，如npm i jquery。</li><li>xxx@版本号 指定需要安装的版本号，若不指定将安装最新的稳定版本。</li></ul><h2 id="npm-uninstall-卸载（快捷方式：rm-r）"><a href="#npm-uninstall-卸载（快捷方式：rm-r）" class="headerlink" title="npm uninstall 卸载（快捷方式：rm, r）"></a>npm uninstall 卸载（快捷方式：rm, r）</h2><ul><li>xxx 卸载xxx。多个依赖可用空格分割。</li><li>xxx -D 卸载xxx，并将依赖信息从package.json中的devDependencies中清除。</li></ul><h2 id="npm-list-列出已安装依赖（快捷方式：ls）"><a href="#npm-list-列出已安装依赖（快捷方式：ls）" class="headerlink" title="npm list 列出已安装依赖（快捷方式：ls）"></a>npm list 列出已安装依赖（快捷方式：ls）</h2><ul><li>默认列出局部依赖。</li><li>npm list -g 列出已安装的全局依赖。</li></ul><h2 id="npm-outdated-检查过期依赖"><a href="#npm-outdated-检查过期依赖" class="headerlink" title="npm outdated 检查过期依赖"></a>npm outdated 检查过期依赖</h2><h2 id="npm-update-更新依赖（快捷方式：up）"><a href="#npm-update-更新依赖（快捷方式：up）" class="headerlink" title="npm update 更新依赖（快捷方式：up）"></a>npm update 更新依赖（快捷方式：up）</h2><ul><li>xxx 局部更新xxx。</li><li>xxx -g 全局更新xxx。</li></ul><h2 id="npm-root-查看依赖安装路径（也就是node-modules的路径）"><a href="#npm-root-查看依赖安装路径（也就是node-modules的路径）" class="headerlink" title="npm root 查看依赖安装路径（也就是node_modules的路径）"></a>npm root 查看依赖安装路径（也就是node_modules的路径）</h2><ul><li>默认查看局部安装路径。</li><li>-g 查看全局安装路径。</li></ul><h2 id="npm-view-查看模块的注册信息"><a href="#npm-view-查看模块的注册信息" class="headerlink" title="npm view 查看模块的注册信息"></a>npm view 查看模块的注册信息</h2><ul><li>xxx versions 列出xxx的所有版本， 如：npm view jquery versions。</li><li>xxx dependencies 列出xxx的所有依赖， 如：npm view gulp dependencies。</li></ul><h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><blockquote><p>npm run <em>*</em></p></blockquote><h1 id="nvm-指令"><a href="#nvm-指令" class="headerlink" title="nvm 指令"></a>nvm 指令</h1><h2 id="nvm是什么"><a href="#nvm是什么" class="headerlink" title="nvm是什么"></a>nvm是什么</h2><blockquote><p>在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。</p></blockquote><p>nvm 应运而生，nvm 是 Mac 下的 node 管理工具，有点类似管理 Ruby 的 rvm，如果需要管理 Windows 下的 node，官方推荐使用 nvmw 或 nvm-windows。不过，nvm-windows 并不是 nvm 的简单移植，他们也没有任何关系。但下面介绍的所有命令，都可以在 nvm-windows 中运行。</p><h2 id="安装多版本的node-npm"><a href="#安装多版本的node-npm" class="headerlink" title="安装多版本的node/npm"></a>安装多版本的node/npm</h2><p>例如，我们要安装4.2.2版本，可以用如下命令：</p><blockquote><p>nvm install 4.2.2</p></blockquote><p>nvm 遵守语义化版本命名规则。例如，你想安装最新的 4.2 系列的最新的一个版本的话，可以运行：</p><blockquote><p>nvm install 4.2</p></blockquote><p>nvm 会寻找 4.2.x 中最高的版本来安装。</p><p>你可以通过以下命令来列出远程服务器上所有的可用版本：</p><blockquote><p>nvm ls-remote</p></blockquote><h2 id="在多个版本中个切换"><a href="#在多个版本中个切换" class="headerlink" title="在多个版本中个切换"></a>在多个版本中个切换</h2><p>每当我们安装了一个新版本 Node 后，全局环境会自动把这个新版本设置为默认。</p><p>nvm 提供了 nvm use 命令。这个命令的使用方法和 install 命令类似。</p><p>例如，切换到 4.2.2：</p><blockquote><p>nvm use 4.2.2</p></blockquote><h2 id="列出已安装实例"><a href="#列出已安装实例" class="headerlink" title="列出已安装实例"></a>列出已安装实例</h2><blockquote><p>nvm ls</p></blockquote><h2 id="在项目中使用不同版本的-Node"><a href="#在项目中使用不同版本的-Node" class="headerlink" title="在项目中使用不同版本的 Node"></a>在项目中使用不同版本的 Node</h2><p>我们可以通过创建项目目录中的 .nvmrc 文件来指定要使用的 Node 版本。之后在项目目录中执行 nvm use 即可。.nvmrc 文件内容只需要遵守上文提到的语义化版本规则即可。另外还有个工具叫做 avn，可以自动化这个过程。</p><h2 id="在多环境中，npm该如何使用呢？"><a href="#在多环境中，npm该如何使用呢？" class="headerlink" title="在多环境中，npm该如何使用呢？"></a>在多环境中，npm该如何使用呢？</h2><p>每个版本的 Node 都会自带一个不同版本的 npm，可以用 npm -v 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 <code>~/.nvm/versions/node/&lt;version&gt;/lib/node_modules&lt;/version&gt;</code> 这样的目录。这刚好也省去我们在 Linux 中使用 sudo 的功夫了。因为这是用户的主文件夹，并不会引起权限问题。</p><p>但问题来了，我们安装过的 npm 包，都要重新再装一次？幸运的是，我们有个办法来解决我们的问题，运行下面这个命令，可以从特定版本导入到我们将要安装的新版本 Node：</p><blockquote><p>nvm install v5.0.0 –reinstall-packages-from=4.2</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只要你做前端，就必定躲不开npm这个工具。这篇文章总结了npm的入门和对应的指令&lt;br&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>ES6和ES7全面入门</title>
    <link href="http://yoursite.com/2018/09/26/ES5%E5%92%8CES6%E5%85%A8%E9%9D%A2%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/26/ES5和ES6全面入门/</id>
    <published>2018-09-26T14:22:17.000Z</published>
    <updated>2018-10-06T02:27:22.666Z</updated>
    
    <content type="html"><![CDATA[<p>ES2015（ES6）和ES2016(ES7)的知识总结<br><a id="more"></a></p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><p>本篇博客的大部分内容和案例均来源于互联网，因为自己也算不上权威就暂时没有这个必要</p><h2 id="1-2-参考资料"><a href="#1-2-参考资料" class="headerlink" title="1.2 参考资料"></a>1.2 参考资料</h2><ul><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰的es6入门</a></li><li><a href="https://www.jianshu.com/p/76dbe1cd5732" target="_blank" rel="external">一篇简书教程</a></li><li><a href="https://babeljs.io/docs/en/learn" target="_blank" rel="external">babel的教程</a></li><li><a href="https://gank.io/post/564151c1f1df1210001c9161" target="_blank" rel="external">一篇特别良心的es6入门到实战的教程</a></li></ul><h1 id="2-ES6"><a href="#2-ES6" class="headerlink" title="2.ES6"></a>2.ES6</h1><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><h2 id="ECMAScript-和-JavaScript-的关系"><a href="#ECMAScript-和-JavaScript-的关系" class="headerlink" title="ECMAScript 和 JavaScript 的关系"></a>ECMAScript 和 JavaScript 的关系</h2><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p><p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p><p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p><p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p><h2 id="let、const"><a href="#let、const" class="headerlink" title="let、const"></a>let、const</h2><p>在 ES2015 的新语法中，影响速度最为直接，范围最大的，恐怕得数 let 和 const 了，它们是继 var 之后，新的变量定义方法。与 let 相比，const 更容易被理解：const 也就是 constant 的缩写，跟 C/C++ 等经典语言一样，用于定义常量，即不可变量。</p><p>但由于在 ES6 之前的 ECMAScript 标准中，并没有原生的实现，所以在降级编译中，会马上进行引用检查，然后使用 var 代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// foo.js</span></div><div class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span></div><div class="line"></div><div class="line">foo = <span class="string">'newvalue'</span></div></pre></td></tr></table></figure><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>在 ES6 诞生之前，我们在给 JavaScript 新手解答困惑时，经常会提到一个观点：</p><blockquote><p>JavaScript 没有块级作用域</p></blockquote><p>在 ES6 诞生之前的时代中，JavaScript 确实是没有块级作用域的。这个问题之所以为人所熟知，是因为它引发了诸如历遍监听事件需要使用闭包解决等问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;button&gt;一&lt;<span class="regexp">/button&gt;</span></div><div class="line"><span class="regexp">&lt;button&gt;二&lt;/</span>button&gt;</div><div class="line">&lt;button&gt;三&lt;<span class="regexp">/button&gt;</span></div><div class="line"><span class="regexp">&lt;button&gt;四&lt;/</span>button&gt;</div><div class="line"></div><div class="line">&lt;div id=<span class="string">"output"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">  <span class="keyword">var</span> buttons = <span class="built_in">document</span>.querySelectorAll(<span class="string">'button'</span>)</div><div class="line">  <span class="keyword">var</span> output = <span class="built_in">document</span>.querySelector(<span class="string">'#output'</span>)</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</div><div class="line">    buttons[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      output.innerText = buttons[i].innerText</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure><p>前端新手非常容易写出类似的代码，因为从直观的角度看这段代码并没有语义上的错误，但是当我们点击任意一个按钮时，就会报出这样的错误信息：</p><p><code>Uncaught TypeError: Cannot read property &#39;innerText&#39; of undefined</code></p><p>出现这个错误的原因是因为 buttons[i] 不存在，即为 undefined。</p><p>为什么会出现按钮不存在结果呢？通过排查，我们可以发现，每次我们点击按钮时，事件监听回调函数中得到的变量 i 都会等于 buttons.length，也就是这里的 4。而 buttons[4] 恰恰不存在，所以导致了错误的发生。</p><p>再而导致 i 得到的值都是 buttons.length 的原因就是因为 JavaScript 中没有块级作用域，而使对 i 的变量引用(Reference)一直保持在上一层作用域（循环语句所在层）上，而当循环结束时 i 则正好是 buttons.length。</p><p>而在 ES6 中，<strong>我们只需做出一个小小的改动</strong>，便可以解决该问题（假设所使用的浏览器已经支持所需要的特性）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">for</span> (<span class="comment">/* var */</span> <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure><p>通过把 for 语句中对计数器 i 的定义语句从 var 换成 let，即可。因为 let 语句会使该变量处于一个块级作用域中，从而让事件监听回调函数中的变量引用得到保持。我们不妨看看改进后的代码经过 babel 的编译会变成什么样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">var</span> _loop = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</div><div class="line">  buttons[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    output.innerText = buttons[i].innerText</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</div><div class="line">  _loop(i)</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure><p>实现方法一目了然，通过传值的方法防止了 i 的值错误。</p><h2 id="箭头函数-Arrow-Function"><a href="#箭头函数-Arrow-Function" class="headerlink" title="箭头函数(Arrow Function)"></a>箭头函数(Arrow Function)</h2><p>继 let 和 const 之后，箭头函数就是使用率最高的新特性了。当然了，如果你了解过 Scala 或者曾经如日中天的 JavaScript 衍生语言 CoffeeScript，就会知道箭头函数并非 ES6 独创。</p><p>箭头函数，顾名思义便是使用箭头(=&gt;)进行定义的函数，属于匿名函数（Lambda）一类。当然了，也可以作为定义式函数使用，但我们并不推荐这样做，随后会详细解释。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>箭头函数有好几种使用语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">foo =&gt; foo + <span class="string">' world'</span> <span class="comment">// means return `foo + ' world'`</span></div><div class="line"></div><div class="line">(foo, bar) =&gt; foo + bar</div><div class="line"></div><div class="line">foo =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> foo + <span class="string">' world'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">(foo, bar) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> foo + bar</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上都是被支持的箭头函数表达方式，其最大的好处便是简洁明了，省略了 function 关键字，而使用 =&gt; 代替。</p><p>箭头函数语言简洁的特点使其特别适合用於单行回调函数的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> names = [ <span class="string">'Will'</span>, <span class="string">'Jack'</span>, <span class="string">'Peter'</span>, <span class="string">'Steve'</span>, <span class="string">'John'</span>, <span class="string">'Hugo'</span>, <span class="string">'Mike'</span> ]</div><div class="line"></div><div class="line"><span class="keyword">let</span> newSet = names</div><div class="line">  .map(<span class="function">(<span class="params">name, index</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      id: index,</div><div class="line">      name: name</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  .filter(<span class="function"><span class="params">man</span> =&gt;</span> man.id % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">  .map(<span class="function"><span class="params">man</span> =&gt;</span> [man.name])</div><div class="line">  .reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(b))</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(newSet) <span class="comment">//=&gt; [ 'Will', 'Peter', 'John', 'Mike' ]</span></div></pre></td></tr></table></figure><h3 id="箭头函数与上下文绑定"><a href="#箭头函数与上下文绑定" class="headerlink" title="箭头函数与上下文绑定"></a>箭头函数与上下文绑定</h3><p>事实上，箭头函数在 ES2015 标准中，并不只是作为一种新的语法出现。就如同它在 CoffeeScript 中的定义一般，是用于对函数内部的上下文 （this）绑定为定义函数所在的作用域的上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  hello: <span class="string">'world'</span>,</div><div class="line">  foo() &#123;</div><div class="line">    <span class="keyword">let</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.hello</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bar</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.hello = <span class="string">'ES6'</span></div><div class="line"><span class="built_in">window</span>.bar = obj.foo()</div><div class="line"><span class="built_in">window</span>.bar() <span class="comment">//=&gt; 'world'</span></div></pre></td></tr></table></figure><p>上面代码中的 obj.foo 等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">foo() &#123;</div><div class="line">  <span class="keyword">let</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hello</div><div class="line">  &#125;).bind(<span class="keyword">this</span>)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> bar</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>另外，要注意的是，箭头函数对上下文的绑定是强制性的，无法通过 apply 或 call 方法改变其上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  init() &#123;</div><div class="line">    <span class="keyword">this</span>.bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.dam</div><div class="line">  &#125;,</div><div class="line">  dam: <span class="string">'hei'</span>,</div><div class="line">  foo() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dam</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> b = &#123;</div><div class="line">  dam: <span class="string">'ha'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">a.init()</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a.foo()) <span class="comment">//=&gt; hei</span></div><div class="line"><span class="built_in">console</span>.log(a.foo.bind(b).call(a)) <span class="comment">//=&gt; ha</span></div><div class="line"><span class="built_in">console</span>.log(a.bar.call(b)) <span class="comment">//=&gt; hei</span></div></pre></td></tr></table></figure><p>另外，因为箭头函数会绑定上下文的特性，故不能随意在顶层作用域使用箭头函数，以防出错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设当前运行环境为浏览器，故顶层作上下文为 `window`</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  msg: <span class="string">'pong'</span>,</div><div class="line"></div><div class="line">  ping: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.msg <span class="comment">// Warning!</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.ping() <span class="comment">//=&gt; undefined</span></div><div class="line"><span class="keyword">let</span> msg = <span class="string">'bang!'</span></div><div class="line">obj.ping() <span class="comment">//=&gt; bang!</span></div></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串模板出现简直对 Node.js 应用的开发和 Node.js 自身的发展起到了相当大的推动作用！我的意思并不是说这个原生的模板字符串能代替现有的模板引擎，而是说它的出现可以让非常多的字符串使用变得尤为轻松。</p><p>模板字符串要求使用 ` 代替原本的单/双引号来包裹字符串内容。它有两大特点：</p><ol><li>支持变量注入</li><li>支持换行</li></ol><h3 id="支持变量注入-useful"><a href="#支持变量注入-useful" class="headerlink" title="支持变量注入(useful)"></a>支持变量注入(useful)</h3><p>模板字符串之所以称之为“模板”，就是因为它允许我们在字符串中引用外部变量，而不需要像以往需要不断地相加、相加、相加……</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'Will Wen Gunn'</span></div><div class="line"><span class="keyword">let</span> title = <span class="string">'Founder'</span></div><div class="line"><span class="keyword">let</span> company = <span class="string">'LikMoon Creation'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> greet = <span class="string">`Hi, I'm <span class="subst">$&#123;name&#125;</span>, I am the <span class="subst">$&#123;title&#125;</span> at <span class="subst">$&#123;company&#125;</span>`</span></div><div class="line"><span class="built_in">console</span>.log(greet) <span class="comment">//=&gt; Hi, I'm Will Wen Gunn, I am the Founder at LikMoon Creation</span></div></pre></td></tr></table></figure><h3 id="支持换行"><a href="#支持换行" class="headerlink" title="支持换行"></a>支持换行</h3><p>无论是上面的哪一种，都会让我们感到很不爽。但若使用模板字符串，仿佛打开了新世界的大门~</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sql = <span class="string">`</span></div><div class="line"><span class="string">SELECT * FROM Users</span></div><div class="line"><span class="string">WHERE FirstName='Mike'</span></div><div class="line"><span class="string">LIMIT 5;</span></div><div class="line"><span class="string">`</span></div></pre></td></tr></table></figure><h2 id="对象字面量扩展语法"><a href="#对象字面量扩展语法" class="headerlink" title="对象字面量扩展语法"></a>对象字面量扩展语法</h2><p>(本质上还是语法糖，但是挺爽的)</p><h3 id="方法属性省略-function-useful"><a href="#方法属性省略-function-useful" class="headerlink" title="方法属性省略 function (useful)"></a>方法属性省略 function (useful)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="comment">// before</span></div><div class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'foo'</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// after</span></div><div class="line">  bar() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'bar'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="同名方法属性省略语法"><a href="#同名方法属性省略语法" class="headerlink" title="同名方法属性省略语法"></a>同名方法属性省略语法</h3><p>也是看上去有点鸡肋的新特性，不过在做 JavaScript 模块化工程的时候则有了用武之地。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// module.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  someMethod</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">someMethod</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">import</span> Module <span class="keyword">from</span> <span class="string">'./module'</span></div><div class="line"></div><div class="line">Module.someMethod()</div></pre></td></tr></table></figure><h3 id="可以动态计算的属性名称"><a href="#可以动态计算的属性名称" class="headerlink" title="可以动态计算的属性名称"></a>可以动态计算的属性名称</h3><p>这个特性相当有意思，也是可以用在一些特殊的场景中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">let</span> outArr = arr.map(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    [ n ]: n,</div><div class="line">    [ <span class="string">`<span class="subst">$&#123;n&#125;</span>^2`</span> ]: <span class="built_in">Math</span>.pow(n, <span class="number">2</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.dir(outArr) <span class="comment">//=&gt;</span></div><div class="line">  [</div><div class="line">    &#123; <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'1^2'</span>: <span class="number">1</span> &#125;,</div><div class="line">    &#123; <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'2^2'</span>: <span class="number">4</span> &#125;,</div><div class="line">    &#123; <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'3^2'</span>: <span class="number">9</span> &#125;</div><div class="line">  ]</div></pre></td></tr></table></figure><h3 id="表达式解构-useful"><a href="#表达式解构-useful" class="headerlink" title="表达式解构(useful)"></a>表达式解构(useful)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Matching with object</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">query</span>) </span>&#123;</div><div class="line">  <span class="comment">/* 交换变量 */</span></div><div class="line">  [x, y] = [y, x];</div><div class="line"></div><div class="line">  <span class="comment">/* 从函数返回多个值 */</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    foo: <span class="number">1</span>,</div><div class="line">    bar: <span class="number">2</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">  <span class="keyword">let</span> &#123; foo, bar &#125; = example();</div><div class="line"></div><div class="line">  <span class="comment">/* 函数参数的定义 */</span></div><div class="line">  <span class="comment">// 参数是一组有次序的值</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class="line">  f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line">  <span class="comment">// 参数是一组无次序的值</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class="line">  f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* 提取json数据 */</span></div><div class="line">  <span class="keyword">let</span> jsonData = &#123;</div><div class="line">    id: <span class="number">42</span>,</div><div class="line">    status: <span class="string">"OK"</span>,</div><div class="line">    data: [<span class="number">867</span>, <span class="number">5309</span>]</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</div><div class="line"></div><div class="line">  <span class="comment">/* 函数参数的默认 */</span></div><div class="line">  jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></div><div class="line"><span class="function"><span class="params">    async = true,</span></span></div><div class="line"><span class="function"><span class="params">    beforeSend = function (</span>) </span>&#123;&#125;,</div><div class="line">    cache = <span class="literal">true</span>,</div><div class="line">    complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">    crossDomain = <span class="literal">false</span>,</div><div class="line">    global = <span class="literal">true</span>,</div><div class="line">    <span class="comment">// ... more config</span></div><div class="line">  &#125; = &#123;&#125;) &#123;</div><div class="line">    <span class="comment">// ... do stuff</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/* 导入模块 */</span></div><div class="line">  <span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</div></pre></td></tr></table></figure><h2 id="函数参数表达、传参"><a href="#函数参数表达、传参" class="headerlink" title="函数参数表达、传参"></a>函数参数表达、传参</h2><p>这个特性有非常高的使用频率，一个简单的语法糖解决了从前需要一两行代码才能实现的功能。</p><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>这个特性在类库开发中相当有用，比如实现一些可选参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span></div><div class="line"><span class="keyword">import</span> readline <span class="keyword">from</span> <span class="string">'readline'</span></div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLineInFile</span>(<span class="params">filename, callback = noop, complete = noop</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> rl = readline.createInterface(&#123;</div><div class="line">    input: fs.createReadStream(path.resolve(__dirname, filename))</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  rl.on(<span class="string">'line'</span>, line =&gt; &#123;</div><div class="line">    <span class="comment">//... do something with the current line</span></div><div class="line">    callback(line)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  rl.on(<span class="string">'close'</span>, complete)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> rl</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</div><div class="line"></div><div class="line">readLineInFile(<span class="string">'big_file.txt'</span>, line =&gt; &#123;</div><div class="line">  <span class="comment">// ...</span></div></pre></td></tr></table></figure><h3 id="后续参数"><a href="#后续参数" class="headerlink" title="后续参数"></a>后续参数</h3><p>我们知道，函数的 call 和 apply 在使用上的最大差异便是一个在首参数后传入各个参数，一个是在首参数后传入一个包含所有参数的数组。如果我们在实现某些函数或方法时，也希望实现像 call 一样的使用方法，在 ES2015 之前，我们可能需要这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchSomethings</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = [].slice.apply(<span class="built_in">arguments</span>)</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeOthers</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = [].slice.apply(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而在 ES2015 中，我们可以很简单的使用 … 语法糖来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchSomethings</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeOthers</span>(<span class="params">name, ...args</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>要注意的是，…args 后不可再添加</p><p>虽然从语言角度看，arguments 和 …args 是可以同时使用 ，但有一个特殊情况则不可：arguments 在箭头函数中，会跟随上下文绑定到上层，所以在不确定上下文绑定结果的情况下，尽可能不要再箭头函数中再使用 arguments，而使用 …args。</p><p>虽然 ECMA 委员会和各类编译器都无强制性要求用 …args 代替 arguments，但从实践经验看来，…args 确实可以在绝大部份场景下可以代替 arguments 使用，除非你有很特殊的场景需要使用到 arguments.callee 和 arguments.caller。所以我推荐都使用 …args 而非 arguments。</p><p>PS：在严格模式（Strict Mode）中，arguments.callee 和 arguments.caller 是被禁止使用的。</p><h3 id="解构传参"><a href="#解构传参" class="headerlink" title="解构传参"></a>解构传参</h3><p>在 ES2015 中，… 语法还有另外一个功能：无上下文绑定的 apply。什么意思？看看代码你就知道了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> args.map(<span class="built_in">Number</span>)</div><div class="line">    .reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sum(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">//=&gt; 6</span></div></pre></td></tr></table></figure><p>有什么卵用？我也不知道(⊙o⊙)… Sorry…</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>默认参数值</code>和<code>后续参数</code>需要遵循顺序原则，否则会出错。<br><code>function(...args, last = 1) {  // This will go wrong}</code></p><h2 id="新的数据结构"><a href="#新的数据结构" class="headerlink" title="新的数据结构"></a>新的数据结构</h2><p>在介绍新的数据结构之前，我们先复习一下在 ES2015 之前，JavaScript 中有哪些基本的数据结构。</p><ul><li>String 字符串</li><li>Number 数字（包含整型和浮点型）</li><li>Boolean 布尔值</li><li>Object 对象</li><li>Array 数组</li></ul><p>其中又分为<code>值类型</code>和<code>引用类型</code>，Array 其实是 Object 的一种子类。</p><h3 id="Set-和-WeakSet"><a href="#Set-和-WeakSet" class="headerlink" title="Set 和 WeakSet"></a>Set 和 WeakSet</h3><p>我们再来复习下高中数学吧，集不能包含相同的元素，我们可以根据元素画出多个集的韦恩图…………</p><p>好了跑题了。是的，在 ES2015 中，ECMA 委员会为 ECMAScript 增添了集(Set)和“弱”集(WeakSet)。它们都具有元素唯一性，若添加了已存在的元素，会被自动忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</div><div class="line">s.add(<span class="string">'hello'</span>).add(<span class="string">'world'</span>).add(<span class="string">'hello'</span>)</div><div class="line"><span class="built_in">console</span>.log(s.size) <span class="comment">//=&gt; 2</span></div><div class="line"><span class="built_in">console</span>.log(s.has(<span class="string">'hello'</span>)) <span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure><p>在实际开发中，我们有很多需要用到集的场景，如搜索、索引建立等。</p><p>WeakSet 在 JavaScript 底层作出调整（在非降级兼容的情况下），检查元素的变量引用情况。如果元素的引用已被全部解除，则该元素就会被删除，以节省内存空间。这意味著无法直接加入数字或者字符串。另外 WeakSet 对元素有严格要求，必须是 Object，当然了，你也可以用 new String(‘…’) 等形式处理元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> weaks = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</div><div class="line">weaks.add(<span class="string">"hello"</span>) <span class="comment">//=&gt; Error</span></div><div class="line">weaks.add(<span class="number">3.1415</span>) <span class="comment">//=&gt; Error</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"bar"</span>)</div><div class="line"><span class="keyword">let</span> pi = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3.1415</span>)</div><div class="line">weaks.add(foo)</div><div class="line">weaks.add(pi)</div><div class="line">weaks.has(foo) <span class="comment">//=&gt; true</span></div><div class="line">foo = <span class="literal">null</span></div><div class="line">weaks.has(foo) <span class="comment">//=&gt; false</span></div></pre></td></tr></table></figure><h3 id="Map-和-WeakMap"><a href="#Map-和-WeakMap" class="headerlink" title="Map 和 WeakMap"></a>Map 和 WeakMap</h3><p>从数据结构的角度来说，映射（Map）跟原本的 Object 非常相似，都是 Key/Value 的键值对结构。但是 Object 有一个让人非常不爽的限制：key 必须是字符串或数字。在一般情况下，我们并不会遇上这一限制，但若我们需要建立一个对象映射表时，这一限制显得尤为棘手。</p><p>而 Map 则解决了这一问题，可以使用任何对象作为其 key，这可以实现从前不能实现或难以实现的功能，如在项目逻辑层实现数据索引等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</div><div class="line"><span class="keyword">let</span> object = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</div><div class="line"></div><div class="line">map.set(object, <span class="string">'hello'</span>)</div><div class="line">map.set(<span class="string">'hello'</span>, <span class="string">'world'</span>)</div><div class="line">map.has(object) <span class="comment">//=&gt; true</span></div><div class="line">map.get(object) <span class="comment">//=&gt; hello</span></div></pre></td></tr></table></figure><p>而 WeakMap 和 WeakSet 很类似，只不过 WeakMap 的键和值都会检查变量引用，只要其一的引用全被解除，该键值对就会被删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> weakm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</div><div class="line"><span class="keyword">let</span> keyObject = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</div><div class="line"><span class="keyword">let</span> valObject = &#123; <span class="attr">score</span>: <span class="number">100</span> &#125;</div><div class="line"></div><div class="line">weakm.set(keyObject, valObject)</div><div class="line">weakm.get(keyObject) <span class="comment">//=&gt; &#123; score: 100 &#125;</span></div><div class="line">keyObject = <span class="literal">null</span></div><div class="line">weakm.has(keyObject) <span class="comment">//=&gt; false</span></div></pre></td></tr></table></figure><h2 id="类-Classes"><a href="#类-Classes" class="headerlink" title="类(Classes)"></a>类(Classes)</h2><p>类，作为自 JavaScript 诞生以来最大的痛点之一，终于在 ES2015 中得到了官方的妥协，“实现”了 ECMAScript 中的标准类机制。为什么是带有双引号的呢？因为我们不难发现这样一个现象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</div><div class="line">[<span class="built_in">Function</span>: Foo]</div></pre></td></tr></table></figure><p>回想一下在 ES2015 以前的时代中，我们是怎么在 JavaScript 中实现类的？<br><code>function Foo() {}var foo = new Foo()</code></p><p>是的，ES6 中的类只是一种语法糖，用于定义原型(Prototype)的。当然，饿死的厨师三百斤，有总比没有强，我们还是很欣然地接受了这一设定。</p><h3 id="遗憾与期望"><a href="#遗憾与期望" class="headerlink" title="遗憾与期望"></a>遗憾与期望</h3><p>就目前来说，ES2015 的类机制依然很鸡肋：</p><ol><li>不支持私有属性（private）</li><li>不支持前置属性定义，但可用 get 语句和 set 语句实现</li><li>不支持多重继承</li></ol><p>没有类似于协议（Protocl）或接口（Interface）等的概念<br>中肯地说，ES2015 的类机制依然有待加强。但总的来说，是值得尝试和讨论的，我们可以像从前一样，不断尝试新的方法，促进 ECMAScript 标准的发展。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise，作为一个老生常谈的话题，早已被聪明的工程师们“玩坏”了。</p><p>光是 Promise 自身，目前就有多种标准，而目前最为流行的是 Promises/A+。而 ES2015 中的 Promise 便是基于 Promises/A+ 制定的。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Promise 是一种用于解决回调函数无限嵌套的工具（当然，这只是其中一种），其字面意义为“保证”。它的作用便是“免去”异步操作的回调函数，保证能通过后续监听而得到返回值，或对错误处理。它能使异步操作变得井然有序，也更好控制。我们以在浏览器中访问一个 API，解析返回的 JSON 数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'http://example.com/api/users/top'</span>)</div><div class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    vm.data.topUsers = data</div><div class="line">  &#125;)</div><div class="line">  <span class="comment">// Handle the error crash in the chaining processes</span></div><div class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</div></pre></td></tr></table></figure><p>Promise 在设计上具有原子性，即只有两种状态：未开始和结束（无论成功与否都算是结束），这让我们在调用支持 Promise 的异步方法时，逻辑将变得非常简单，这在大规模的软件工程开发中具有良好的健壮性。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="创建-Promise-对象"><a href="#创建-Promise-对象" class="headerlink" title="创建 Promise 对象"></a>创建 Promise 对象</h4><p>要为一个函数赋予 Promise 的能力，先要创建一个 Promise 对象，并将其作为函数值返回。Promise 构造函数要求传入一个函数，并带有 resolve 和 reject 参数。这是两个用于结束 Promise 等待的函数，对应的成功和失败。而我们的逻辑代码就在这个函数中进行。</p><p>此处，因为必须要让这个函数包裹逻辑代码，所以如果需要用到 this 时，则需要使用箭头函数或者在前面做一个 this 的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="进行异步操作"><a href="#进行异步操作" class="headerlink" title="进行异步操作"></a>进行异步操作</h4><p>事实上，在异步操作内，并不需要对 Promise 对象进行操作（除非有特殊需求）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    api.call(<span class="string">'fetch_data'</span>, (err, data) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err)</div><div class="line"></div><div class="line">      resolve(data)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为在 Promise 定义的过程中，也会出现数层回调嵌套的情况，如果需要使用 this 的话，便显现出了箭头函数的优势了。</p><h4 id="使用-Promise"><a href="#使用-Promise" class="headerlink" title="使用 Promise"></a>使用 Promise</h4><p>让异步操作函数支持 Promise 后，我们就可以享受 Promise 带来的优雅和便捷了~</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fetchData()</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> storeInFileSystem(data)</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> renderUIAnimated(data)</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</div></pre></td></tr></table></figure><h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>虽说 Promise 确实很优雅，但是这是在所有需要用到的异步方法都支持 Promise 且遵循标准。而且链式 Promise 强制性要求逻辑必须是线性单向的，一旦出现如并行、回溯等情况，Promise 便显得十分累赘。</p><p>所以在目前的最佳实践中，Promise 会作为一种接口定义方法，而不是逻辑处理工具。后文将会详细阐述这种最佳实践。</p><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol 是一种很有意思的概念，它跟 Swift 中的 Selector 有点相像，但也更特别。在 JavaScript 中，对象的属性名称可以是字符串或数字。而如今又多了一个 Symbol。那 Symbol 究竟有什么用？</p><p>首先，我们要了解的是，Symbol 对象是具有唯一性的，也就是说，每一个 Symbol 对象都是唯一的，即便我们看不到它的区别在哪里。这就意味著，我们可以用它来保证一些数据的安全性。<br><code>console.log(Symbol(&#39;key&#39;) == Symbol(&#39;key&#39;)) //=&gt; false</code></p><p>如果将一个 Symbol 隐藏于一个封闭的作用域内，并作为一个对象中某属性的键，则外层作用域中便无法取得该属性的值，有效保障了某些私有库的代码安全性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> privateDataStore = &#123;</div><div class="line">  set(val) &#123;</div><div class="line">    <span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="built_in">Math</span>.random().toString(<span class="number">32</span>).substr(<span class="number">2</span>))</div><div class="line">    <span class="keyword">this</span>[key] = val</div><div class="line"></div><div class="line">    <span class="keyword">return</span> key</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  get(key) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[key]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> key = privateDateStore(<span class="string">'hello world'</span>)</div><div class="line">privateDataStore[key] <span class="comment">//=&gt; undefined</span></div><div class="line">privateDataStore.get(key) <span class="comment">//=&gt; hello world</span></div></pre></td></tr></table></figure><h2 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy(代理)"></a>Proxy(代理)</h2><p>Proxy 是 ECMAScript 中的一种新概念，它有很多好玩的用途，从基本的作用说就是：Proxy 可以在不入侵目标对象的情况下，对逻辑行为进行拦截和处理。</p><p>比如说我想记录下我代码中某些接口的使用情况，以供数据分析所用，但是因为目标代码中是严格控制的，所以不能对其进行修改，而另外写一个对象来对目标对象做代理也很麻烦。那么 Proxy 便可以提供一种比较简单的方法来实现这一需求。</p><blockquote><p>注意，要使得代理起作用，必须对proxy对象操作而不是原对象</p></blockquote><p>假设我要对 api 这一对象进行拦截并记录下代码行为，我就可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> apiProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;</div><div class="line">  get(receiver, name) &#123;</div><div class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">      min.sadd(<span class="string">`log:<span class="subst">$&#123;name&#125;</span>`</span>, args)</div><div class="line">      <span class="keyword">return</span> receiver[name].apply(receiver, args)</div><div class="line">    &#125;).bind(receiver)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">api.getComments(artical.id)</div><div class="line">  .then(<span class="function"><span class="params">comments</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;)</div></pre></td></tr></table></figure><h1 id="3-ES7"><a href="#3-ES7" class="headerlink" title="3.ES7"></a>3.ES7</h1><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>上文中我们提及到 co 是一个利用 Generator 模拟 ES7 中 async/await 特性的工具，那么，这个 async/await 究竟又是什么呢？它跟 co 又有什么区别呢？</p><p>我们知道，Generator Function 与普通的 Function 在执行方式上有著本质的区别，在某种意义上是无法共同使用的。但是，对于 ES7 的 Async Function 来说，这一点并不存在！它可以以普通函数的执行方式使用，并且有著 Generator Function 的异步优越性，它甚至可以作为事件响应函数使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(<span class="string">'/api/fetch/data'</span>)</div><div class="line">  <span class="keyword">let</span> reply = <span class="keyword">await</span> res.json()</div><div class="line"></div><div class="line">  <span class="keyword">return</span> reply</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> reply = fetchData() <span class="comment">//=&gt; DATA...</span></div></pre></td></tr></table></figure><h2 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a>Decorators</h2><p>对于 JavaScript 开发者来说，Decorators 又是一种新的概念，不过它在 Python 等语言中早已被玩出各种花式。</p><p>Decorator 的定义如下：</p><ul><li>是一个表达式</li><li>Decorator 会调用一个对应的函数</li><li>调用的函数中可以包含 target（装饰的目标对象）、name（装饰目标的名称）和 descriptor（描述器）三个参数</li><li>调用的函数可以返回一个新的描述器以应用到装饰目标对象上</li></ul><p>PS：如果你不记得 descriptor 是什么的话，请回顾一下 Object.defineProperty() 方法。</p><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>我们在实现一个类的时候，有的属性并不想被 for..in 或 Object.keys() 等方法检索到，那么在 ES5 时代，我们会用到 Object.defineProperty() 方法来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  foo: <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'bar'</span>, &#123;</div><div class="line">  enumerable: <span class="literal">false</span>,</div><div class="line">  value: <span class="number">2</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj.bar) <span class="comment">//=&gt; 2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> keys = []</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj)</div><div class="line">  keys.push(key)</div><div class="line"><span class="built_in">console</span>.log(keys) <span class="comment">//=&gt; [ 'foo' ]</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)) <span class="comment">//=&gt; [ 'foo' ]</span></div></pre></td></tr></table></figure><p>那么在 ES7 中，我们可以用 Decorator 来很简单地实现这个需求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.foo = <span class="number">1</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @nonenumerable</div><div class="line">  get bar() &#123; <span class="keyword">return</span> <span class="number">2</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonenumerable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</div><div class="line">  descriptor.enumerable = <span class="literal">false</span></div><div class="line">  <span class="keyword">return</span> descriptor</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obj()</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj.foo) <span class="comment">//=&gt; 1</span></div><div class="line"><span class="built_in">console</span>.log(obj.bar) <span class="comment">//=&gt; 2</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)) <span class="comment">//=&gt; [ 'foo' ]</span></div></pre></td></tr></table></figure><h2 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h2><blockquote><p>修饰器是一个对类进行处理的函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</div><div class="line">    target.isTestable = isTestable;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@testable(<span class="literal">true</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</div><div class="line">MyTestableClass.isTestable <span class="comment">// true</span></div><div class="line"></div><div class="line">@testable(<span class="literal">false</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</div><div class="line">MyClass.isTestable <span class="comment">// false</span></div></pre></td></tr></table></figure><h3 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h3><p>正如上面所说，Decorator 在编程中早已不是什么新东西，特别是在 Python 中早已被玩出各种花样。聪明的工程师们看到 ES7 的支持当然不会就此收手，就让我们看看我们还能用 Decorator 做点什么神奇的事情。</p><p>假如我们要实现一个类似于 Koa 和 PHP 中的 CI 的框架，且利用 Decorator 特性实现 URL 路由，我们可以这样做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 框架内部</span></div><div class="line"><span class="comment">// 控制器</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> handlers = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</div><div class="line"><span class="keyword">var</span> urls = &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义控制器</span></div><div class="line">@route(<span class="string">'/'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.msg = <span class="string">'World'</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">async</span> GET(ctx) &#123;</div><div class="line">    ctx.body = <span class="string">`Hello <span class="subst">$&#123;<span class="keyword">this</span>.msg&#125;</span>`</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Router Decorator</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">target</span> =&gt;</span> &#123;</div><div class="line">    target.url = url</div><div class="line">    <span class="keyword">let</span> urlObject = <span class="keyword">new</span> <span class="built_in">String</span>(url)</div><div class="line">    urls[url] = urlObject</div><div class="line"></div><div class="line">    handlers.set(urlObject, target)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 路由执行部份</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">router</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (urls[url]) &#123;</div><div class="line">    <span class="keyword">var</span> handlerClass = handlers.get(urls[url])</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> handlerClass()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> handler = router(<span class="string">'/'</span>)</div><div class="line"><span class="keyword">if</span> (handler) &#123;</div><div class="line">  <span class="keyword">let</span> context = &#123;&#125;</div><div class="line">  handler.GET(context)</div><div class="line">  <span class="built_in">console</span>.log(context.body)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最重要的是，同一个修饰对象是可以同时使用多个修饰器的，所以说我们还可以用修饰器实现很多很多有意思的功能。</p><h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><h2 id="let取代var"><a href="#let取代var" class="headerlink" title="let取代var"></a>let取代var</h2><blockquote><p>let和var作用相似，而且let没有副作用</p></blockquote><h2 id="全局常量和线程安全"><a href="#全局常量和线程安全" class="headerlink" title="全局常量和线程安全"></a>全局常量和线程安全</h2><blockquote><p>在let和const之间，建议优先选择const，尤其是在全局环境，不应该设置变量，只应该设置常量</p></blockquote><p>const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。</p><p>const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。<br>所有的函数都应该设置为常量。</p><p>长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>静态字符串一律使用单引号或者反引号，动态字符串使用双引号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> a = <span class="string">"foobar"</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="string">'foo'</span> + a + <span class="string">'bar'</span>;</div><div class="line"></div><div class="line"><span class="comment">// acceptable</span></div><div class="line"><span class="keyword">const</span> c = <span class="string">`foobar`</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> a = <span class="string">'foobar'</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="string">`foo<span class="subst">$&#123;a&#125;</span>bar`</span>;</div></pre></td></tr></table></figure><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>使用数组成员对变量赋值时，优先使用解构赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>];</div><div class="line"><span class="keyword">const</span> second = arr[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> [first, second] = arr;</div></pre></td></tr></table></figure><p>函数的参数如果是对象的成员，优先使用解构赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> firstName = user.firstName;</div><div class="line">  <span class="keyword">const</span> lastName = user.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; firstName, lastName &#125; = obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [left, right, top, bottom];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; left, right, top, bottom &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; left, right &#125; = processInput(input);</div></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2, &#125;;</div><div class="line"><span class="keyword">const</span> b = &#123;</div><div class="line">  k1: v1,</div><div class="line">  k2: v2</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2 &#125;;</div><div class="line"><span class="keyword">const</span> b = &#123;</div><div class="line">  k1: v1,</div><div class="line">  k2: v2,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> a = &#123;&#125;;</div><div class="line">a.x = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="comment">// if reshape unavoidable</span></div><div class="line"><span class="keyword">const</span> a = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(a, &#123; <span class="attr">x</span>: <span class="number">3</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="literal">null</span> &#125;;</div><div class="line">a.x = <span class="number">3</span>;</div></pre></td></tr></table></figure><p>对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ref = <span class="string">'some value'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> atom = &#123;</div><div class="line">  ref: ref,</div><div class="line"></div><div class="line">  value: <span class="number">1</span>,</div><div class="line"></div><div class="line">  addValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> atom.value + value;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> atom = &#123;</div><div class="line">  ref,</div><div class="line"></div><div class="line">  value: <span class="number">1</span>,</div><div class="line"></div><div class="line">  addValue(value) &#123;</div><div class="line">    <span class="keyword">return</span> atom.value + value;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>使用扩展运算符（…）拷贝数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> len = items.length;</div><div class="line"><span class="keyword">const</span> itemsCopy = [];</div><div class="line"><span class="keyword">let</span> i;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">  itemsCopy[i] = items[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure><p>使用 Array.from 方法，将类似数组的对象转为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>);</div><div class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo);</div></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>立即执行函数可以写成箭头函数的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet.'</span>);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div></pre></td></tr></table></figure><p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, option = false </span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, &#123; option = false &#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用默认值语法设置函数参数的默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</div><div class="line">  opts = opts || &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="map结构"><a href="#map结构" class="headerlink" title="map结构"></a>map结构</h2><p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params">contents = []</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>._queue = [...contents];</div><div class="line">&#125;</div><div class="line">Queue.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">  <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(contents = []) &#123;</div><div class="line">    <span class="keyword">this</span>._queue = [...contents];</div><div class="line">  &#125;</div><div class="line">  pop() &#123;</div><div class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">    <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> inherits = <span class="built_in">require</span>(<span class="string">'inherits'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PeekableQueue</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">  Queue.apply(<span class="keyword">this</span>, contents);</div><div class="line">&#125;</div><div class="line">inherits(PeekableQueue, Queue);</div><div class="line">PeekableQueue.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekableQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">  peek() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'moduleA'</span>);</div><div class="line"><span class="keyword">const</span> func1 = moduleA.func1;</div><div class="line"><span class="keyword">const</span> func2 = moduleA.func2;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> &#123; func1, func2 &#125; <span class="keyword">from</span> <span class="string">'moduleA'</span>;</div></pre></td></tr></table></figure><blockquote><p>如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用</p></blockquote><p>不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</div></pre></td></tr></table></figure><p>如果模块默认输出一个函数，函数名的首字母应该小写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeStyleGuide</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> makeStyleGuide;</div></pre></td></tr></table></figure><p>如果模块默认输出一个对象，对象名的首字母应该大写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> StyleGuide = &#123;</div><div class="line">  es6: &#123;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> StyleGuide;</div></pre></td></tr></table></figure><h3 id="ES6的模块和commonJs的不同"><a href="#ES6的模块和commonJs的不同" class="headerlink" title="ES6的模块和commonJs的不同"></a>ES6的模块和commonJs的不同</h3><ul><li>commonjs模块输出的是一个值的拷贝，es6输出的是值的引用</li><li>commonjs是运行时加载，es6是编译时输出接口</li></ul><p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  counter: counter,</div><div class="line">  incCounter: incCounter,</div><div class="line">&#125;;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></div><div class="line">mod.incCounter();</div><div class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></div></pre></td></tr></table></figure><p>上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  get counter() &#123;</div><div class="line">    <span class="keyword">return</span> counter</div><div class="line">  &#125;,</div><div class="line">  incCounter: incCounter,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node main.js</div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure><p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</div><div class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></div><div class="line">incCounter();</div><div class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></div></pre></td></tr></table></figure><p>上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化</p><blockquote><p>ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块<br>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</div><div class="line"></div><div class="line">obj.prop = <span class="number">123</span>; <span class="comment">// OK</span></div><div class="line">obj = &#123;&#125;; <span class="comment">// TypeError</span></div></pre></td></tr></table></figure><blockquote><p>上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量</p></blockquote><p>最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mod.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.sum += <span class="number">1</span>;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sum);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</div></pre></td></tr></table></figure><p>上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES2015（ES6）和ES2016(ES7)的知识总结&lt;br&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>const,let,var</title>
    <link href="http://yoursite.com/2018/09/06/const-let-var/"/>
    <id>http://yoursite.com/2018/09/06/const-let-var/</id>
    <published>2018-09-06T00:50:03.000Z</published>
    <updated>2018-09-06T06:19:20.120Z</updated>
    
    <content type="html"><![CDATA[<p>一天看某位大佬的代码时，发现里面一个var也没有，当时就觉得惊为天人。当然学代码不能仅仅为了酷，酷当然是激励我们敲代码的一个重要理由，但我们也应该搞清楚为什么需要这么做，以便我们以后遇到了类似的问题知道该从什么样的思路出发<br><a id="more"></a></p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1背景介绍"><a href="#1-1背景介绍" class="headerlink" title="1.1背景介绍"></a>1.1背景介绍</h2><p>const，let实际上都是<a href="http://caibaojian.com/es6/" target="_blank" rel="external">es6</a>的新增内容</p><h2 id="1-2-参考资料"><a href="#1-2-参考资料" class="headerlink" title="1.2 参考资料"></a>1.2 参考资料</h2><ul><li><a href="http://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="external">阮一峰的es6标准入门</a></li><li><a href="http://www.infoq.com/cn/articles/es6-in-depth-let-and-const" target="_blank" rel="external">深入浅出es6</a></li></ul><h1 id="2-let"><a href="#2-let" class="headerlink" title="2.let"></a>2.let</h1><h2 id="2-1-let是更完美的var"><a href="#2-1-let是更完美的var" class="headerlink" title="2.1 let是更完美的var"></a>2.1 let是更完美的var</h2><blockquote><p>对于绝大多数代码而言，在es6的新标准下，你应该停止上使用var，能使用let就用吧</p></blockquote><h2 id="2-2-基本用法"><a href="#2-2-基本用法" class="headerlink" title="2.2 基本用法"></a>2.2 基本用法</h2><p>它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p><h2 id="2-3-不存在变量提升"><a href="#2-3-不存在变量提升" class="headerlink" title="2.3 不存在变量提升"></a>2.3 不存在变量提升</h2><h2 id="2-4-暂时性死区"><a href="#2-4-暂时性死区" class="headerlink" title="2.4 暂时性死区"></a>2.4 暂时性死区</h2><p>在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><p>暂时性死区”也意味着typeof不再是一个百分之百安全的操作。</p><blockquote><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p></blockquote><h2 id="2-5-不允许重复声明"><a href="#2-5-不允许重复声明" class="headerlink" title="2.5 不允许重复声明"></a>2.5 不允许重复声明</h2><h1 id="3-const"><a href="#3-const" class="headerlink" title="3 const"></a>3 const</h1><p>const在很多于语言都有体现，也很好理解了，即为声明一个只读的常量。一旦声明，常量的值就不能改变</p><h2 id="3-1-必须马上初始化"><a href="#3-1-必须马上初始化" class="headerlink" title="3.1 必须马上初始化"></a>3.1 必须马上初始化</h2><h2 id="3-2-不存在变量提升"><a href="#3-2-不存在变量提升" class="headerlink" title="3.2 不存在变量提升"></a>3.2 不存在变量提升</h2><h2 id="3-3-暂时性锁区"><a href="#3-3-暂时性锁区" class="headerlink" title="3.3 暂时性锁区"></a>3.3 暂时性锁区</h2><h2 id="3-4-const的本质"><a href="#3-4-const的本质" class="headerlink" title="3.4 const的本质"></a>3.4 const的本质</h2><p>对于简单数据类型const很好理解，但是对于符合类型的数据（数组和对象），只能保证那个变量所对应的地址不变，但对象本身还是可以修改的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一天看某位大佬的代码时，发现里面一个var也没有，当时就觉得惊为天人。当然学代码不能仅仅为了酷，酷当然是激励我们敲代码的一个重要理由，但我们也应该搞清楚为什么需要这么做，以便我们以后遇到了类似的问题知道该从什么样的思路出发&lt;br&gt;
    
    </summary>
    
      <category term="技术细节" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>前端工程师的ppt reveal.js</title>
    <link href="http://yoursite.com/2018/09/05/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84ppt-reveal-js/"/>
    <id>http://yoursite.com/2018/09/05/前端工程师的ppt-reveal-js/</id>
    <published>2018-09-05T06:23:17.000Z</published>
    <updated>2018-10-24T02:35:25.895Z</updated>
    
    <content type="html"><![CDATA[<p>不管是学生还是社畜，ppt始终是一个难以绕过的坎。没有艺术细胞的人对此的苦恼自不必说，即使对艺术感兴趣，限于时间和精力有限，我们也很难</p><a id="more"></a><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><h2 id="1-1-reveal-js是什么？"><a href="#1-1-reveal-js是什么？" class="headerlink" title="1.1 reveal.js是什么？"></a>1.1 reveal.js是什么？</h2><p>最开始我接触这个技术的时候是上次学习顾秩灵的<a href="http://justineo.github.io/slideshows/semantic-html/#/" target="_blank" rel="external">web语义化</a>，当时看的时候就觉得惊为天人，炫酷不说，而且和专业相关能够表现出自己的专业性</p><p>说了再多不如直接去看演示</p><p><img src="https://cdn.sspai.com/2017/08/29/4b2715265f01b94d10037572bf7f2948.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="gif"></p><p>它最突出的功能都在其官网主页展示得很清楚了，你只需要像坐火车一样静心欣赏它的美景就可以了</p><p>当然它最吸引我的还是其对markdown语法的支持，对于我这样重度md爱好者来说就是最好的福音</p><h2 id="1-2-它的优势"><a href="#1-2-它的优势" class="headerlink" title="1.2 它的优势"></a>1.2 它的优势</h2><ul><li>炫酷</li><li>可配置型不错（比不过ppt大佬，但强于一般人）</li><li>表现形式强</li><li>相比ppt碎片化表现感更强（ppt的基本展现单元是页，而这个可以是段）</li><li>支持markdown语法</li></ul><h2 id="1-3-相似的技术"><a href="#1-3-相似的技术" class="headerlink" title="1.3 相似的技术"></a>1.3 相似的技术</h2><ul><li><a href="http://imakewebthings.com/deck.js/#intro" target="_blank" rel="external">deck.js</a></li><li><a href="http://www.dowebok.com/107.html" target="_blank" rel="external">Scrollify</a></li><li><a href="https://github.com/alvarotrigo/fullPage.js/tree/master/lang/chinese#fullpagejs" target="_blank" rel="external">fullPage.js</a> [这个也非常好]</li><li><a href="http://bartaz.github.io/impress.js" target="_blank" rel="external">impress.js</a></li></ul><h1 id="2-参考资料"><a href="#2-参考资料" class="headerlink" title="2. 参考资料"></a>2. 参考资料</h1><ul><li><a href="https://sspai.com/post/40657" target="_blank" rel="external">把你的markdown变成PPT</a></li><li><a href="https://github.com/hakimel/reveal.js" target="_blank" rel="external">reveal.js的github地址</a></li><li><a href="https://revealjs.com/#/" target="_blank" rel="external">reveal.js的官方演示</a></li><li><a href="http://htmlcheats.com/reveal-js/reveal-js-tutorial-reveal-js-for-beginners/" target="_blank" rel="external">reveal.js tutorial</a></li></ul><h1 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h1><h2 id="3-1-一些快捷操作"><a href="#3-1-一些快捷操作" class="headerlink" title="3.1 一些快捷操作"></a>3.1 一些快捷操作</h2><ul><li>息屏 [B]</li><li>演讲者模式 [S] <img src="http://oy2kvpd7z.bkt.clouddn.com/md/1536131461154.png" alt="png"></li><li>缩放模式 [ESC]</li><li>全屏模式 [F]</li></ul><h2 id="3-2学习步骤"><a href="#3-2学习步骤" class="headerlink" title="3.2学习步骤"></a>3.2学习步骤</h2><p>多说无益，直接去看我上面列出的参考资料即可，虽然官方给出的api配置繁多，但想要实现基本功能却是非常简单。</p><p>我的建议是首先上它的github上下载源文件之后，首先学习它的index.html，这个比较简单而且一开始上手的话利于理解它整体的结构。这段代码很少，应该很快就能理解。然后再慢慢啃demo.html，理解完demo.html应该就差不多了，剩余的一些api就没有必要学得太详细了，需要用的时候再查就可以了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不管是学生还是社畜，ppt始终是一个难以绕过的坎。没有艺术细胞的人对此的苦恼自不必说，即使对艺术感兴趣，限于时间和精力有限，我们也很难&lt;/p&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="reveal.js" scheme="http://yoursite.com/tags/reveal-js/"/>
    
  </entry>
  
  <entry>
    <title>土拨鼠之日观后感</title>
    <link href="http://yoursite.com/2018/07/26/%E5%9C%9F%E6%8B%A8%E9%BC%A0%E4%B9%8B%E6%97%A5%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    <id>http://yoursite.com/2018/07/26/土拨鼠之日观后感/</id>
    <published>2018-07-26T12:38:21.000Z</published>
    <updated>2018-07-26T13:52:19.281Z</updated>
    
    <content type="html"><![CDATA[<p>假如生命只剩下1天，你会做什么？</p><a id="more"></a><p>高中的时候其实就听说了这部电影，但是直到本科毕业才有机会看。最近看了两遍，真的感触很深，还是写一份影评来记录一下感受和自己的看法</p><blockquote><p>剧透警告</p></blockquote><p>主角菲尔是一个记者，他们当地的小镇在每年开春2月2号都有一个习俗，那就是通过土拨鼠能否看到自己的影子来判断春天是否来临</p><p>这当然只是一个引子，有趣的是当主角在2号之后醒来发现自己竟然还是处于2号的状态，一开始他以为只是一个无趣的骗局，可是当他走出旅馆时他惊恐地发现身边所有的事都和昨天经历过的一模一样。他发现了，自己已经陷入了一日囚，他尝试向自己的新同事丽塔倾诉，可被视作一个crazy guy</p><p>他愤怒继而失望</p><p>之后他意识到不管你当天做什么，第二天都会恢复原样，道德和规则对他来说就不存在任何意义。他通过一次次询问的方式来获取姑娘们的信息，然后第二天的时候自如地说出这些信息以尽可能博得姑娘们的好感，他这样的策略是成功的。但是他发现自己始终还有一个人无法攻克，那就是他的同事丽塔</p><p>他通过很多天来彻底摸清楚关于丽塔的一切，以尽可能地完成一个近乎完美的一日约会，可每次他都会失败，丽塔总是能在最关键的时刻发现他的阴谋</p><blockquote><p>“你在干什么？你甚至都不了解我？你在向我的好友们打电话以试图了解我的习惯吗？你这是真正的爱吗”</p></blockquote><p>他在彻底失败了很多次之后，彻底绝望了，他开始丧失了对生活的兴趣</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532610526991.png" alt=""></p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532610546245.png" alt=""></p><p>（男主的演技真的是没话说）</p><p>这一段我真的看的特别有感触，男主的那种绝望的眼神，我能明白</p><p>于是，他开始自杀，各种方式，火烧，撞车，电击，吃毒，无论他尝试哪一种第二天早上6点他都会回到最初旅馆的那张床上</p><p>他又一次陷入了另一种绝望，他开始找女主倾诉他的经历和一切，他说他是神“神之所以全知全能，只是因为他在人间待得够久”他能叫出小镇里每一个人的名字和经历，甚至能准确预报出接下里一段时间内会发生哪些事情。他说他自己因为无聊花了很多时间来训练一些平时可能根本不会注意的技巧，女主迷上了他，他们相爱了，但是男主这个时候眼里还是充满了暗淡</p><blockquote><p>我想说的是，你是我一生中见过的最善良，最体贴，最美丽的人。我从没见过任何人比你待人更好。第一次见到你，在我身上发生了奇妙的事情，我从没告诉过你，我知道我想用尽全身力气紧紧地拥抱你，我配不上像你这样的，但如果可以，我发誓我会爱你，一生一世<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532610944692.png" alt=""></p></blockquote><p>第二天起来，男主又回到了起点</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532611173610.png" alt=""></p><p>看看他这个眼神</p><p>男主之后开始改变了策略，他开始对生活中各式各样的东西感到新奇，并且每一项都花了大力气去学习，钢琴，冰雕，修车，急救术，他开始关心周围所有的人，他开始热爱身边所有的事物。当然他也碰到了当天必定会死救不回来的流浪汉</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532611390913.png" alt=""></p><p>当他开始真正积极地面对生活的时候，女主（或者说任何一个人）都情不自禁地爱上了他。</p><hr><p>说说我的想法吧</p><p>有一些瑕疵，但不失为一个精彩的电影。对现实很有指导意义。我指的瑕疵主要是剧情安排有一些刻意，比如最后的桥段，菲尔的改变导致大家都喜欢他，这当然是很好的事，但是桥段显得很刻意和突兀，一定程度上降低了这部电影在我心中的观感</p><p>当然，他揭示的道理，作为商业片来讲，还是非常深刻和鞭辟入里的。</p><p>当然我对片子里的真实性还是有一点存疑，这里并非是说一日囚这种奇遇，而是男主的态度。他的情感态度实际上是跟电影的节奏保持一致的，这也让我们在看的时候觉得连贯，但如果仔细推敲的话，这其实和男主实际经历的时间不一样。我之前看过有人分析说男主在这一天里已经困了二三十年了，假设真的有这么久的话，我很好奇男主是否还能对女主把持这样的激情呢</p><p>爱情究竟是一种怎么样的东西呢？</p><p>一见钟情，两相情悦这些都是经典的爱情理论和人们对于爱情的固有印象。那么如果是一方单方面的追求，这样的一段关系，究竟在多大程度上能够和爱情划上等号呢？</p><p>一种解释可能是这样的：追求只是让对方注意到你的机会，你可以在这个过程中尽情地展示你的魅力和决心，让对方逐渐对你产生好感。毕竟恋爱或者说爱情产生的必要条件就是双方都对对方产生水准之上的好感，而追求这个过程就是加速你们之间的进程。（自己把自己说服了）</p><p>同样，在恋爱或者说交往的过程，其实也是一个双方互相认同和成长的过程，我们能收获认同感，也能收获责任感</p><p>感觉我自己目前是享受不了这些特权了，一方面我自己的能力还不够强，另一方面我对感情的认识还很浅薄和肤浅。电影里揭示的道理简洁而深刻，感情从来就不是靠追，而是双方互相吸引，彼此喜欢，仅此而已。我们要做的就是尽可能地投资自己，让自己变得尽可能的充实</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假如生命只剩下1天，你会做什么？&lt;/p&gt;
    
    </summary>
    
      <category term="影评" scheme="http://yoursite.com/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>闲谈&amp;近期总结</title>
    <link href="http://yoursite.com/2018/07/20/%E9%97%B2%E8%B0%88-%E8%BF%91%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/07/20/闲谈-近期总结/</id>
    <published>2018-07-20T13:25:39.000Z</published>
    <updated>2018-09-29T09:34:28.249Z</updated>
    
    <content type="html"><![CDATA[<p>最近有一些事觉得很麻烦把，晚上去操场整理了一下思路，现在大概清晰一点了，写下来记录一下</p><a id="more"></a><h1 id="1-应该保持的习惯"><a href="#1-应该保持的习惯" class="headerlink" title="1.应该保持的习惯"></a>1.应该保持的习惯</h1><h2 id="思考的时候去操场散步"><a href="#思考的时候去操场散步" class="headerlink" title="思考的时候去操场散步"></a>思考的时候去操场散步</h2><p>已经很久没有去操场单独只是为了思考问题了，但事实证明这真的很有作用。在图书馆或者机房都无法完全沉浸式地去思考问题，但是操场可以，戴上bose就能体会到与世隔绝的感觉，真的对思考帮助很大</p><h1 id="2-关于爱情"><a href="#2-关于爱情" class="headerlink" title="2.关于爱情"></a>2.关于爱情</h1><p>晚上跟两个同学聊天，收货真的很大。但是后来仔细想了一下，问题还是远比我想象的复杂，这无关技巧，只在于恋爱本身，我想地越深入就会越觉得对它的本质感到好奇</p><p>当我在想到大学恋爱实际上不会很长久的时候，莫名地感到了一丝恐惧，进而突然想到，喜欢一个人究竟以意味着什么呢。</p><p>问题也许可以更深一步，那就是爱情或者说恋爱，对于一个独立个体来说，究竟意味什么呢？</p><p>从生理学的角度上讲无非就是多巴胺和荷尔蒙，但这样未免有失情趣。我以我少的可怜的经验去仔细揣度了一下，一对年轻的男女，相遇相恋，结婚生子，然后轮回。这是正常的较为理想的流程，可是如果是一个人的话，可能唯一的感觉就是孤独无靠吧。那么，为什么恋爱或者爱情已经固化为了人类的一项固有标签呢？繁衍后代的本能当然是一个很好的说辞，但这并不是我想要的答案。对于年轻人来说，恋爱对他们可能意味着新鲜，有趣，性，认同感。细化到生活中（或者说是用功利的眼光看待）可能是想想做的事能有人陪，一起分享开心，一起承担痛苦。</p><p>我在自己思考了一番之后打开了知乎，发现知乎现在果然跟我大二时的质量完全不能比了。不过这也算是我为了获取某个答案而采取捷径的恶果。当然后来才发现是自己选题质量不好，”爱情的本质是什么“这个问题下的回答质量普遍偏低，”爱情是什么“相对略好</p><p>看完答案之后我有点怅然若失，因为感觉不是自己想要的，突然意识到自己想要问的是”婚姻究竟以为着什么“ ”两个人的结合究竟意味着什么“</p><p>不过细想，爱情这种东西，似乎并不应然属于每一个人甚至是已经成家的人，再往深处想，就会开始质疑爱情本身的定义了</p><h1 id="3-关于自己"><a href="#3-关于自己" class="headerlink" title="3.关于自己"></a>3.关于自己</h1><p>爱好很杂并不一定是一件坏事，但是在该积累技术能力的时候把时间都浪费在这个上面就会显得很不为自己的未来负责</p><p>我决定未来一段时间不玩游戏（饥荒 &amp; 塞尔达）</p><p>自己的动力一直不足说到底还是不确信自己究竟未来应该做什么</p><p>现在差不多坚定下来了，还是主要做前端</p><p>另外，好久没写文章了。以前都是在ulysess上想到什么写什么，但其实这样不太好，因为输出还是最好在一个公共的平台，这样才有交流和获取更多信息的可能性。好久没有写文章&amp;看书的后果就是自己连一些基本的观点都说不利索了</p><p>之前翻阅原来的知乎答案的时候发现有时候自己连大二的时候都不如。曾经的自己对很多人文社科类的知识感兴趣，愿意看很多书来试图靠近一点点世界的真向，但是现在有的时候什么都不太想做，这样的自己又回到了原点</p><p>作为曾经尝试过很多的我，当然知道一些领域如哲学是很难入门的</p><p>已经很久没有体会到纯粹的智识性趣味了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有一些事觉得很麻烦把，晚上去操场整理了一下思路，现在大概清晰一点了，写下来记录一下&lt;/p&gt;
    
    </summary>
    
      <category term="随想" scheme="http://yoursite.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="个人成长" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>什么是Web语义化</title>
    <link href="http://yoursite.com/2018/07/11/%E4%BB%80%E4%B9%88%E6%98%AFWeb%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
    <id>http://yoursite.com/2018/07/11/什么是Web语义化/</id>
    <published>2018-07-11T12:10:52.000Z</published>
    <updated>2018-07-18T07:39:35.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>web语义元素的定义和我自己的理解</p></blockquote><a id="more"></a><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.zhihu.com/question/20455165" target="_blank" rel="external">知乎（如何理解Web语义化）</a></p><p><a href="http://justineo.github.io/slideshows/semantic-html/#/" target="_blank" rel="external">一个使用reveal.js写的挺炫酷的语义dom讲解</a></p><h1 id="权威解释"><a href="#权威解释" class="headerlink" title="权威解释"></a>权威解释</h1><blockquote><p>什么是语义化？其实简单说来就是让机器可以读懂内容。</p><p>先随便扯扯。对于当前的 Web 而言，HTML 是联系大多数 Web 资源的纽带，也是内容的载体。在 Web 被刚刚设计出来的时候，Tim Berners-Lee 可能不会想到它现在会达到的规模以及深入到我们生活的那么多方面。也许起初的想法很简单：用来发布 Web 内容和资源的索引，方便人们查看。</p><p>但是随着 Web 规模的不断扩大，信息量之大已经不在人肉处理的范围之内了。这个时候人们开始用机器来处理 Web 上发布的各种内容，搜索引擎就诞生了。再后来，人们又设计了各种智能程序来对索引好的内容作各种处理和挖掘。所以让机器能够更好地读懂 Web 上发布的各种内容就变得越来越重要。</p><p>其实 HTML 在刚开始设计出来的时候就是带有一定的「语义」的，包括段落、表格、图片、标题等等，但这些更多地只是方便浏览器等 UA 对它们作合适的处理。但逐渐地，机器也要借助 HTML 提供的语义以及自然语言处理的手段来「读懂」它们从网上获取的 HTML 文档，但它们无法读懂例如「红色的文字」或者是深度嵌套的表格布局中内容的含义，因为太多已有的内容都是专门为了可视化的浏览器设计的。面对这种情况，出现了两种观点：</p><p>1.我们可以让机器的理解能力越来越接近人类，人能看懂、听懂的东西，机器也能理解</p><p>2.我们应该在发布内容的时候，就用机器可读的、被广泛认可的语义信息来描述内容，来降低机器处理 Web 内容的难度（HTML 本身就已经是朝这个方向迈出的一小步了）。</p><p><img src="https://pic2.zhimg.com/01b4d93c152d2a9c2db734065be0f3f5_b.jpg" alt=""></p><p>我画的这个图，意思是说，内容的语义表达能力和 AI 的智能程度决定了机器分析处理 Web 内容能力的高低。上面观点 1 的方向是朝着人类水平的人工智能努力，而观点 2 的方向正是万维网创始人 Tim Berners-Lee 爵士提出的美好愿景：语义网。语义网我就不多说了，简单来说就是让一切内容和包括对关系的描述都成为 Web 上的资源，都可以由唯一的 URI 定义，语义明确、机器可读。显然，两条路都的终极目标都很遥远，第一条路技术上难以实现，而第二条路实施起来障碍太多。</p><p>我认为我们当前能够看得见摸得着的 Web 语义化，其实就是在往第二条路的方向上，迈出的一小步，即对已经有的被广泛认可的 HTML 标准做改进。我们刚开始意识到，我们必须回归内容本身，将内容本身的语义合理地表述出来，再为不同的用户代理设计不同的样式描述，也就是我们说的内容与样式分离。这样我们在提供内容的时候，首先要做的就是将内容本身进行合理的描述，暂时不用考虑它的最终呈现会是什么样子。</p><p>HTML 规范其实一直在往语义化的方向上努力，许多元素、属性在设计的时候，就已经考虑了如何让各种用户代理甚至网络爬虫更好地理解 HTML 文档。HTML5 更是在之前规范的基础上，将所有表现层（presentational）的语义描述都进行了修改或者删除，增加了不少可以表达更丰富语义的元素。为什么这样的语义元素是有意义的？因为它们被广泛认可。所谓语义本身就是对符号的一种共识，被认可的程度越高、范围越广，人们就越可以依赖它实现各种各样的功能。</p><p>HTML5 并非 Web 语义唯一倚仗的规范，除了 W3C 和 WHATWG 外，还有其它的组织在为扩展、标准化 Web 语义做着贡献。只要有浏览器厂商、搜索引擎原意支持，它们的规范一样可以成为通用的基础设施。例如 microformats 社区以及 <a href="http://Schema.org" target="_blank" rel="external">http://Schema.org</a> 上都有对 HTML 以及 Microdata（<a href="http://www.w3.org/TR/html5/microdata.html）" target="_blank" rel="external">http://www.w3.org/TR/html5/microdata.html）</a> 规范的扩展词汇表，Google、Bing、Yahoo! 等搜索引擎以及各个主流浏览器都不同程度地接纳了其中定义的语义扩展，并应用在了生产中。</p></blockquote><h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><p>首先要明确一点，这一次任务虽然非常简单，但是却是很重要的一节，我自己做项目的时候能够感觉得出来，div的语义化写得不明显就只能用class来凑，感觉很不规范。</p><p>我之前一直在想在网上找规范什么的，突然在IFE的笔记区里看到一个另我豁然开朗的答案————直接去大厂的html里看啊，看人家是怎么设定html的，直接对着写两个，自己马上就能明白</p><blockquote><p>发现自己还是too young，看了下淘宝和微博，发现它们都是用的div，根本没怎么在语义上下功夫</p></blockquote><p>记好这张图就好了<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1531313829236.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;web语义元素的定义和我自己的理解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>(转)js闭包问题解决</title>
    <link href="http://yoursite.com/2018/07/05/%E8%BD%AC-js%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/07/05/转-js闭包问题解决/</id>
    <published>2018-07-05T09:11:36.000Z</published>
    <updated>2018-09-06T00:49:25.991Z</updated>
    
    <content type="html"><![CDATA[<p>最近又碰到了js的闭包问题，感觉自己的基础还不扎实…在网上找到了一个文章已经把解决方法总结得很好了，直接搬运一下，之后再加点自己的东西<br><a id="more"></a></p><h1 id="JS中for循环里面的闭包问题的原因及解决办法"><a href="#JS中for循环里面的闭包问题的原因及解决办法" class="headerlink" title="JS中for循环里面的闭包问题的原因及解决办法"></a>JS中for循环里面的闭包问题的原因及解决办法</h1><p>我们先看一个正常的for循环，普通函数里面有一个for循环，for循环结束后最终返回结果数组</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">        arr[i] = i;        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line">alert(box()) <span class="comment">//正常情况不需要闭包，就可以达到预期效果</span></div><div class="line">   <span class="comment">//输出结果为一个数组 0,1,2,3,4</span></div></pre></td></tr></table></figure><p>有时我们需要在for循环里面添加一个匿名函数来实现更多功能，看下面代码</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//循环里面包含闭包函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">        arr[i] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> i;                            <span class="comment">//由于这个闭包的关系，他是循环完毕之后才返回，最终结果是4++是5</span></div><div class="line">        &#125;                                        <span class="comment">//这个匿名函数里面根本没有i这个变量，所以匿名函数会从父级函数中去找i，</span></div><div class="line">    &#125;                                            <span class="comment">//当找到这个i的时候，for循环已经循环完毕了，所以最终会返回5</span></div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="comment">//alert(box());                                    //执行5次匿名函数本身</span></div><div class="line"><span class="comment">//alert(box()[1]);　　　　　　　　　　　　　　　　　　　//执行第2个匿名函数本身</span></div><div class="line"><span class="comment">//alert(box().length);                            //最终返回的是一个数组，数组的长度为5</span></div><div class="line">alert(box()[<span class="number">0</span>]());                                <span class="comment">//数组中的第一个数返回的是5，这是为什么？</span></div></pre></td></tr></table></figure><p>上面这段代码就形成了一个闭包：</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见的方式，就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量。</p></blockquote><p>在for循环里面的匿名函数执行 return i 语句的时候，由于匿名函数里面没有i这个变量，所以这个i他要从父级函数中寻找i，而父级函数中的i在for循环中，当找到这个i的时候，是for循环完毕的i，也就是5，所以这个box得到的是一个数组[5,5,5,5,5]。</p><h1 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h1><p>在看解决方案一之前，我们先看一下匿名函数的自我执行：</p><p>匿名函数自我执行的写法是，在函数体外面加一对圆括号，形成一个表达式，在圆括号后面再加一个圆括号，里面可传入参数。</p><p>例如下代码：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">function</span>()&#123;</div><div class="line">    alert(<span class="name">'lee'</span>)<span class="comment">;                //匿名函数自我执行(匿名函数)()</span></div><div class="line">&#125;)()<span class="comment">;</span></div></pre></td></tr></table></figure><p>我们再来看解决方案1：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">        arr[i] = (<span class="function"><span class="keyword">function</span><span class="params">(num)</span></span>&#123;                    <span class="comment">//自我执行，并传参(将匿名函数形成一个表达式)(传递一个参数)</span></div><div class="line">            <span class="keyword">return</span> num;                            <span class="comment">//这里的num写什么都可以                    </span></div><div class="line">        &#125;)(i);                                    <span class="comment">//这时候这个括号里面的i和上面arr[i]的值是一样的都是取自for循环里面的i                            </span></div><div class="line">    &#125;                                            </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="comment">//alert(box());                                </span></div><div class="line"><span class="comment">//alert(box()[1]);</span></div><div class="line"><span class="comment">//alert(box().length);                            </span></div><div class="line">alert(box()[<span class="number">0</span>]);</div></pre></td></tr></table></figure><p>通过给匿名函数传参，而传递的这个参数i是每次执行for循环里面的i，每次传递的参数i的值都不一样，匿名函数里面的num接收传递的参数i，所以box()最终输出结果为[0,1,2,3,4]</p><h1 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h1><p>这种方案的原理就是在匿名函数1里面再写入一个匿名函数2，这个匿名函数2需要的num值会在他的父级函数匿名函数1里面去寻找，而匿名函数1里面的num值就是传入的这个参数i，和上面例子中的i是一样的，</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function box()&#123;</div><div class="line"><span class="code">    var arr = [];</span></div><div class="line"><span class="code">    for(var i=0;i&lt;5;i++)&#123;</span></div><div class="line"><span class="code">        arr[i] = (function(num)&#123;</span></div><div class="line"><span class="code">        //num在这里                                    //原理和上面一种方法一样的，所以可以实现闭包                    </span></div><div class="line"><span class="code">            return function()&#123;                        //在这个闭包里面再写一个匿名函数</span></div><div class="line"><span class="code">                return num;                            </span></div><div class="line"><span class="code">            &#125;;                                                                </span></div><div class="line"><span class="code">        &#125;)(i)                                                </span></div><div class="line"><span class="code">    &#125;</span></div><div class="line"><span class="code">    return arr;</span></div><div class="line">&#125;</div><div class="line">//alert(box());                                </div><div class="line">//alert(box()[1]);</div><div class="line">//alert(box().length);</div><div class="line">var b = box();                            </div><div class="line">alert(b[<span class="string">0</span>](<span class="link"></span>));</div><div class="line">alert(box()[<span class="string">0</span>](<span class="link"></span>));</div></pre></td></tr></table></figure><p>box()最终返回结果[0,1,2,3,4],</p><h1 id="解决方案3"><a href="#解决方案3" class="headerlink" title="解决方案3"></a>解决方案3</h1><p>如果将一个匿名函数自我执行的时候赋值给一个变量，那么这个匿名函数中的圆括号的可以去掉的，看下面代码，</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tip = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;         <span class="comment">//这样把匿名函数自我执行的时候赋值给一个变量，那么圆括号是可以去掉的</span></div><div class="line">    alert(<span class="string">'lee'</span>);</div><div class="line">&#125;();</div></pre></td></tr></table></figure><p>利用匿名函数的这一特点，我们可以将解决方案1中的代码改进一下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">        arr[i] = <span class="function"><span class="keyword">function</span><span class="params">(num)</span></span>&#123;                </div><div class="line">            <span class="keyword">return</span> num;                            </div><div class="line">        &#125;(i);                                </div><div class="line">    &#125;                                            </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="comment">//alert(box());                                </span></div><div class="line"><span class="comment">//alert(box()[1]);</span></div><div class="line"><span class="comment">//alert(box().length);                            </span></div><div class="line">alert(box()[<span class="number">4</span>]);</div></pre></td></tr></table></figure><h1 id="解决方案4"><a href="#解决方案4" class="headerlink" title="解决方案4"></a>解决方案4</h1><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1536194960944.png" alt=""></p><p>匿名函数在执行的时候他本身就传递给了一个变量arr[i]，所以匿名函数的圆括号是可以去掉的。</p><p>以上就是几种解决for循环中闭包的办法，当然还有更多办法，大家可自行google或者bing其他资料来加深印象(百度是基本上搜不到什么有用的文章的)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又碰到了js的闭包问题，感觉自己的基础还不扎实…在网上找到了一个文章已经把解决方法总结得很好了，直接搬运一下，之后再加点自己的东西&lt;br&gt;
    
    </summary>
    
      <category term="技术细节" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>SICP第一章笔记</title>
    <link href="http://yoursite.com/2018/06/28/SICP%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/28/SICP第一章笔记/</id>
    <published>2018-06-28T11:37:28.000Z</published>
    <updated>2018-07-18T07:14:34.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>第一章的内容相对来说比较基础 </p></blockquote><a id="more"></a><h1 id="1-应用序和正则序"><a href="#1-应用序和正则序" class="headerlink" title="1.应用序和正则序"></a>1.应用序和正则序</h1><ul><li>正则序 </li></ul><blockquote><p>首先不计算运算对象的值，首先展开原有的式子，直到实际需要的时候再计算。缺陷是可能有重复计算</p></blockquote><ul><li>应用序 </li></ul><blockquote><p>与正则序完全相反，首先求值，然后应用。</p></blockquote><p>大部分情况下，两种方法得到的结果都是一样的。但是大部分的解释器现在都是<code>应用序</code>。正则序一方面会比较复杂，但另一方面它也可以特别有价值</p><p>一个辨别正则序和应用序的例子</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1530191611264.png" alt=""></p><p>如果是正则序，则不会陷入求p的循环中，而如果是应用序则会陷入死循环</p><h1 id="2-迭代和递归"><a href="#2-迭代和递归" class="headerlink" title="2.迭代和递归"></a>2.迭代和递归</h1><p>这也是我在重读SICP之前印象最深的一点，但是直到手写了几个函数之后才发现这两者之间真正的差别.</p><p>首先要声明，大部分情况下，迭代的效率都比递归更高。但是递归更加符合人们的直觉，即其易于理解。当我们把代码拆开之后，会发现迭代不仅占用的内存小，而且避免了很多重复计算。在处理大量数据时，建议还是使用迭代。</p><blockquote><p>对于任何递归过程的解释，所需要消耗的内存总是和过程调用的数目成正比。而迭代过程则不受影响。</p></blockquote><p>在代码结构上讲，迭代的特点我总结共<strong>3</strong>个本质特点</p><ul><li>最终需要输出的值一定是作为参数放在函数里</li><li>在递归中需要调用到自身函数的时候，迭代里不再通过调用自己，而是有几个调用自己的次数就在迭代的函数里增加几个新的参数。</li><li>迭代的版本中的判断条件一般是<code>到了某个值之后，抛出结果的参量</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;第一章的内容相对来说比较基础 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SICP" scheme="http://yoursite.com/tags/SICP/"/>
    
  </entry>
  
  <entry>
    <title>《SICP》攻略计划</title>
    <link href="http://yoursite.com/2018/06/25/%E3%80%8ASICP%E3%80%8B%E6%94%BB%E7%95%A5%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2018/06/25/《SICP》攻略计划/</id>
    <published>2018-06-25T09:49:51.000Z</published>
    <updated>2018-06-28T05:57:56.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一次看这本书的时候还是大三，但是因为考研（懒）等原因只寥寥看了两周的时间就放下了。但正是这短短的两周，让我彻底感受到了SICP和Lisp语言的魅力。说实话，最近前端做的非常迷茫，决定回归本源，来认真研读SICP这本好书</p></blockquote><a id="more"></a><p><strong>本文只是个引子，具体的读书笔记我之后会单独列文章出来的</strong></p><h1 id="Why-SICP"><a href="#Why-SICP" class="headerlink" title="Why SICP"></a>Why SICP</h1><blockquote><p>我现在正处于本科和研究生阶段交接的地步，我最近一直在做的前端最近感觉到了迷茫，因为感觉前端的东西都很浅（不管是我现在用到的东西，还是框架，我总感觉不是很踏实）。虽然研究生阶段师兄们找的工作都是算法岗（也就是研究生阶段做的事）但是我还是想挑战一下算法岗。原本我的计划是先做把前端做到一定的程度（即差不多找工作，另外百度前端学院也自称，完成它几个月的任务就能达到国内一线大公司实习的标准），再去看一下纯粹的编程。现在看来这个计划似乎有点本末倒置的嫌疑，应该是先研读优秀的纯编程方面的知识，有了一定的底气，再去看js前端方面的内容，可能就会有种“一览众山小”的感觉，先这样计划着吧</p><p>这本书的很多内容、习题需要仔细揣摩才能领略其精髓，所以看这本书一定不要心急。 其次，在阅读时，请务必关闭手机上一些社交工具，并预留出至少 1 个小时的完整时间来看，否则我不认为你真的能有所收获。</p><p>学习是件很苦的事，大多数人都是三分钟热度，所以如果你觉得看这本书让你很烦躁，不妨出去运动一下，或听一会音乐🎵，第二天接着来。坚持下来，不要放弃，更不要失去对探索编程真谛的好奇心。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://liujiacai.net/blog/2016/04/23/sicp-chapter4-summary/" target="_blank" rel="external">一个记录SICP习题的博客</a></li><li><a href="https://sicp.liujiacai.net/chap3/exercise.html" target="_blank" rel="external">上一个人的SICP习题总结</a></li><li><a href="http://www.nowamagic.net/librarys/veda/detail/1905" target="_blank" rel="external">向热爱计算机的你推荐SICP</a></li><li><a href="http://yinwang0.lofter.com/post/183ec2_47bea8" target="_blank" rel="external">如何掌握程序语言</a></li></ol><h1 id="开发环境环境配置"><a href="#开发环境环境配置" class="headerlink" title="开发环境环境配置"></a>开发环境环境配置</h1><p>我之前是使用的<a href="https://racket-lang.org/" target="_blank" rel="external">DrRacket</a>，是一个GUI版本，而且自带简便的调试功能。但这次我觉得它的代码补全和高亮什么的不太好，而且SICP应该不需要太强的调试功能，我决定自己在atom上搞，下载一个<code>language-scheme</code>的插件，然后在终端下运行对应的scheme程序。我使用的scheme解释器是<a href="http://ftp.gnu.org/gnu/mit-scheme/stable.pkg/9.2/mit-scheme-9.2-x86-64.dmg" target="_blank" rel="external">mit-scheme</a>。</p><p>下载完上面的scheme解释器之后，将其加入在系统的全局路径里，在终端里输入scheme就可以直接交互运行了，但这样的话<code>会无法使用方向键</code>。下载rlwrap就可以了<code>brew install rlwrap</code>，下载完运行<code>rlwrap scheme</code>即可。</p><h1 id="SICP计划"><a href="#SICP计划" class="headerlink" title="SICP计划"></a>SICP计划</h1><ol><li>我计划1年内读完，即研一的阶段做完</li><li>重点放在前3章（假设做不完的话）</li><li>之前刷的时候，重点放在做题上。这次在做的时候，<strong>要开始利用好git了</strong>，每个题单独成一个scm文件</li><li>每一章单独做一个总结，<a href="https://liujiacai.net/blog/2015/07/18/sicp-chapter1-summary/" target="_blank" rel="external">参考</a>，每一个题单独做一份文件，并且push到github上</li></ol><h1 id="辅助资料链接"><a href="#辅助资料链接" class="headerlink" title="辅助资料链接"></a>辅助资料链接</h1><ol><li><a href="http://www.math.pku.edu.cn/teachers/qiuzy/progtech/" target="_blank" rel="external">北大SICP教学主页</a></li><li><a href="https://www.comp.nus.edu.sg/~cs1101s/sicp/" target="_blank" rel="external">SICP in javascript</a></li><li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/" target="_blank" rel="external">MIT 教学视频</a><h1 id="SICP笔记链接"><a href="#SICP笔记链接" class="headerlink" title="SICP笔记链接"></a>SICP笔记链接</h1></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上一次看这本书的时候还是大三，但是因为考研（懒）等原因只寥寥看了两周的时间就放下了。但正是这短短的两周，让我彻底感受到了SICP和Lisp语言的魅力。说实话，最近前端做的非常迷茫，决定回归本源，来认真研读SICP这本好书&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="lisp" scheme="http://yoursite.com/tags/lisp/"/>
    
  </entry>
  
  <entry>
    <title>python处理编码问题</title>
    <link href="http://yoursite.com/2018/05/23/python%E5%A4%84%E7%90%86%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/05/23/python处理编码问题/</id>
    <published>2018-05-23T02:15:22.000Z</published>
    <updated>2018-05-25T11:55:23.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近参加一个可视化的比赛，在用python处理csv数据时，编码的问题真的是让人头大。干脆写一篇博客把编码的问题梳理一遍</p></blockquote><a id="more"></a><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="https://blog.csdn.net/woshimalingyi/article/details/49201319" target="_blank" rel="external">字符编码和字符集</a></p><p><a href="https://blog.csdn.net/ggggiqnypgjg/article/details/53271541" target="_blank" rel="external">python中文乱码问题</a></p><h1 id="常见的编码体系"><a href="#常见的编码体系" class="headerlink" title="常见的编码体系"></a>常见的编码体系</h1><h2 id="编码的定义"><a href="#编码的定义" class="headerlink" title="编码的定义"></a>编码的定义</h2><blockquote><p>编码是信息从一种形式或格式转换为另一种形式的过程也称为计算机编程语言的代码简称编码。用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。编码在电子计算机、电视、遥控和通讯等方面广泛使用。编码是信息从一种形式或格式转换为另一种形式的过程。解码，是编码的逆过程。</p></blockquote><p>正常情况下我们无论是做网页还是处理数据的时候都会遇到编码问题的，所以有必要对编码的方式做一个详尽的理解</p><h2 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h2><p>这个本科学c语言的时候应该就接触过了</p><blockquote><p>这是美国在19世纪60年代的时候为了建立英文字符和二进制的关系时制定的编码规范，它能表示128个字符，其中包括英文字符、阿拉伯数字、西文字符以及32个控制字符。它用一个字节来表示具体的字符，但它只用后7位来表示字符（2^7=128），最前面的一位统一规定为0。</p></blockquote><h2 id="拓展的ASCII码"><a href="#拓展的ASCII码" class="headerlink" title="拓展的ASCII码"></a>拓展的ASCII码</h2><blockquote><p>原本的ASCII码对于英文语言的国家是够用了，但是欧洲国家的一些语言会有拼音，这时7个字节就不够用了。因此一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使 用的编码体系，可以表示最多256个符号。但这时问题也出现了：不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码 中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。这个问题就直接促使了Unicode编码的产生。</p></blockquote><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><blockquote><p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。而Unicode就是这样一种编码：它包含了世界上所有的符号，并且每一个符号都是独一无二的。比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表 。很多人都说Unicode编码，但<strong>其实Unicode是一个符号集（世界上所有符号的符号集），而不是一种新的编码方式。</strong></p><p>但是正因为Unicode包含了所有的字符，而有些国家的字符用一个字节便可以表示，而有些国家的字符要用多个字节才能表示出来。即产生了两个问题：第一，如果有两个字节的数据，那计算机怎么知道这两个字节是表示一个汉字呢？还是表示两个英文字母呢？第二，因为不同字符需要的存储长度不一样，那么如果Unicode规定用2个字节存储字符，那么英文字符存储时前面1个字节都是0，这就大大浪费了存储空间。</p><p>上面两个问题造成的结果是：1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。2）unicode在很长一段时间内无法推广，直到互联网的出现。</p></blockquote><h2 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h2><blockquote><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍，这里的关系是，<strong>UTF-8是Unicode的实现方式之一</strong>。</p><p>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>UTF-8的编码规则很简单，只有两条：</p><p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</p><p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p></blockquote><h2 id="GBK-GB2312-GB18030"><a href="#GBK-GB2312-GB18030" class="headerlink" title="GBK/GB2312/GB18030"></a>GBK/GB2312/GB18030</h2><blockquote><p>GBK和GB2312都是针对简体字的编码，只是GB2312只支持六千多个汉字的编码，而GBK支持1万多个汉字编码。而GB18030是用于繁体字的编码。汉字存储时都使用两个字节来储存。</p></blockquote><h2 id="不同编码方式之间的联系"><a href="#不同编码方式之间的联系" class="headerlink" title="不同编码方式之间的联系"></a>不同编码方式之间的联系</h2><p>比如：在欧美，<strong>一般直接使用ASCII码</strong>就能够满足他们的要求，因为他们只有26个字母和一些其他的字符。而且编码表示的长度只占一个字节。但是，如果他们的程序要到我们国家来使用，那么我们如果不懂英语就完全不能够使用了。我们国家汉字近10万</p><p>使用Unicode字符集（<strong>该字符集和编码几乎囊括所有国家的常用字符</strong>）。而在国内，因为还可能显示其他不常见的汉字，因此就不能采用Unicode。为此，我们国家便发明了自己的字符集和编码—-GBXXX系列，供国内使用。因此，字符集和字符编码的多样性是由于不同区域的需求多样性导致的。但是在国际上，还是使用Unicode字符集和UTF-X编码方式</p><p>有一些编码存在包含关系，比如UTF-8的第一个字节的编码规则跟ASCII码完全一样。因此，<strong>对于ASCII码的编码内容使用UTF-8也能够正确解码</strong>。字符集也是一样的。因此，ASCII码编码的内容使用UTF-8解码后，使用Unicode字符集规则来解释得到的字符串跟使用ASCII字符集解释得到的完全一样。</p><p>比如：对于同一个编码<br> “\u33a1”. GBK的可能解释为”你“； ISO-8859-1的解释是乱码 “?”; Unicode的解释为”你“。</p><p>原因就是因为<strong>Unicode跟GBK有部分编码解码解码规则是一样的</strong>。而ISO-8859-1是外文编码，不能识别中文<br> ，因此无法解析。</p><h1 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h1><h2 id="乱码的定义"><a href="#乱码的定义" class="headerlink" title="乱码的定义"></a>乱码的定义</h2><blockquote><p>乱码，指的是由于本地计算机在用文本编辑器打开源文件时，使用了不相应字符集而造成部分或所有字符无法被阅读的一系列字符。造成其结果的原因是多种多样的。</p><h2 id="乱码出现的原因"><a href="#乱码出现的原因" class="headerlink" title="乱码出现的原因"></a>乱码出现的原因</h2></blockquote><h1 id="python处理编码"><a href="#python处理编码" class="headerlink" title="python处理编码"></a>python处理编码</h1><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><h2 id="python中的unicode对象"><a href="#python中的unicode对象" class="headerlink" title="python中的unicode对象"></a>python中的unicode对象</h2><p>python代码中，a=u’中国’, 或者a=’中国’.decode()的结果。</p><h2 id="python中的编码转换原则"><a href="#python中的编码转换原则" class="headerlink" title="python中的编码转换原则"></a>python中的编码转换原则</h2><p>unicode是”中介”，<strong>任何编码之间转换都需要先decode()到unicode</strong>。</p><h2 id="python文件开头注释作用"><a href="#python文件开头注释作用" class="headerlink" title="python文件开头注释作用"></a>python文件开头注释作用</h2><p>“#coding:utf-8” 告诉python用什么编码去读取这个.py文件。</p><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>python2.7读csv中文文件乱码</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>python读文件里的中文成功解决了（通过手动修改所有csv的编码为utf-8）</p><h4 id="方法2（未验证）"><a href="#方法2（未验证）" class="headerlink" title="方法2（未验证）"></a>方法2（未验证）</h4><p><code>import codecs codecs.open(file_path, &#39;r&#39;, encoding=&quot;utf-8&quot;)</code><br> 这个方法没尝试，估计也可以，另外这里用的codecs的open函数，因为python2.7不支持打开文件时选择编码</p><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>python2.7写入csv文件乱码</p><h3 id="问题解决-1"><a href="#问题解决-1" class="headerlink" title="问题解决"></a>问题解决</h3><p><code>with codecs.open(file_path, &#39;w&#39;, &#39;utf_8_sig&#39;)</code><br>注意这里一定要是<strong>utf-8_sig</strong>而不是<strong>utf-8</strong>,然后你需要写进去的数据文件保持utf-8格式就可以了，它这个方法打开的文件会自动显示成</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>excel打开csv文件，可以识别编码“GB2312”，但是不能识别“utf-8”,所以csv文件里的中文还是需要转成中文的编码格式</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近参加一个可视化的比赛，在用python处理csv数据时，编码的问题真的是让人头大。干脆写一篇博客把编码的问题梳理一遍&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术细节" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    
    
      <category term="编码" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>《图解HTTP》读后总结</title>
    <link href="http://yoursite.com/2018/05/13/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E5%90%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/13/《图解HTTP》读后总结/</id>
    <published>2018-05-13T01:49:20.000Z</published>
    <updated>2018-06-12T10:00:25.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>6月份开始的一个比赛需要网络方面的知识，但是限于专业和自己的懒惰，自己一直对计算机网络的知识处于一个一知半解的程度，正好掏出买了半年但一直没看的书，从头到尾梳理一遍。顺便下次组会展示的时候科普一下网络的知识。</p></blockquote><a id="more"></a><h1 id="1-了解Web和网络技术基础"><a href="#1-了解Web和网络技术基础" class="headerlink" title="1.了解Web和网络技术基础"></a>1.了解Web和网络技术基础</h1><p>为了了解HTTP，我们有必要事先理解一下TCP/IP协议族。</p><h2 id="1-1-网络基础TCP-IP"><a href="#1-1-网络基础TCP-IP" class="headerlink" title="1.1 网络基础TCP/IP"></a>1.1 网络基础TCP/IP</h2><p>通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的，而HTTP是它内部的一个集。</p><p>计算机和网络设备之间要互相通信，双方就必须基于相同的方法，比如如何探测通信目标，由哪一边先发起通信，使用哪种语言进行通信，都需要事先制定。不同的硬件，操作系统之间的通信，所有的这一切都需要一种规则，我们就讲这些规则称之为<strong>协议</strong></p><blockquote><p>将所有与互联网相关联的协议集合起来，总称为TCP/IP</p></blockquote><h3 id="1-1-1-TCP-IP的分层管理"><a href="#1-1-1-TCP-IP的分层管理" class="headerlink" title="1.1.1 TCP/IP的分层管理"></a>1.1.1 TCP/IP的分层管理</h3><p><strong>分层的好处</strong>：相当于是模块化管理，方便改进和修改</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><blockquote><p>应用层决定了向用户提供应用服务时通信的活动</p></blockquote><p>顾名思义，实际上就是应用的层面，属于抽象等级最高的一阶。比如<a href="https://baike.baidu.com/item/FPT/4424643?fr=aladdin" target="_blank" rel="external">FTP</a>，<a href="https://baike.baidu.com/item/dns/427444" target="_blank" rel="external">DNS</a>，<a href="https://baike.baidu.com/item/SMTP/175887" target="_blank" rel="external">SMTP</a>，HTTP等常见的服务。</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><blockquote><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输</p></blockquote><p>说起来很抽象，实际上就是TCP和UDP，就是制定了在传输数据时，每个计算机应该使用什么样的协议</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><blockquote><p>网络层处理在网络上流动的数据包。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。</p></blockquote><h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><blockquote><p>用来处理网络的硬件部分</p></blockquote><p>这个就相对easy了，可以简单理解为计算机网络在物理的层面。</p><p>此外，我个人还对<strong>网络层</strong>和<strong>传输层</strong>之间的区别不是很清楚，但是看了下面一个例子之后，瞬间明白了</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526261983229.png" alt=""></p><blockquote><p>说白了，网络层是负责不同计算机之间的信息传递，而传输层则是细到了进程级别</p></blockquote><h3 id="1-1-2-TCP-IP通信传输流"><a href="#1-1-2-TCP-IP通信传输流" class="headerlink" title="1.1.2 TCP/IP通信传输流"></a>1.1.2 TCP/IP通信传输流</h3><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526194008306.png" alt=""><br>发送端在层与层之间传输数据时，都会加上一个本层所属的首部信息。反之，接收端在层与层之间传输数据时，就会消去</p><h2 id="1-2-与HTTP关系密切的协议"><a href="#1-2-与HTTP关系密切的协议" class="headerlink" title="1.2 与HTTP关系密切的协议"></a>1.2 与HTTP关系密切的协议</h2><h3 id="1-2-1-IP协议"><a href="#1-2-1-IP协议" class="headerlink" title="1.2.1 IP协议"></a>1.2.1 IP协议</h3><blockquote><p>注意！这里的IP指协议，我们平时说的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80/150859" target="_blank" rel="external">IP</a>是IP地址。</p></blockquote><p>此处IP全称为网络协议，几乎所有使用网络的系统都会用到IP协议。其作用就是把各种数据发给对方。此时，如果想要保证确保数据包能到对方那里，需要满足各种条件，其中最重要的两个是<strong>IP地址</strong>和<strong>MAC</strong>地址。</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><blockquote><p>IP地址是指互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。目前还有些ip代理软件，但大部分都收费。</p></blockquote><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><blockquote><p>MAC（Media Access Control或者Medium Access Control）地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。 [1]<br>MAC地址是网卡决定的，是固定的。</p></blockquote><p>举一个例子，我们可以把计算机之间的信息传输理解为快递的流程，买方想通过物流将商品交到顾客的手上，这个时候，Ip地址可以理解为顾客的地址，Mac地址可以理解为顾客的身份证号（或者可以理解为任何可以唯一表示顾客的特征，比如外貌+姓名）</p><p>为什么在传输过程中我们需要ip和mac两种地址？</p><p>￼<img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526198406978.png" alt=""></p><h3 id="1-2-2-TCP协议"><a href="#1-2-2-TCP协议" class="headerlink" title="1.2.2 TCP协议"></a>1.2.2 TCP协议</h3><p>tcp处于传输层中，提供可靠的字节流服务。其中<strong>可靠</strong>是指，能够将数据准确可靠地传给对方，所以相应地，与tcp对应的是udp，它的特点就是不管对方是否能接收到数据，都一股脑地都把数据传过去再说。<strong>字节流服务</strong>是指，为了方便传输而将大块数据分割成以报文段为单位的数据包进行管理。</p><h4 id="tcp的三次握手"><a href="#tcp的三次握手" class="headerlink" title="tcp的三次握手"></a>tcp的三次握手</h4><p>tcp协议为什么能够准确无误地将数据传送到目标处？就在于它采用了<strong>三次握手</strong>的策略</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526198697091.png" alt=""></p><p>开始之前，首先声明，TCP的两种标志SYN（同步）和ACK（理解）</p><ol><li>发送端发送一个标记syn（记为j）的数据包给对方</li><li>接收端接到以后，再反向发一个syn（j+1）和ack（记为k）标志的数据包给对方</li><li>发送端收到以后，再向接收端发一个ACK（k+1）的数据包给接收端。至此完成3次握手</li></ol><blockquote><p>若是在握手过程中莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p></blockquote><h3 id="1-2-3-DNS服务"><a href="#1-2-3-DNS服务" class="headerlink" title="1.2.3 DNS服务"></a>1.2.3 DNS服务</h3><p>这个相对来说是个老朋友了，它和HTTP一样都是出于四层结构中的应用层，主要功能是<strong>提供域名到IP地址之间的转化服务</strong>。</p><p>一般来说，我们在web中想要获取某项资源，都是以域名的形式来访问，这主要是因为相对于IP地址，用字母配合数字的表达形式来指定计算机名更加符合人类的记忆习惯</p><p>比如我们想要访问百度，我们在浏览器中输入<a href="http://www.baidu.com，这个请求实际上首先是前往了DNS服务器，解析成了对应的IP地址，然后再进入正常的网络通信流程" target="_blank" rel="external">http://www.baidu.com，这个请求实际上首先是前往了DNS服务器，解析成了对应的IP地址，然后再进入正常的网络通信流程</a></p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526199225187.png" alt=""></p><h4 id="DNS污染和DNS劫持"><a href="#DNS污染和DNS劫持" class="headerlink" title="DNS污染和DNS劫持"></a>DNS污染和DNS劫持</h4><p><strong>DNS污染</strong>指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。范例，访问Youtube、Facebook之类网站等出现的状况。</p><p><strong>DNS劫持</strong>就是指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。范例，网通、电信、铁通的某些用户有时候会发现自己打算访问一个地址，却被转向了各种推送广告等网站，这就是DNS劫持。</p><h2 id="1-3各种协议与HTTP协议的关系"><a href="#1-3各种协议与HTTP协议的关系" class="headerlink" title="1.3各种协议与HTTP协议的关系"></a>1.3各种协议与HTTP协议的关系</h2><blockquote><p>本章最重要的一张图</p></blockquote><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526199438621.png" alt=""></p><h2 id="1-4-URL和URI"><a href="#1-4-URL和URI" class="headerlink" title="1.4 URL和URI"></a>1.4 URL和URI</h2><h3 id="1-4-1-两者的区别"><a href="#1-4-1-两者的区别" class="headerlink" title="1.4.1 两者的区别"></a>1.4.1 两者的区别</h3><p>uri（统一资源标识符），url（统一资源定位符）。url更为我们所熟知，其正是使用web浏览器来访问页面时需要输入的网页地址。</p><p>后者是前者的子集，前者的特点是可以唯一表示一种资源，但其表现形式不局限于后面哪一种，有的时候用前者表示的资源可能在某一命名空间中，但其不代表网络地址</p><blockquote><p>urn:issn:1535-3611</p></blockquote><h3 id="1-4-2-url的结构"><a href="#1-4-2-url的结构" class="headerlink" title="1.4.2 url的结构"></a>1.4.2 url的结构</h3><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526200119436.png" alt=""></p><h1 id="2-简单的HTTP协议"><a href="#2-简单的HTTP协议" class="headerlink" title="2. 简单的HTTP协议"></a>2. 简单的HTTP协议</h1><h2 id="2-1-HTTP协议用于客户端与服务器之间的通信"><a href="#2-1-HTTP协议用于客户端与服务器之间的通信" class="headerlink" title="2.1 HTTP协议用于客户端与服务器之间的通信"></a>2.1 HTTP协议用于客户端与服务器之间的通信</h2><blockquote><p>请求访问文本或者图像等资源的一端称之为客户端</p><p>提供资源相应的一端称之为服务器端</p></blockquote><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526262272192.png" alt=""></p><h2 id="2-2-HTTP是不保存状态的协议"><a href="#2-2-HTTP是不保存状态的协议" class="headerlink" title="2.2 HTTP是不保存状态的协议"></a>2.2 HTTP是不保存状态的协议</h2><p>HTTP是一种<strong>无状态协议</strong>，也就是说HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526262386148.png" alt=""></p><p>这样做有好处即能够快速处理大量事物，确保协议的可伸缩性。但是坏处就是无法保存登录状态（这个用cookie实现了）</p><h2 id="2-3-HTTP方法"><a href="#2-3-HTTP方法" class="headerlink" title="2.3 HTTP方法"></a>2.3 HTTP方法</h2><ol><li>GET</li><li>POST<br>（知道上述两者即可，剩下的几乎用不到，需要用到的时候再查）</li></ol><h2 id="2-4-持久连接"><a href="#2-4-持久连接" class="headerlink" title="2.4 持久连接"></a>2.4 持久连接</h2><h3 id="2-4-1-持久连接的提出"><a href="#2-4-1-持久连接的提出" class="headerlink" title="2.4.1 持久连接的提出"></a>2.4.1 持久连接的提出</h3><p>HTTP协议的初始版本中，每进行一次通信就需要断开一次TCP连接</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526262602095.png" alt=""></p><p>这样做的后果就是，小容量的文本传输倒也没什么，但是随着HTTP的普及，文档中包含大量图片的情况多了起来，这个时候每次请求都会造成无谓的TCP断开和重连，<strong>增加通信量的开销</strong></p><p>为了解决上述问题，持久连接的方法被踢了出来，它的特点是</p><blockquote><p>只要任意一段没有明确提出断开连接，则保持TCP连接状态</p></blockquote><p>这么做的好处是减少了TCP链接的重复建立和断开的开销，减轻了服务器端的负载。</p><h3 id="2-4-2-管线化"><a href="#2-4-2-管线化" class="headerlink" title="2.4.2 管线化"></a>2.4.2 管线化</h3><p>持久连接使得多数请求能够以管线化的方式发送成为可能，跟多线程类似，我们不需要一个接一个地等待响应就可以直接发送下一个请求，又一次提高了http通信的效率</p><h2 id="2-5-使用cookie的状态管理"><a href="#2-5-使用cookie的状态管理" class="headerlink" title="2.5 使用cookie的状态管理"></a>2.5 使用cookie的状态管理</h2><p>http本身是<strong>无记忆</strong>的，这个时候在处理一些需要登录验证的页面就无法应对，此时我们引入了cookie技术。cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。</p><p>服务器端会发送一个set-cookie的首部字段信息，通知客户端保存cookie，等下次客户端再向服务器端发送请求时，其会自动在请求报文中加入cookie值。</p><p>这时服务器发现cookie之后，会去检查到底是哪一个客户端发来的请求，然后对比服务器上的记录，最后得到该客户端的登录状态信息。</p><h1 id="3-HTTP报文内的HTTP信息"><a href="#3-HTTP报文内的HTTP信息" class="headerlink" title="3. HTTP报文内的HTTP信息"></a>3. HTTP报文内的HTTP信息</h1><h2 id="3-1-HTTP报文的结构"><a href="#3-1-HTTP报文的结构" class="headerlink" title="3.1 HTTP报文的结构"></a>3.1 HTTP报文的结构</h2><p>emm实际这个部分如果写过爬虫的话应该会很熟悉了</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526263911192.png" alt=""></p><h2 id="3-2-编码提升传输速率"><a href="#3-2-编码提升传输速率" class="headerlink" title="3.2 编码提升传输速率"></a>3.2 编码提升传输速率</h2><p>HTTP在传输数据时可以直接发送原数据，但是也可以在传输过程中通过编码来提升传输速率，但是同时编码的操作在本地完成，需要消耗一定程度的CPU</p><h3 id="3-2-1-报文和实体的区别"><a href="#3-2-1-报文和实体的区别" class="headerlink" title="3.2.1 报文和实体的区别"></a>3.2.1 报文和实体的区别</h3><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526264151128.png" alt=""></p><p>我个人的感觉是，实体就是原始数据，包括实体首部和实体主体，报文是实体编码之后，在信息传输途中的形式</p><h3 id="3-2-2-分割发送的分块传输编码"><a href="#3-2-2-分割发送的分块传输编码" class="headerlink" title="3.2.2 分割发送的分块传输编码"></a>3.2.2 分割发送的分块传输编码</h3><p>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。HTTP中存在一种称为传输编码的机制，专门应用于分块传输。</p><h2 id="3-3-获取部分内容的范围请求"><a href="#3-3-获取部分内容的范围请求" class="headerlink" title="3.3 获取部分内容的范围请求"></a>3.3 获取部分内容的范围请求</h2><p><span id="rangeRequest"></span><br>我们在平时肯定遇到过这样的情况：使用浏览器下载某项文件，中途中断了，此时再次下载从头开始显然非常可惜，一般情况下如果时间没有过的太久，浏览器会自动帮我们提供从中断处开始下载的功能。</p><p>要实现该功能需要指定下载的范围，我们称之为<strong>范围请求</strong>，我们只需要在head里加入如下<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526264594986.png" alt=""></p><p>范围的制定方式如下<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526264653159.png" alt=""></p><h2 id="3-4内容协商"><a href="#3-4内容协商" class="headerlink" title="3.4内容协商"></a>3.4内容协商</h2><p>当浏览器的默认语言为中文或者英文时，访问相同url的web网页则会显示对应的英文版或者中文版，这样的机制我们称之为<strong>内容协商</strong></p><blockquote><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，其会以语言，字符集，编码方式等为基准来判断响应的资源。同样的我们可以通过修改一些报文的首部来作为请求协商的手段</p></blockquote><p>内容协商分为3类</p><ol><li>服务器驱动协商（即由服务器来决定，但并不一定是最佳选择）</li><li>客户端驱动协商（即由客户端来决定，比如切换成pc版或者移动端）</li><li>透明协商（双方共同协商）</li></ol><h1 id="4-返回结果的HTTP状态码"><a href="#4-返回结果的HTTP状态码" class="headerlink" title="4. 返回结果的HTTP状态码"></a>4. 返回结果的HTTP状态码</h1><blockquote><p>http服务器端返回的状态码的作用就是，通过它的描述，拥护可以知道服务器端对自己的请求处理的状态</p></blockquote><h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><p>这个系列的状态码都表示请求被正常处理了</p><h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p>表示客户端发来的请求被正常处理了，这种情况一般是最“好”的结果</p><h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p>表示服务器已成功处理请求，但是没有任何实体返回，页面不更新。一般用于客户端单方向向服务器发送信息</p><h3 id="206-Partical-Content"><a href="#206-Partical-Content" class="headerlink" title="206 Partical Content"></a>206 Partical Content</h3><p>表示客户端进行了<a href="#rangeRequest">范围请求</a>,而服务器成功执行了这个请求</p><h2 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h2><p>这个系列表示浏览器需要执行某些特殊的处理以正常处理请求</p><h3 id="301-Moved-Permantly"><a href="#301-Moved-Permantly" class="headerlink" title="301 Moved Permantly"></a>301 Moved Permantly</h3><p>永久性重定向，表示请求的资源已被分配了新的url，以后使用该资源时应该使用现在给的url（以报文首部的location字段里给出来了）</p><h3 id="302-Not-Found"><a href="#302-Not-Found" class="headerlink" title="302 Not Found"></a>302 Not Found</h3><p>临时性重定向，希望用户本次能够使用新的url访问</p><h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><p>基本功能和302一致。但是明确向用户表示需要用GET方法获得资源</p><blockquote><p>当301,302,303系列状态码发回时，几乎所有的浏览器都会把post改成GET，并且删除报文内的主体，之后请求会自动再次发送。当然这么做是有违标准的，但大家都会这么做</p></blockquote><h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><p>表示客户端发送了附带条件的请求，服务器端找到了资源但是并未符合相应的条件</p><h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h3><p>临时重定向，与302功能相似</p><h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h2><p>该系列错误表示客户端是错误发生所在</p><h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>表示请求报文中存在语法错误。当错误发生时，需要修改内容并再次发送请求。</p><h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><p>表示需要经过验证，若之前已经验证过了，则表示验证失败</p><h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p>表示请求资源的访问被拒接了，服务器可以不给出理由，如果有理由，则可以在实体的主体部分中看到</p><h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>服务器上没有请求的资源</p><h2 id="5xx服务器错误"><a href="#5xx服务器错误" class="headerlink" title="5xx服务器错误"></a>5xx服务器错误</h2><p>表示错误出在服务器上</p><h3 id="500-Internet-Server-Error"><a href="#500-Internet-Server-Error" class="headerlink" title="500 Internet Server Error"></a>500 Internet Server Error</h3><p>表示服务器在执行请求时发生了错误，也有可能时bug或者临时的故障</p><h3 id="503-Service-Unavilable"><a href="#503-Service-Unavilable" class="headerlink" title="503 Service Unavilable"></a>503 Service Unavilable</h3><p>表示服务器暂时超负载或者停机维护，无法处理请求</p><h1 id="5-与HTTP协作的Web服务器"><a href="#5-与HTTP协作的Web服务器" class="headerlink" title="5.与HTTP协作的Web服务器"></a>5.与HTTP协作的Web服务器</h1><h2 id="5-1-用单台虚拟主机实现多个域名"><a href="#5-1-用单台虚拟主机实现多个域名" class="headerlink" title="5.1 用单台虚拟主机实现多个域名"></a>5.1 用单台虚拟主机实现多个域名</h2><p>HTPP/1.1允许一台HTTP服务器搭建多个Web站点。比如提供Web托管服务的供应商，可以用一台服务器为多位用户服务</p><p>由于DNS的设置，当浏览器中输入不同于域名的时候，最终访问到服务器的可以是相同的ip</p><h2 id="5-2-通信数据转发程序：代理，网关，隧道"><a href="#5-2-通信数据转发程序：代理，网关，隧道" class="headerlink" title="5.2 通信数据转发程序：代理，网关，隧道"></a>5.2 通信数据转发程序：代理，网关，隧道</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>本质上是一种类似于中转站的方式，接受有客户端发送的请求并转发给服务器端，反之亦然。同时，每次经过一级代理的时候，就会追加Via首部</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526278757111.png" alt=""></p><blockquote><p>使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的</p></blockquote><h4 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h4><p>代理转发响应时，缓存代理会预先将资源的副本缓存保存在代理服务器上。当代理再次接收到相对资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回</p><h4 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h4><p>看代理服务器在转发请求或者响应时会不会对报文做加工，如果没有加工则是透明代理，反之为非透明代理</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526279046268.png" alt=""></p><p>网关的作用机制和代理相似，但是目的不一样</p><blockquote><p>网关的功能是使通信线路上的服务提供非HTTP协议服务。利用网关能提高通信的安全性，因为可以在客户端与网关之间的线路上加密以确保连接的安全。比如网关可以连接数据库等</p></blockquote><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道不会解析HTTP请求，客户端可以不用在意它的存在，其作用是建立起一条安全的通信线路<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526279260810.png" alt=""></p><h2 id="5-3-保存资源的缓存"><a href="#5-3-保存资源的缓存" class="headerlink" title="5.3 保存资源的缓存"></a>5.3 保存资源的缓存</h2><blockquote><p>缓存是指代理服务器或者客户端本地磁盘内保存的资源副本。利用缓存能够减少对源服务器的访问，因此就节省了通信流量和通信时间。</p></blockquote><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526280001491.png" alt=""></p><h1 id="6-HTTP首部"><a href="#6-HTTP首部" class="headerlink" title="6 HTTP首部"></a>6 HTTP首部</h1><blockquote><p>HTTP首部字段传递重要信息</p></blockquote><h2 id="6-1-通用首部字段"><a href="#6-1-通用首部字段" class="headerlink" title="6.1 通用首部字段"></a>6.1 通用首部字段</h2><blockquote><p>通用首部字段是指请求报文和响应报文都会采用的首部</p></blockquote><h3 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h3><blockquote><p>控制缓存的工作机理，比如是否采用缓存，是否只针对特定用户才使用缓存等，缓存期限等</p></blockquote><h3 id="connection"><a href="#connection" class="headerlink" title="connection"></a>connection</h3><blockquote><p>作用1：控制不再转发给代理的首部字段（即里面是不再转发的首部字段名）</p><p>作用2：管理持久连接（指定connection为close，则断开持久连接）</p></blockquote><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><blockquote><p>表明HTTP报文创建的日期和时间</p></blockquote><h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><blockquote><p>作用是告知报文主体记录了哪些字段</p></blockquote><h3 id="via"><a href="#via" class="headerlink" title="via"></a>via</h3><blockquote><p>追踪客户端和服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会现在首部字段via中附加该服务器的信息，然后再进行转发</p></blockquote><h2 id="6-2-请求首部字段"><a href="#6-2-请求首部字段" class="headerlink" title="6.2 请求首部字段"></a>6.2 请求首部字段</h2><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><blockquote><p>告知服务器，用户代理能够处理的媒体类型以及媒体类型的相对优先级</p></blockquote><h3 id="accept-charset"><a href="#accept-charset" class="headerlink" title="accept-charset"></a>accept-charset</h3><h3 id="accept-encoding"><a href="#accept-encoding" class="headerlink" title="accept-encoding"></a>accept-encoding</h3><h3 id="accept-language"><a href="#accept-language" class="headerlink" title="accept-language"></a>accept-language</h3><h3 id="authorization"><a href="#authorization" class="headerlink" title="authorization"></a>authorization</h3><blockquote><p>告知服务器，用户代理的证书（认证信息）</p></blockquote><h3 id="except"><a href="#except" class="headerlink" title="except"></a>except</h3><blockquote><p>告诉服务器，期待出现的某种特定行为（状态码）</p></blockquote><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><blockquote><p>因为虚拟主机运行在同一个IP上，因此使用host来区分</p></blockquote><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526349521925.png" alt=""></p><h3 id="if-match"><a href="#if-match" class="headerlink" title="if-match"></a>if-match</h3><blockquote><p>称之为条件请求，它会告知服务器匹配资源所用的实体标记（ETag）</p></blockquote><h3 id="if-modified-since"><a href="#if-modified-since" class="headerlink" title="if-modified-since"></a>if-modified-since</h3><blockquote><p>条件请求，它希望从服务器那里获取指定日期之后更新的文件</p></blockquote><h3 id="if-none-match"><a href="#if-none-match" class="headerlink" title="if-none-match"></a>if-none-match</h3><blockquote><p>与if-match正好相反</p></blockquote><h3 id="if-range"><a href="#if-range" class="headerlink" title="if-range"></a>if-range</h3><h3 id="if-unmodified-since"><a href="#if-unmodified-since" class="headerlink" title="if-unmodified-since"></a>if-unmodified-since</h3><h3 id="max-forwards"><a href="#max-forwards" class="headerlink" title="max-forwards"></a>max-forwards</h3><blockquote><p>指定最多再妆发多少次，当次数为0，则不再转发而是直接给出响应</p></blockquote><h3 id="referer"><a href="#referer" class="headerlink" title="referer"></a>referer</h3><blockquote><p>告知服务器请求的原始资源的url</p></blockquote><h3 id="user-agent"><a href="#user-agent" class="headerlink" title="user-agent"></a>user-agent</h3><blockquote><p>表示浏览器的种类</p></blockquote><h2 id="6-3-响应首部字段"><a href="#6-3-响应首部字段" class="headerlink" title="6.3 响应首部字段"></a>6.3 响应首部字段</h2><h3 id="accept-ranges"><a href="#accept-ranges" class="headerlink" title="accept-ranges"></a>accept-ranges</h3><h3 id="etags"><a href="#etags" class="headerlink" title="etags"></a>etags</h3><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><blockquote><p>提供重定向的地址（浏览器一般都会尝试对这个地址的访问）</p></blockquote><h3 id="retry-after"><a href="#retry-after" class="headerlink" title="retry-after"></a>retry-after</h3><h2 id="6-4-实体首部字段"><a href="#6-4-实体首部字段" class="headerlink" title="6.4 实体首部字段"></a>6.4 实体首部字段</h2><h3 id="allow"><a href="#allow" class="headerlink" title="allow"></a>allow</h3><blockquote><p>即允许使用的http方法</p></blockquote><h3 id="content-encoding"><a href="#content-encoding" class="headerlink" title="content-encoding"></a>content-encoding</h3><h3 id="conten-type"><a href="#conten-type" class="headerlink" title="conten-type"></a>conten-type</h3><h1 id="7-确保web安全的HTTPS"><a href="#7-确保web安全的HTTPS" class="headerlink" title="7. 确保web安全的HTTPS"></a>7. 确保web安全的HTTPS</h1><h2 id="7-1-http的缺点"><a href="#7-1-http的缺点" class="headerlink" title="7.1 http的缺点"></a>7.1 http的缺点</h2><h3 id="7-1-1主要缺点"><a href="#7-1-1主要缺点" class="headerlink" title="7.1.1主要缺点"></a>7.1.1主要缺点</h3><ul><li>通信使用明文，内容可能被窃听</li><li>不验证通信双方的身份，因此有可能遭遇伪装</li><li>无法验证明文的完整性，所以有可能已遭篡改</li></ul><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526354175531.png" alt=""></p><h3 id="7-1-2-加密手段"><a href="#7-1-2-加密手段" class="headerlink" title="7.1.2 加密手段"></a>7.1.2 加密手段</h3><h4 id="通信的加密"><a href="#通信的加密" class="headerlink" title="通信的加密"></a>通信的加密</h4><p>http中没有对通信进行加密的机制，但是我们可以通过和SSL（安全套接层）组合使用，加密http的通信内容</p><p>与ssl组合的http称为<strong>https</strong></p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526354188927.png" alt=""></p><h4 id="内容的加密"><a href="#内容的加密" class="headerlink" title="内容的加密"></a>内容的加密</h4><p>即客户端对http报文进行加密处理再发送请求，但是这样保密性不如前者，仍然有泄密的风险</p><h3 id="7-1-3-不验证通信方的身份就可能遭遇伪装"><a href="#7-1-3-不验证通信方的身份就可能遭遇伪装" class="headerlink" title="7.1.3 不验证通信方的身份就可能遭遇伪装"></a>7.1.3 不验证通信方的身份就可能遭遇伪装</h3><ul><li>无法验证服务器的真伪</li><li>无法验证客户端的真伪</li><li>无法确定对方是否具有访问权限</li><li>无法判定请求来自何方</li><li>即使无意义的请求也会赵丹泉水，无法阻止海量请求下的Dos（拒绝服务攻击）</li></ul><h4 id="验证对手的证书"><a href="#验证对手的证书" class="headerlink" title="验证对手的证书"></a>验证对手的证书</h4><blockquote><p>ssl不仅提供加密处理，而且还提供了一种被称为证书的手段，可用于确定通信方。<br><strong>证书</strong>由值得信任的第三方机构颁发，用于证明服务器和客户端是实际存在的，另外伪造证书的技术难度是很大的</p></blockquote><h3 id="7-1-4-无法证明报文完整性，可能已遭篡改"><a href="#7-1-4-无法证明报文完整性，可能已遭篡改" class="headerlink" title="7.1.4 无法证明报文完整性，可能已遭篡改"></a>7.1.4 无法证明报文完整性，可能已遭篡改</h3><h4 id="接收到的内容可能有误"><a href="#接收到的内容可能有误" class="headerlink" title="接收到的内容可能有误"></a>接收到的内容可能有误</h4><p>由于http协议无法验证报文的完整性，因此没法确认内容有误或者遭篡改（比如MITM中间人攻击）</p><h4 id="如何防止篡改"><a href="#如何防止篡改" class="headerlink" title="如何防止篡改"></a>如何防止篡改</h4><blockquote><p>最常用的方法是MD5和SHA-1等散列值校验的方法，以及用数字签名</p></blockquote><p>可惜的是，用这些方法也依然无法保证安全性，因为其本身遭篡改的话，用户还是没法查觉，我们还是必须要用到https</p><h2 id="7-2-http-加密-认证-完整性保护-https"><a href="#7-2-http-加密-认证-完整性保护-https" class="headerlink" title="7.2 http+加密+认证+完整性保护 = https"></a>7.2 http+加密+认证+完整性保护 = https</h2><blockquote><p>https并非是应用层的一种新协议，只是http通信接口部分用ssl和tls协议代替。通常情况下，http直接与tcp通信，当使用ssl时，则变成先和ssl通信，再有ssl和tcp通信</p></blockquote><h2 id="7-3-https的一些弊病"><a href="#7-3-https的一些弊病" class="headerlink" title="7.3 https的一些弊病"></a>7.3 https的一些弊病</h2><p>https也存在一些问题，也就是它的处理速度会变慢。</p><p>慢分为两个层面，一个是通信慢，另一种是占用cpu，导致处理速度慢</p><p>和使用http相比，网络负载可能会变慢<strong>2到100倍</strong>。</p><p>针对速度变慢这个特点，并没有根本性的解决方法，我们会采用ssl加速器（专门针对服务器）这种硬件来改善</p><p>所以一般来说，网站里只需要对包含个人信息等敏感数据时采用https加密通信</p><p>特别是那些访问量较多的web网站在进行加密处理时，它们所承担的负载不容小觑，并非所有的内容都加密，仅在需要隐藏信息的内容时才进行加密，以节约资源</p><p>除此之外，想要节约购买证书的开销也是原因之一</p><h1 id="8-确认访问用户身份的验证"><a href="#8-确认访问用户身份的验证" class="headerlink" title="8.确认访问用户身份的验证"></a>8.确认访问用户身份的验证</h1><h2 id="8-1-BASIC认证"><a href="#8-1-BASIC认证" class="headerlink" title="8.1 BASIC认证"></a>8.1 BASIC认证</h2><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526608271186.png" alt=""></p><blockquote><p>BASIC认证虽然是采用了Base64编码方式，但这不是加密处理，<strong>不需要任何附加信息就可以解码，换而言之，就等于是明文发送密码和账户</strong>，如果被人窃听，被盗的几率很高</p></blockquote><h2 id="8-2-DIGEST认证"><a href="#8-2-DIGEST认证" class="headerlink" title="8.2 DIGEST认证"></a>8.2 DIGEST认证</h2><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526608448753.png" alt=""></p><blockquote><p>由于发送给对方的只是由质询码产生的计算结果，所以比起BASIC，其泄露的可能性降低了很多</p></blockquote><h2 id="8-3-SSL客户端认证"><a href="#8-3-SSL客户端认证" class="headerlink" title="8.3 SSL客户端认证"></a>8.3 SSL客户端认证</h2><p>一般的机制下，只要账户和密码正确，就可以认证是本人的行为，但如果用户的ID和密码被盗，就有很大的可能被冒充，利用ssl客户端则可以避免该情况的发生</p><p>一般来说，ssl客户端认证是<strong>证书+密码</strong>双重机制来保证安全</p><h2 id="8-4-基于表单的认证"><a href="#8-4-基于表单的认证" class="headerlink" title="8.4 基于表单的认证"></a>8.4 基于表单的认证</h2><blockquote><p>由于使用上的便利性以及安全性问题，BASIC和DIGEST认证几乎不怎么使用。另外SSL客户端认证虽然有较高的安全等级，但因为维持费用的问题，还尚未普及。目前web尚多半为各自实现的基于表单的认证方式</p></blockquote><h1 id="9-基于HTTP的功能追加协议"><a href="#9-基于HTTP的功能追加协议" class="headerlink" title="9. 基于HTTP的功能追加协议"></a>9. 基于HTTP的功能追加协议</h1><h2 id="9-1-消除HTTP瓶颈的SPDY"><a href="#9-1-消除HTTP瓶颈的SPDY" class="headerlink" title="9.1 消除HTTP瓶颈的SPDY"></a>9.1 消除HTTP瓶颈的SPDY</h2><h3 id="9-1-1-HTTP的瓶颈"><a href="#9-1-1-HTTP的瓶颈" class="headerlink" title="9.1.1 HTTP的瓶颈"></a>9.1.1 HTTP的瓶颈</h3><ul><li>一条连接上只可发送一个请求</li><li>请求只能从客户端开始，客户端不可以接受除响应之外的指令</li><li>请求/响应首部未经过压缩就发送，首部信息越多延迟越大</li><li>发送冗长的首部，每次互相发送相同的首部造成的浪费越大</li><li>可任意选择数据压缩格式，非强制压缩放送</li></ul><h3 id="9-1-2-SPDY的设计与功能"><a href="#9-1-2-SPDY的设计与功能" class="headerlink" title="9.1.2 SPDY的设计与功能"></a>9.1.2 SPDY的设计与功能</h3><p>它并没有完全改写HTTP协议，只是通过新加会话层的形式运作<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526610952788.png" alt=""></p><ul><li>多路复用流。通过单一的tcp连接，可以无限制地处理多个HTTP请求</li><li>赋予请求优先级</li><li>压缩http首部</li><li>推送功能。支持服务器主动向客户端推送数据的功能</li><li>服务器提示功能</li></ul><h2 id="9-2-使用浏览器进行全双工通信的WebSocket"><a href="#9-2-使用浏览器进行全双工通信的WebSocket" class="headerlink" title="9.2 使用浏览器进行全双工通信的WebSocket"></a>9.2 使用浏览器进行全双工通信的WebSocket</h2><h3 id="9-2-1-功能"><a href="#9-2-1-功能" class="headerlink" title="9.2.1 功能"></a>9.2.1 功能</h3><ul><li>推送功能</li><li>减少通信量</li><li>由于是建立在http基础上的协议，因此连接的发起方仍然是客户端，而一旦建立起WebSocket通信连接，双方都可以直接向对方发送报文</li></ul><h1 id="10-Web的攻击技术"><a href="#10-Web的攻击技术" class="headerlink" title="10. Web的攻击技术"></a>10. Web的攻击技术</h1>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;6月份开始的一个比赛需要网络方面的知识，但是限于专业和自己的懒惰，自己一直对计算机网络的知识处于一个一知半解的程度，正好掏出买了半年但一直没看的书，从头到尾梳理一遍。顺便下次组会展示的时候科普一下网络的知识。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>毕设DEMO</title>
    <link href="http://yoursite.com/2018/03/07/%E6%AF%95%E8%AE%BEDEMO/"/>
    <id>http://yoursite.com/2018/03/07/毕设DEMO/</id>
    <published>2018-03-07T13:10:31.000Z</published>
    <updated>2018-04-17T13:12:11.654Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/demo/毕设/index2.html">DEMO1</a></p><p><a href="/demo/船舶可视化/index.html">DEMO2</a></p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/demo/毕设/index2.html&quot;&gt;DEMO1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/demo/船舶可视化/index.html&quot;&gt;DEMO2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>【css布局之position】</title>
    <link href="http://yoursite.com/2018/03/03/%E3%80%90css%E5%B8%83%E5%B1%80%E4%B9%8Bposition%E3%80%91/"/>
    <id>http://yoursite.com/2018/03/03/【css布局之position】/</id>
    <published>2018-03-03T03:59:11.000Z</published>
    <updated>2018-03-03T04:20:55.426Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这段时间在刷百度前端学院，从最基础的task开始刷。好久没有碰css了，一年前做起来轻车熟路的东西，现在竟然要花很久来调试，于是想着干脆写几篇文章来彻底整理一下有关css布局的东西，这一篇从position开始。</p></blockquote><a id="more"></a><h1 id="css中的positon"><a href="#css中的positon" class="headerlink" title="css中的positon"></a>css中的positon</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这段时间在刷百度前端学院，从最基础的task开始刷。好久没有碰css了，一年前做起来轻车熟路的东西，现在竟然要花很久来调试，于是想着干脆写几篇文章来彻底整理一下有关css布局的东西，这一篇从position开始。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="布局" scheme="http://yoursite.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
</feed>
