<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Prozac’s blog</title>
  
  <subtitle>记录学习的技能和遇到的问题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-14T11:12:20.533Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Prozac</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020春招总结</title>
    <link href="http://yoursite.com/2020/04/14/2020%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/04/14/2020春招总结/</id>
    <published>2020-04-14T07:52:26.000Z</published>
    <updated>2020-04-14T11:12:20.533Z</updated>
    
    <content type="html"><![CDATA[<p>其实我的春招在上一周就完成地差不多了，但是一直在整理剑指offer的一个项目再加上被学校的事占用了一些时间，这才有机会好好整理一下自己春招的情况和最近的学习状态，东西很杂，但我会尽量按逻辑梳理</p><a id="more"></a><h1 id="春招之路"><a href="#春招之路" class="headerlink" title="春招之路"></a>春招之路</h1><p>首先我这这篇文章不是讲面经的，我的面经早就已经整理在<a href="https://luvsunlight.github.io/front-end-cookbook/#/_posts/%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86" target="_blank" rel="external">我的项目里</a>，感兴趣的可以去看看</p><p>今年的春招也是我第一次正经的技术面试，我一共投递了五家企业，都是在牛客上找的内推，其中猿辅导没有暑假实习，美团二面之后就没有消息了，字节给了offer，然后阿里走到了hr面，还在等后续。快手我最后拒了，因为效率太慢了…</p><p>面试的感受的话，其实面经也讲了很多，这里也聊聊吧，不过只讲感受不讲细节。这次春招之前我做了接近一个月的准备，其实真正的准备是去年开始的，包括算法数据结构/JS基础，今年2月系统整理了浏览器知识和网络知识，再去刷了一周面经，差不多查漏补缺了就去面试了。事实证明，应届生面试，基础知识真的非常非常重要，我的工程化知识大部分面试官都不会太刁难，基础知识我自己感觉占了面试过程中80%的比重。</p><p>当然面试过程中也有很多插曲，阿里的面试是我在牛客上找的一位学长，最开始他帮我修改简历，到最后我每次面试的进度跟进还有平时疑惑的地方，这位学长都会不厌其烦地解惑，真的非常感谢!（阿里面试过程中遇到的每位前辈人都超级nice!，一面二面三面面试官包括校招的leader）字节的hr比较慢等offer等了很久…美团我一二面感觉没啥问题，不知道为啥被泡了池子。快手效率比阿里还慢…我上述五个岗位是同时投递的，但是字节美团和阿里都接近面试的尾声了，快手过了一个月才通知我一面，最后我因为这段时间想要静下心来学习还是委婉拒绝了后续的面试。面试的过程能够收获很多东西，比如你有哪些知识属于短板，比如现在招聘市场上面试官看中哪些功能，还有你可以借此机会结识很多大牛，不管后续结果如何，总归是多了一份机会。但是同时面试也是一个比较痛苦的过程，它对心理素质和身体素质都是一次考验，等待陌生电话的感觉既紧张又刺激，同时你也很难抽出大块的时间来武装你自己，毕竟这个时候的准备都是有限面向面试的</p><p>最后是一句老话，虽然基础功的积累很难突击，这需要平时的日积月累，但是也无需对自己太过不自信，永远没有完全准备好的那一天，面试官问的问题总有你不知道的，这也不是丢脸的事情，但重要的是你基础知识牢靠，见招拆招，你虽然不了解这个领域，但是可以结合自己的内功尝试向面试官阐述自己的理解，比如我字节一面时面试官问了我一个大量插入DOM的场景该怎么设计策略，我虽然没有做过这种业务，但是涉及大量DOM操作肯定要往重绘重排上考虑。当然如果技术性太强，自己又完全不知道就老实向面试官承认即可</p><h1 id="关于未来一段时间的学习"><a href="#关于未来一段时间的学习" class="headerlink" title="关于未来一段时间的学习"></a>关于未来一段时间的学习</h1><p>通过春招这接近一个月的面试体验来说，我对自己的能力边界也有一个大概的了解。首先我前端基础知识基本没有太大的问题，不管是哪一家的面试，我在这方面没有出过大的纰漏，这也和我自己系统的复习有关，从JS基础，到浏览器机制，网络和安全，工程化和框架。这些问题目前我都有自己的理解和体系，就算没接触过的业务也可以快速定位到知识点，这是我目前最大的优势，要保持但是也不能松懈</p><p>但是也有一些硬的点我在面试过程中表现不太好，给我拉低了分的</p><ul><li>计算机基础知识。比如我知道进程和线程的区别，但是我不知道其运行的原理</li><li>算法和数据结构。算法和数据结构对于编码能力的进阶非常重要</li><li>复杂业务的实践</li></ul><p>上述三点是我仔细总结自己在面试过程中暴露的三个主要问题，那么接下来的时间我将会就这几个问题专门突破</p><ul><li>计算机基础知识 =&gt; CSSAPP</li><li>算法 =&gt; 剑指offer(已完成)/leetcode做题+系统整理</li><li>复杂业务 =&gt; 找一个复杂业务/自己实施从想法到落地</li></ul><h1 id="关于知识输出"><a href="#关于知识输出" class="headerlink" title="关于知识输出"></a>关于知识输出</h1><p>之前写了一篇文章讲自己对知识输出的思考，最近又有了一些新的思考。我自己平时因为加入社区不多，也不可能说有事没事上技术网站上看有没有新的热点技术（网站文章质量参差不齐也是一个原因），这种情况下，推送式的服务就显得尤为重要了，目前我摄入知识性文章最多的还是公众号和微博，掘金和InfoQ只是闲暇时看一下，毕竟轮询的效率摆在这哈哈哈。话说回来，我自己目前阶段不会开公众号的，以后想法会不会变再另说，但是我必须承认公众号是一个非常有效的知识摄入手段</p><p>再说说自己目前的知识输出计划吧，自己的知识输出也是历经多个平台，从最开始的在onenote上以笔记的形式记录，到个人博客，再到github仓库，可以说有一定自己的心得体会，个人博客是个非常好的平台，它不仅可以用于记录技术，也可以记录生活，我觉得部分层面上它可以支撑起一个精神自留地的作用，但是坏处是略微有点零散，不适合做系统知识的整理，所以我后来选择了docsify和自己写的插件的组合来整理系统知识，比如算法，比如前端知识，但是这样其实也有缺陷，因为这样只适合系统的开源知识，一些比如业务知识或者日常的记录，其实并不适合以文档的形式记录。我个人不支持直接在github上维护，因为这样阅读体验会很差（但是好像有github issue转blog的工具），不过还是不推荐，docsify可以直接在线看，效率也很可以</p><p>春招期间，神三元的经历深深打动了我，让我明白了自己目前其实还是处于舒适区，还需要学习的东西有很多很多，还需要继续努力</p><h1 id="关于GTD"><a href="#关于GTD" class="headerlink" title="关于GTD"></a>关于GTD</h1><p>自己的GTD一直在变，最开始是onenote，后来转奇妙清单，最近因为在用MWeb，所以就用MWeb做GTD，MWeb写文档非常爽，但是其启动慢，多端同步慢，我已经逐渐感觉到其局限性，前几天用了滴答清单，社区评价还可以，但是说实话我自己使用是怎么都不顺手，于是想着重新用回奇妙清单，发现奇妙清单转移到微软的Todo了，下载之后，发现，非常好用！</p><p>想了一个模式，即todo的事都记录在微软Todo上，然后每周周末的时候再在MWeb在总结做存档，毕竟微软的那个没有存档的功能</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实我的春招在上一周就完成地差不多了，但是一直在整理剑指offer的一个项目再加上被学校的事占用了一些时间，这才有机会好好整理一下自己春招的情况和最近的学习状态，东西很杂，但我会尽量按逻辑梳理&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>关于知识输出</title>
    <link href="http://yoursite.com/2020/01/27/%E5%85%B3%E4%BA%8E%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/"/>
    <id>http://yoursite.com/2020/01/27/关于知识输出/</id>
    <published>2020-01-27T04:59:05.000Z</published>
    <updated>2020-04-14T07:54:16.586Z</updated>
    
    <content type="html"><![CDATA[<p>一些关于知识输出的思考</p><a id="more"></a><p>近日，一件事情引发了我对知识输出平台的思考：我在公众号里关注的一位极其优秀的前端行业从业者在年终总结中透露出他是年初才开始入的前端坑，我当时就极其震撼，感觉自己本科期间学习的几年内容完全是白学了，这位作者自言也是今年开始在掘金上发布有质量的文章，同时开始写公众号，持续输出知识。看到这里，我开始认真思考起我的知识输出途径</p><p>目前，我的知识输出途径还比较有限且封闭，一个是github pages上搭建的自用博客，目前零零散散地写了一些文章，还有就是github上维护了两个基于docsify的项目，主要用于记录前端知识点，我自认为输出的质量不低，但是说实话这两种途径输出的效果比较封闭。我思考今年应该寻求怎么样的一个新形式来保证自己的输出质量和效果</p><p>但是老实说，我是比较反感技术人员用公众号的形式进行输出的，理由有很多很多。</p><p>第一公众号封闭，它没有办法用rss扒，只能在移动端取得比较好的阅读体验，哪怕在pc的原生客户端上，阅读起来也相当费劲，比如我要是在公众号上找到了一个有质量的发布者，我想阅读他的全部作品，是一件非常费劲的事。</p><p>第二，我认为公众号本身是一个对标报纸/新闻的产品，报纸的好处在于每天都有新鲜的看，但是一般阅读难度和深度都不大，属于娱乐型的阅读途径，很少有人会把去年一年的报纸拿过来整合看，这样做非常蠢也不符合报纸的定位。公众号在我这看来同样如此，它就像一个流，只适合浅层次阅读。当然我们如果想将公众号内容整合起来也可以做对应的开发工作，当然这在我看来属于得不偿失的工作，为什么要想尽办法给猫套上马鞍呢？</p><p>第三，公众号没有办法和pocket这样的延迟阅读的工具整合在一起，虽然有微信的收藏功能，但是这也丢失了pocket的全平台整合的优势了</p><p>第四，我个人在阅读学习类知识时，更偏向用电脑或者纯电子书，手机阅读是最次最次的选择，原因很简单，手机上诱惑更多更大，很多情况你就不知不觉跑去看微博去了。同时，电脑上有编辑器，有终端，有各种测试手段，比手机上的阅读体验要好很多。这也是我非常反感极客时间的打卡限定小程序平台上的原因，打卡总结知识在我看来用电脑要顺滑百倍，可惜的是只能在小程序端打卡。</p><p>第五，公众号抱团化，同质化问题严重，当然CSDN上的文章同质化问题也不小，但是当我集中刷公众号上的文章时，我发现这个问题的严峻性还是超乎了我的想象，我不知道是因为可以凑字数，使公众号看起来饱满还是单纯的公众号作者之间报团取暖，我关注了接近二十多个前端领域的公众号，其中绝大多数发布的文章同质化极其严重，一个问题你讲过来我讲过去，显得很没有水准和诚意。当然我们平时自己也有开发任务在身，不可能说一周全部的时间都用来写原创内容，但是我觉得可以以周报的形式来汇总自己觉得有价值的文章，自己可以做微评或者本周的原创工作基于周报上的内容进行展开，这在我看来是一个比较好，比较规范的知识输出途径</p><p>写到这里，我自己大概也有些思绪了。2020年开始，我的知识输出将以以下几个板块为主</p><h2 id="知识笔记"><a href="#知识笔记" class="headerlink" title="知识笔记"></a>知识笔记</h2><p>零零散散的博客一旦数量汇集起来会显得非常散乱，我需要一个规范的，有条理的archive来将我所学习的知识进行整合起来，这个部分我还是交给我在github上维护的<a href="https://github.com/luvsunlight/front-end-cookbook" target="_blank" rel="external">项目</a></p><h2 id="单独的博客"><a href="#单独的博客" class="headerlink" title="单独的博客"></a>单独的博客</h2><p>这个系列是精讲知识，比如单独拎出一个知识点，或者学习某一项新技术，这些东西放在知识笔记里不合适，以博客的形式记录最好。我选择githubpages搭的博客，以及掘金这两个平台进行发布，前者是为了获取更多的曝光量，让我开始和社区进行有效的互动，后者则是我作为程序员自己的私域</p><h2 id="维护一份前端周报"><a href="#维护一份前端周报" class="headerlink" title="维护一份前端周报"></a>维护一份前端周报</h2><p>我对前端始终怀有热爱和虔诚，我获取前端知识的渠道非常广，极客时间，掘金，InfoQ，segmentfault，书籍，公众号，微博…。每一个平台都有各自的特点和可取之处，我决定在2020年维护一份前端周报</p><p>我自己平时关注的周报的形式也有不同，简单的如腾讯新闻团队的github上建一个项目，复杂一点的如蚂蚁金服的在语雀上发布的项目。我更偏向于前者，一个是周报量不大，没有必要用一个很大的项目来维护。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些关于知识输出的思考&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>{}&lt;3表达式的返回值什么</title>
    <link href="http://yoursite.com/2020/01/02/3%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2020/01/02/3表达式的返回值什么/</id>
    <published>2020-01-02T12:44:56.000Z</published>
    <updated>2020-01-02T13:08:39.839Z</updated>
    
    <content type="html"><![CDATA[<p>在看红宝书的时候，测试{}&lt;3时，发生了出乎意料的返回结果…</p><a id="more"></a><p>今天系统重新巩固红宝书，在词法的操作符版块，看到了关系操作符，兴致上来了自己测试了几个用例</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"23"</span> &lt; <span class="string">"3"</span> <span class="string">//</span> <span class="literal">true</span></div><div class="line"><span class="string">"a"</span> &lt; 1 <span class="string">//</span> <span class="literal">false</span></div></pre></td></tr></table></figure><blockquote><p>我们先来看看红宝书上对该操作符的描述</p></blockquote><ul><li>如果两个操作数都是数值类型，则进行数值比较</li><li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值</li><li>如果一个操作数是数值，则将另外一个转化为数值，然后再比较</li><li>如果一个操作符是对象，则调用valueOf，用得到的结果按照前面的规则执行比较，如果没有valueOf方法或者返回的值不是基本类型，则用toString方法</li><li>如果一个操作数是NaN则返回false，因为NaN不能比较</li></ul><p>那么，我们来看一下<code>{}&lt;3</code>这个表达式，3是数值类型，那么我们就对另外一个值操作，先调用valueOf操作,返回{}不是基本数据类型，则调用toString方法，返回”[object Object]”是基本类型,现在变成了一个数值3和一个字符串”[object Object]”进行该操作,我们对字符串进行强制类型转换，转化为NaN，那么实际应该是NaN &lt; 3,返回false才对，但是在chrome浏览器上则是抛出未知语法错误，我就产生了巨大的疑惑，难道是我哪一步推导产生了错误？</p><p>打开vsc写了一个脚本如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123;</div><div class="line">valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"o1 valueOf"</span>)</div><div class="line"><span class="keyword">return</span> []</div><div class="line">&#125;,</div><div class="line">toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"o1 toString"</span>)</div><div class="line"><span class="keyword">return</span> <span class="string">"[object Object]"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(o1 &lt; <span class="number">3</span>) </div><div class="line"><span class="comment">// o1 valueOf</span></div><div class="line"><span class="comment">// o1 toString</span></div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure><p>我自己在这里模拟了一个object，但是为什么在node下就没有报错呢？我又测试了一下更简单直接的版本</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(&#123;&#125; &lt; <span class="number">3</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure><p>到这里才恍然大悟，原来之前的语法报错是chrome浏览器自己做的手段，跟ECMAScript规范没有关系</p><p>但是也要注意对象在这里的处理情况，并不是对象调用[ToPrimitive]属性直接作为返回值，而是将返回值再带入规则中，可能还要进行第二轮的类型转换</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var o1 = &#123;</div><div class="line">valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"o1 valueOf"</span>)</div><div class="line"><span class="keyword">return</span> <span class="string">"1"</span></div><div class="line">&#125;,</div><div class="line">toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"o1 toString"</span>)</div><div class="line"><span class="keyword">return</span> <span class="string">"a"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var o2 = &#123;</div><div class="line">valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"o2 valueOf"</span>)</div><div class="line"><span class="keyword">return</span> <span class="number">2</span></div><div class="line">&#125;,</div><div class="line">toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"o2 toString"</span>)</div><div class="line"><span class="keyword">return</span> <span class="number">4</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o1 &lt; o2)</div><div class="line"><span class="regexp">//</span> o1 valueOf </div><div class="line"><span class="regexp">//</span> o2 valueOf</div><div class="line"><span class="regexp">//</span> <span class="literal">true</span></div></pre></td></tr></table></figure><p>上例中，”1”和2比较，套用规则，再将”1”转换成1之后进行比较</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var o1 = &#123;</div><div class="line">valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"o1 valueOf"</span>)</div><div class="line"><span class="keyword">return</span> <span class="number">1</span></div><div class="line">&#125;,</div><div class="line">toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"o1 toString"</span>)</div><div class="line"><span class="keyword">return</span> <span class="string">"a"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var o2 = &#123;</div><div class="line">valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"o2 valueOf"</span>)</div><div class="line"><span class="keyword">return</span> <span class="string">"a"</span></div><div class="line">&#125;,</div><div class="line">toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"o2 toString"</span>)</div><div class="line"><span class="keyword">return</span> <span class="number">4</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o1 &lt; o2)</div><div class="line"><span class="regexp">//</span> o1 valueOf </div><div class="line"><span class="regexp">//</span> o2 valueOf</div><div class="line"><span class="regexp">//</span> <span class="literal">false</span></div></pre></td></tr></table></figure><p>上例中1和”a”比较，”a”转换为NaN，则返回false</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看红宝书的时候，测试{}&amp;lt;3时，发生了出乎意料的返回结果…&lt;/p&gt;
    
    </summary>
    
      <category term="技术细节" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年终总结</title>
    <link href="http://yoursite.com/2019/12/30/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/30/2019年终总结/</id>
    <published>2019-12-30T12:35:10.000Z</published>
    <updated>2020-03-03T08:40:16.277Z</updated>
    
    <content type="html"><![CDATA[<p>2019年的年度总结</p><a id="more"></a><p>2019年在这个博客上写的东西很少了，主要是因为感觉在这个blog上东一篇西一篇地写文章很没有章法，也不利于记忆。于是在github上另开了两个仓库，<a href="https://github.com/luvsunlight/front-end-cookbook" target="_blank" rel="external">前端知识手册</a>和<a href="https://github.com/luvsunlight/frontend-interview-archive" target="_blank" rel="external">前端面试手册</a>，关于系统性知识的总结都放在了github的仓库上面。</p><p>一时间都有种想要废弃这个blog的打算，但是意识到知识手册终究是知识手册，想要有一个全面性的知识输出，还是得靠博客，于是我又回来了</p><p>正式开始之前先感慨一句，去年9月份才刚刚研究生入学，但是一晃眼，我就又到了要准备两个月后的春招了，时间真的不等人啊，不过小组内一届的专硕更加不容易，研究生生涯开始半年就要开始准备工作的事宜了，想想大家都还是挺不容易的</p><p>2019年，这一年的我是既勤奋又不勤奋的一年，我虽自诩为前端行业从事者也是爱好者，本科阶段的课程作业也均是使用前端相关技术，但说来惭愧，我从去年9月份才开始接触vue，进而引入前端的新浪潮，在这短短的一年里，我接触并学习了无数的新名词和新领域。新知识之多让我不禁感慨，怎么本科阶段通杀的那些技术到了如今显得如此不堪，再回首以前的经历时感觉自己好像在玩泥巴。</p><p>正式总结如下</p><p>在这一年里，我在技术方面做了如下的事</p><blockquote><p>项目方面</p></blockquote><ul><li>happy-question项目，学习vue全家桶做一个稍大型的项目</li><li>在学习css布局各种知识时，使用vue-cli创建了<a href="https://github.com/luvsunlight/css-layout-demo" target="_blank" rel="external">一个项目</a>用于加深理解</li><li>vue-beauty项目，<code>vue</code>+<code>vuex</code>+<code>vue-router</code>+<code>vue-infinite-scroll</code>+<code>vue-awesome</code>+<code>axios</code>+<code>懒加载</code>+<code>less</code>，做了一个懒加载好康图片的应用（github上找的练手项目）</li><li><a href="https://github.com/luvsunlight/vue-chat" target="_blank" rel="external">vue-chat项目</a>，<code>vue全家桶</code>+<code>mock</code>+<code>less</code>等，一个仿微信聊天的应用，练手之作</li><li><a href="https://github.com/luvsunlight/vue-todos" target="_blank" rel="external">vue-todos项目</a>，技术栈同上，也是一个练手之作，主要是好看，自己觉得特别舒服</li><li><a href="https://github.com/luvsunlight/js-archive-creator" target="_blank" rel="external">js-archive项目</a>，最开始是因为在整理知识网的时候，有好几个项目想要整理，感觉都可以写成一个工具，以便复用，现在是一个半完成体，只支持localStorage，还没有做数据库的存储</li><li><a href="https://github.com/luvsunlight/vuelegant" target="_blank" rel="external">vuelegant</a>，打算自己从头写一个UI框架，参考的是<a href="https://vue.ant.design/components/message-cn/" target="_blank" rel="external">ant-design-vue</a>和<a href="https://www.iviewui.com/components/icon" target="_blank" rel="external">iView</a>的源码，虽然尚未完成，但是学习了很多组件库的组织方式，命名规范等</li><li>osm-track-proj，这个是研究生期间导师要求完成的项目，技术栈为<code>vue全家桶</code>+<code>mock</code>+<code>ant-design-vue</code>+<code>less</code>+<code>axios</code>+<code>Web GL</code>+<code>nodejs</code>+<code>mySql</code>,是一个很全面的项目，不过导师并没有采纳此方案</li><li>完成了两个小程序，一个是给女朋友的生日礼物，还有一个是给机房设计的月报系统</li></ul><blockquote><p>开源方面</p></blockquote><ul><li>学习了vue-cli2.x版本的自定义template，自己写了一个<a href="https://github.com/luvsunlight/webpack" target="_blank" rel="external">常用的template</a>并且push到github上了（后已全部改用vue-cli3.x ~ ？）</li><li>耗时两个月，系统学习了数据结构和算法，并且在leetcode上刷了一定量的题目（后来因为准备前端系统知识而暂时搁置），对基本的数据结构和算法有较为熟练的掌握和理解。并且在github上基于docsify建立了一个<a href="https://github.com/luvsunlight/algorithm" target="_blank" rel="external">项目</a></li><li><code>gulp</code>+<code>babel</code>+<code>npm script</code>做了一个<a href="https://github.com/luvsunlight/docsify-vuepress-theme" target="_blank" rel="external">docsify的theme</a>，这个时候还不知道CI，自己写了一个脚本用于打包和部署npm仓库，但也算正式脱离vue-cli工具，自己构建工具流。<ul><li>可以改进的地方有很多，比如持续构建，AST代替正则会更好</li></ul></li><li>基于<code>webpack</code>+<code>babel</code>+<code>travis CI</code>+<code>semantic release</code>+<code>mocha+chai</code>做了一个自定义log的库，正式用持续构建的思想去维护开源项目</li><li>基于<code>rollup</code>+<code>travis CI</code>+<code>semantic release</code>+<code>babel</code>，将本科阶段写的webGL封装库优化并且以npm仓库的形式发布，rollup比起webpack更适合打包第三方库</li><li>建立了一套<a href="https://github.com/luvsunlight/fjl-cli" target="_blank" rel="external">脚手架工具</a>，类似yeoman，用于快速生成代码模板，并且创建了两套模板，<a href="https://github.com/luvsunlight/oslib-template" target="_blank" rel="external">一套</a>用于快速生成js第三方库，基于rollup打包，<a href="https://github.com/luvsunlight/doc-template" target="_blank" rel="external">另一套</a>用于快速生成文档模板</li><li>维护了两个前端知识仓库，<a href="https://github.com/luvsunlight/front-end-cookbook" target="_blank" rel="external">前端知识手册</a>和<a href="https://github.com/luvsunlight/frontend-interview-archive" target="_blank" rel="external">前端面试手册</a>，可以说这两个仓库占据了我下半年的绝大部分精力，我意识到光会使用vue做项目根本算不上精通前端，也意识到一年前看的书如今再次回顾宛如新书，我决定以在线笔记的形式维护这两个大型的项目（第二个项目是在准备面经时创建的，主要还是第一个项目）</li></ul><p>看起来好像今年做了很多事，但其实难度都很浅，只是更高程度的CURD，这里单指项目方面，在知识学习方面还是汲取了很多的，尤其在js基础知识上认真巩固了一下。前面之所以说今年也是很不勤奋的一年，就是因为我本可以做更多更有趣更深入的事情，但是我贪图玩乐(?)，将很多时间浪费在了娱乐上，每次看到大神都会感到冷汗直冒，深感惭愧。明年将是转折的一年，我需要同时面临毕业和找工作的压力，希望新的一年我可以学习更多的知识，更好地巩固自己的能力</p><p>11月份的时候和机房的几个同学一起想要参加qq小程序比赛，这个时候的我自诩在前端方面做一个简单的业务开发还是问题不大的，再加上自己年初的时候有小程序的开发经验，在和小组成员头脑风暴一个晚上初步定下项目的方案后，就拍胸脯承诺下了全包此事（组队的除了我之外只有一个初级前端）。现在想想这可能是本科阶段我参加项目的后遗症，本科时我负责过很多项目都是我一个人承担，但万万没想到这样的工作模式一旦工作量大了就会带来巨大的隐患。真正接手这个项目才发现它的各种棘手之处，首先qq小程序平台开发体验极其极其极其恶心，要啥功能啥功能没有，我不明白都是一个公司的产品，该编辑器还在微信开发者工具之后，咋功能还反过来落后微信的几个档次呢？它连基本的emmet也没有，组件页面一键生成也没有，而且热更新的执行效率也非常差（估计是编译的问题），平时用vsc开发vue的程序，保存文件后1s之内html就发生了对应的更新，qq小程序开发工具将这个时间成功得延长了5-10倍，整个人像吃了屎一样的恶心，还不如手动刷新页面来得快。此外这个工具还有各式各样的bug，在pc端能够正常运行，一到真机调试就会出现问题。在这里可以剧透了，我们小组最终放弃了该比赛，而导致我们真正放弃比赛的原因还不是前面那些，而是小程序端和服务端的交互，在微信小程序开发中，它提供了免费的云开发，但是到qq这里，没门，不仅如此，它还要求你在短短一个月的时间里办好域名，服务器和相应的域名备案。而我们团队知晓这一点时，距离比赛结束的时间已经不足以备案了，再加上组内的几位小伙伴一点也不擅长此事，只得就此作罢。</p><p>以上这些是我们放弃比赛的客观原因，当然也是存在主观原因的，那就是我对一个产品的开发流程过于乐观和松懈了，尽管我之前已经了解了软件工程里的敏捷开发和瀑布模型等知识，但真正上手一个产品开发时还是硬着头皮一把梭，初步订好功能模块之后，也不设计原型，也不考虑各个模块的复杂程度和可实现度，代码写到哪就是哪，再加上我之前把开发的工作全都揽下了，产品UI和代码全部都是我一个人负责，我在开发完产品的二分之一部分时就感觉到了严重的力不从心，难度不大，但无奈要设计的部分实在太多了，全部工程交由一人负责实在困难。我本来指向安心地写代码，现在产品设计和UI还有代码架构的事全要负责，而且还要限时一个月之内完成，我着实感觉有些困难。</p><p>现在回过头来看这次比赛，还是能有不少收获和反省的</p><ul><li>对于在校生来说瀑布模型显得不够灵活，敏捷开发也太捉襟见肘，那么快速迭代模型显然是一个可以采取的方案</li><li>设计产品方案时，在讨论好产品定位和大概模块之后，也不要急着开写，可以细分模块，再做进一步的讨论</li><li>模块也要细分讨论，主要商议细节怎么处理，以及该模块可能的复杂度</li><li>PD和美工一起设计原型，然后再开会讨论，组内一致通过后，再可以开始前端页面的构建</li><li>代码方面至少要两个人，前后端分离，如果人员有空闲，最好再分一个人解决服务器，域名和备案这方面的配置准备</li><li>讨论方案时的复杂度可能和实际施工时的复杂度有出入，这个时候可以慢慢啃让这个模块成为程序中的亮点，也可以适当缩减模块的内容，让单位时间的产出比更高</li><li>一个人全揽活不适合大型开发除非你有异常充盈的知识储备和充足的时间</li><li>代码全部完成后要快速迭代，可以组内讨论也可以请人来测试，然后再按模块修改产品功能</li></ul><p>今年我比较满意的点是认真学习了数据结构，这让我在思考代码和平时的很多场景中都充满自信，还有认真学习了js的基础知识。事实证明任何时候学习编程的基本能力才能真正提升人的编程水准和自信。不满的地方在于项目过于单薄，明天争取做几个有挑战性的项目，让能力和水准上一层台阶</p><blockquote><p>2020计划</p></blockquote><p>技术方面</p><ul><li style="list-style: none"><input type="checkbox"> 初步完成深度学习入门，看完《深度学习入门》，并且做出知识整合</li><li style="list-style: none"><input type="checkbox"> 学习编译原理</li><li style="list-style: none"><input type="checkbox"> 学习ts，并且完成项目落地</li><li style="list-style: none"><input type="checkbox"> 学习node，基础的后端知识</li><li style="list-style: none"><input type="checkbox"> 学习react</li><li style="list-style: none"><input type="checkbox"> 学习Electron</li><li style="list-style: none"><input type="checkbox" checked> 重看红宝书（2遍）</li><li style="list-style: none"><input type="checkbox"> 项目<ul><li style="list-style: none"><input type="checkbox"> 重新维护vuelegant项目</li><li style="list-style: none"><input type="checkbox"> 重新维护js-archive-creator项目</li><li style="list-style: none"><input type="checkbox"> 实现一个简易版的vue</li><li style="list-style: none"><input type="checkbox"> 实现一个美团仿版</li><li style="list-style: none"><input type="checkbox"> 使用PWA重构vue-todo</li><li style="list-style: none"><input type="checkbox"> 做一个复杂一点的后台系统</li></ul></li><li style="list-style: none"><input type="checkbox"> 开启看源码计划<ul><li style="list-style: none"><input type="checkbox"> vue</li><li style="list-style: none"><input type="checkbox"> jquery</li><li style="list-style: none"><input type="checkbox"> ant-design-vue架构剖析</li></ul></li></ul><blockquote><p>生活方面</p></blockquote><ul><li style="list-style: none"><input type="checkbox"> 找到心仪的offer</li><li style="list-style: none"><input type="checkbox"> 初步学习制作音乐</li></ul><blockquote><p>结语</p></blockquote><p>这算是正儿八经的第一次年度总结和计划，以后这个版块我希望自己能越做越好，自己的博客也要慢慢</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年的年度总结&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>es6...运算符</title>
    <link href="http://yoursite.com/2019/10/23/es6-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/10/23/es6-运算符/</id>
    <published>2019-10-23T11:48:32.000Z</published>
    <updated>2020-03-10T13:23:51.940Z</updated>
    
    <content type="html"><![CDATA[<p>很多人可能看见三个点的运算符都不知道能干什么。我从最开始的不知道，到现在知道能用来展开数据，但是你知道它的具体含义和进阶用法吗</p><a id="more"></a><h1 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a>1. 基础用法</h1><ul><li>展开</li><li>收集</li><li>类数组转化为数组</li><li>增加元素或者属性</li><li>合并数组/对象</li></ul><p>官方定义 =&gt;</p><blockquote><p>Spread syntax allows an iterable, such as an array expression or string, to be expanded in places where 0 or more arguments or elements are expected or an object expression to be expanded in places where 0 or more key-value pairs (for object literals) are expected.</p></blockquote><p>就是说，这个运算符可以展开为一个可迭代对象中的所有项</p><h2 id="1-1-展开"><a href="#1-1-展开" class="headerlink" title="1.1 展开"></a>1.1 展开</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">const b = [<span class="number">1</span>, ...a, <span class="number">5</span>]</div><div class="line"></div><div class="line">b; <span class="comment">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure><h2 id="1-2-收集"><a href="#1-2-收集" class="headerlink" title="1.2 收集"></a>1.2 收集</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a, b, <span class="rest_arg">...c</span>)</span> </span>&#123;</div><div class="line">    console.log(a, b, c)     </div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 1, 2, [3, 4, 5]</span></div></pre></td></tr></table></figure><p>注意，这里的运算符一定要在最后一个参数的位置或者只有它一个参数</p><h2 id="1-3-类数组转化为数组"><a href="#1-3-类数组转化为数组" class="headerlink" title="1.3 类数组转化为数组"></a>1.3 类数组转化为数组</h2><blockquote><p>类数组，即和数组非常接近，都拥有一系列元素，也有length属性,也支持按下标访问，常见的如字符串，选择器返回的结果,arguments</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> nodeList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>);</div><div class="line"><span class="keyword">const</span> array = [...nodeList];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(nodeList); <span class="comment">//Result: HTMLCollection [ div.test, div.test ]</span></div><div class="line"><span class="built_in">console</span>.log(array); <span class="comment">//Result: Array [ div.test, div.test ]</span></div><div class="line"></div><div class="line"><span class="comment">// 在es5时代，我们需要</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</div></pre></td></tr></table></figure><h2 id="1-4-增加元素或者属性"><a href="#1-4-增加元素或者属性" class="headerlink" title="1.4 增加元素或者属性"></a>1.4 增加元素或者属性</h2><blockquote><p>给数组新增元素</p></blockquote><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> pokemon = [<span class="string">'KK'</span>, <span class="string">'Peter'</span>]<span class="comment">;</span></div><div class="line"><span class="keyword">const</span> charmander = <span class="string">'郑伊健'</span><span class="comment">;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> pokedex = [...pokemon, charmander]<span class="comment">;</span></div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(pokedex)<span class="comment">; </span></div><div class="line"></div><div class="line">//Result: [ <span class="string">'KK'</span>, <span class="string">'Peter'</span>, <span class="string">'郑伊健'</span> ]</div></pre></td></tr></table></figure><blockquote><p>给对象新增属性</p></blockquote><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> basicSquirtle = &#123; name: <span class="string">'Squirtle'</span>, type: <span class="string">'Water'</span> &#125;<span class="comment">;</span></div><div class="line"><span class="keyword">const</span> fullSquirtle = &#123;</div><div class="line">  ...basicSquirtle,</div><div class="line">  species: <span class="string">'Tiny Turtle'</span>,</div><div class="line">  evolution: <span class="string">'Wartortle'</span></div><div class="line">&#125;<span class="comment">;</span></div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(fullSquirtle)<span class="comment">; </span></div><div class="line"></div><div class="line">//Result: &#123; name: <span class="string">'Squirtle'</span>, type: <span class="string">'Water'</span>, species: <span class="string">'Tiny Turtle'</span>, evolution: <span class="string">'Wartortle'</span> &#125;</div></pre></td></tr></table></figure><h2 id="1-5-合并数组-对象"><a href="#1-5-合并数组-对象" class="headerlink" title="1.5 合并数组/对象"></a>1.5 合并数组/对象</h2><blockquote><p>合并数组</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const pokemon = <span class="meta">[</span><span class="string">'Squirtle'</span>, <span class="string">'Bulbasur'</span>, <span class="string">'Charmander'</span><span class="meta">]</span>;</div><div class="line">const morePokemon = <span class="meta">[</span><span class="string">'Totodile'</span>, <span class="string">'Chikorita'</span>, <span class="string">'Cyndaquil'</span><span class="meta">]</span>;</div><div class="line"></div><div class="line">const pokedex = <span class="meta">[</span><span class="params">...</span>pokemon, <span class="params">...</span>morePokemon<span class="meta">]</span>;</div><div class="line"></div><div class="line">console.log(pokedex); </div><div class="line">//Result: <span class="meta">[</span> <span class="string">'Squirtle'</span>, <span class="string">'Bulbasur'</span>, <span class="string">'Charmander'</span>, <span class="string">'Totodile'</span>, <span class="string">'Chikorita'</span>, <span class="string">'Cyndaquil'</span> <span class="meta">]</span></div><div class="line"></div><div class="line">// 对象数组也一样：</div><div class="line">const pokemon = <span class="meta">[</span></div><div class="line">  &#123; name: <span class="string">'Squirtle'</span>, <span class="keyword">type</span>: <span class="string">'Water'</span> &#125;,</div><div class="line">  &#123; name: <span class="string">'Bulbasur'</span>, <span class="keyword">type</span>: <span class="string">'Plant'</span> &#125;</div><div class="line"><span class="meta">]</span>;</div><div class="line">const morePokemon = <span class="meta">[</span>&#123; name: <span class="string">'Charmander'</span>, <span class="keyword">type</span>: <span class="string">'Fire'</span> &#125;<span class="meta">]</span>;</div><div class="line"></div><div class="line">const pokedex = <span class="meta">[</span><span class="params">...</span>pokemon, <span class="params">...</span>morePokemon<span class="meta">]</span>;</div><div class="line"></div><div class="line">console.log(pokedex); </div><div class="line"></div><div class="line">//Result: <span class="meta">[</span> &#123; name: <span class="string">'Squirtle'</span>, <span class="keyword">type</span>: <span class="string">'Water'</span> &#125;, &#123; name: <span class="string">'Bulbasur'</span>, <span class="keyword">type</span>: <span class="string">'Plant'</span> &#125;, &#123; name: <span class="string">'Charmander'</span>, <span class="keyword">type</span>: <span class="string">'Fire'</span> &#125; <span class="meta">]</span></div></pre></td></tr></table></figure><blockquote><p>合并对象</p></blockquote><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> baseSquirtle = &#123;</div><div class="line">  name: <span class="string">'Squirtle'</span>,</div><div class="line">  type: <span class="string">'Water'</span></div><div class="line">&#125;<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> squirtleDetails = &#123;</div><div class="line">  species: <span class="string">'Tiny Turtle Pokemon'</span>,</div><div class="line">  evolution: <span class="string">'Wartortle'</span></div><div class="line">&#125;<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> squirtle = &#123; ...baseSquirtle, ...squirtleDetails &#125;<span class="comment">;</span></div><div class="line">console.<span class="built_in">log</span>(squirtle)<span class="comment">; </span></div><div class="line">//Result: &#123; name: <span class="string">'Squirtle'</span>, type: <span class="string">'Water'</span>, species: <span class="string">'Tiny Turtle Pokemon'</span>, evolution: <span class="string">'Wartortle'</span> &#125;</div></pre></td></tr></table></figure><h1 id="2-进阶"><a href="#2-进阶" class="headerlink" title="2. 进阶"></a>2. 进阶</h1><ul><li>deepClone</li><li>增加条件属性</li></ul><h2 id="2-1-复制一个嵌套对象"><a href="#2-1-复制一个嵌套对象" class="headerlink" title="2.1 复制一个嵌套对象"></a>2.1 复制一个嵌套对象</h2><p>修改克隆对象的属性时，原对象属性不变。但是原对象如果有数组或者对象类型的属性，这些属性变化时，克隆对象属性改变。因为复制过来的对象是一个引用类型</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> pokemon = &#123;</div><div class="line">  name: <span class="string">'Squirtle'</span>,</div><div class="line">  type: <span class="string">'Water'</span>,</div><div class="line">  abilities: [<span class="string">'Torrent'</span>, <span class="string">'Rain Dish'</span>]</div><div class="line">&#125;<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> squirtleClone = &#123; ...pokemon &#125;<span class="comment">;</span></div><div class="line"></div><div class="line">pokemon.name = <span class="string">'Charmander'</span><span class="comment">;</span></div><div class="line">pokemon.abilities.push(<span class="string">'Surf'</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(squirtleClone)<span class="comment">; </span></div><div class="line"></div><div class="line">//Result: &#123; name: <span class="string">'Squirtle'</span>, type: <span class="string">'Water'</span>, abilities: [ <span class="string">'Torrent'</span>, <span class="string">'Rain Dish'</span>, <span class="string">'Surf'</span> ]</div></pre></td></tr></table></figure><p>解决方法也很简单</p><p>复制引用类型的数据/deepClone</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> pokemon = &#123;</div><div class="line">  name: <span class="string">'Squirtle'</span>,</div><div class="line">  type: <span class="string">'Water'</span>,</div><div class="line">  abilities: [<span class="string">'Torrent'</span>, <span class="string">'Rain Dish'</span>]</div><div class="line">&#125;<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> squirtleClone = &#123; ...pokemon, abilities: [...pokemon.abilities] &#125;<span class="comment">;</span></div><div class="line"></div><div class="line">pokemon.name = <span class="string">'Charmander'</span><span class="comment">;</span></div><div class="line">pokemon.abilities.push(<span class="string">'Surf'</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(squirtleClone)<span class="comment">;</span></div><div class="line"></div><div class="line">//Result: &#123; name: <span class="string">'Squirtle'</span>, type: <span class="string">'Water'</span>, abilities: [ <span class="string">'Torrent'</span>, <span class="string">'Rain Dish'</span> ] &#125;</div></pre></td></tr></table></figure><h2 id="2-2-增加条件属性"><a href="#2-2-增加条件属性" class="headerlink" title="2.2 增加条件属性"></a>2.2 增加条件属性</h2><p>实际上就是新增属性的延伸</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> pokemon = &#123;</div><div class="line">  name: <span class="string">'Squirtle'</span>,</div><div class="line">  type: <span class="string">'Water'</span></div><div class="line">&#125;<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> abilities = [<span class="string">'Torrent'</span>, <span class="string">'Rain dish'</span>]<span class="comment">;</span></div><div class="line"><span class="keyword">const</span> fullPokemon = abilities ? &#123; ...pokemon, abilities &#125; : pokemon<span class="comment">;</span></div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(fullPokemon)<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="literal">or</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> fullPokemon = &#123;</div><div class="line">  ...pokemon,</div><div class="line">  ...(abilities &amp;&amp; &#123; abilities &#125;)</div><div class="line">&#125;<span class="comment">;</span></div></pre></td></tr></table></figure><h1 id="3-Refer"><a href="#3-Refer" class="headerlink" title="3. Refer"></a>3. Refer</h1><p><a href="https://mp.weixin.qq.com/s/HSyYrqfjYYh35ctpbnjrNA" target="_blank" rel="external">深入了解es6强大的…运算符</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人可能看见三个点的运算符都不知道能干什么。我从最开始的不知道，到现在知道能用来展开数据，但是你知道它的具体含义和进阶用法吗&lt;/p&gt;
    
    </summary>
    
      <category term="技术细节" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
      <category term="知识" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>超实用的文档管理工具DASH</title>
    <link href="http://yoursite.com/2019/10/16/%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7DASH/"/>
    <id>http://yoursite.com/2019/10/16/超实用的文档管理工具DASH/</id>
    <published>2019-10-16T02:14:53.000Z</published>
    <updated>2019-10-16T02:35:13.531Z</updated>
    
    <content type="html"><![CDATA[<p>一般人管理文档的方式可能是需要的时候就去查，更仔细一点的可能是在chrome建个书签文件夹专门用来整理遇到的api文档网站，那么有没有更为可靠的软件可以帮我们做到这一点呢?</p><a id="more"></a><p><a href="https://kapeli.com/dash" target="_blank" rel="external">DASH</a></p><p>Dash is an API Documentation Browser and Code Snippet Manager. Dash stores snippets of code and instantly searches offline documentation sets for 200+ APIs, 100+ cheat sheets and more. You can even generate your own docsets or request docsets to be included.</p><h1 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h1><h3 id="1-海量文档"><a href="#1-海量文档" class="headerlink" title="1. 海量文档"></a>1. 海量文档</h3><p>DASH上有海量的文档，几乎包含了所以你可能接触到的语言或者工具</p><h3 id="2-文档可离线"><a href="#2-文档可离线" class="headerlink" title="2. 文档可离线"></a>2. 文档可离线</h3><p>我们可以将文档下载下来，这样离线也是可以查询的</p><h3 id="3-内置google和Stackoverflow"><a href="#3-内置google和Stackoverflow" class="headerlink" title="3. 内置google和Stackoverflow"></a>3. 内置google和Stackoverflow</h3><p>在搜索api的同时也会自行搜索stackoverflow上的相关问题提供给你，非常方便</p><h3 id="4-支持自定义snippet"><a href="#4-支持自定义snippet" class="headerlink" title="4. 支持自定义snippet"></a>4. 支持自定义snippet</h3><p>有了它，你就可以有了一个无限量（只要你电脑内存空间够）的snippet管理平台，并且支持高亮，缩紧，搜索，用起来非常非常方便.而且snippet还支持按标签分类，真的谁用谁知道</p><h3 id="5-与其他平台的集成"><a href="#5-与其他平台的集成" class="headerlink" title="5. 与其他平台的集成"></a>5. 与其他平台的集成</h3><p>DASH可以和很多很多平台集成，这里举我最常用的两个</p><h4 id="5-1-Alfred"><a href="#5-1-Alfred" class="headerlink" title="5.1 Alfred"></a>5.1 Alfred</h4><p>直接 dash + 关键字即可</p><h4 id="5-2-VSC"><a href="#5-2-VSC" class="headerlink" title="5.2 VSC"></a>5.2 VSC</h4><p>首先在插件商店搜索DASH，下载对应插件，然后在代码页面选中单词，输入control+h，即可打开dash并且在dash中搜索响应api</p><h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><p>dash还有很多很多功能，总的来说是一个非常高效的提高开发体验的工具，极其推荐使用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般人管理文档的方式可能是需要的时候就去查，更仔细一点的可能是在chrome建个书签文件夹专门用来整理遇到的api文档网站，那么有没有更为可靠的软件可以帮我们做到这一点呢?&lt;/p&gt;
    
    </summary>
    
      <category term="技术细节" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    
    
  </entry>
  
  <entry>
    <title>DIY Vue UI组件库之路</title>
    <link href="http://yoursite.com/2019/05/31/DIY-Vue-UI%E7%BB%84%E4%BB%B6%E5%BA%93%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/05/31/DIY-Vue-UI组件库之路/</id>
    <published>2019-05-31T14:24:01.000Z</published>
    <updated>2019-06-02T11:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写vue的项目多了，感觉越来越需要自己从头开始写一个UI组件库来系统地升华自己的能力</p></blockquote><a id="more"></a><h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><ul><li>vue</li><li>vuex</li><li>vueRouter</li><li>less</li></ul><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>首先使用vue-cli3.x来构建项目，因为是特别正式的项目，不是平时的业务开发，所以加入了单测和eslinit</p><h2 id="测试了下npm发布包的功能"><a href="#测试了下npm发布包的功能" class="headerlink" title="测试了下npm发布包的功能"></a>测试了下npm发布包的功能</h2><p>首先在npm官网注册账号，然后在本地项目文件夹下<code>npm login</code>,然后<code>npm publish --access public</code></p><p>注意npm的淘宝源是不行的，最好是使用<code>nrm</code>来管理npm源。常用操作<code>nrm ls</code>，<code>nrm use ***</code></p><h2 id="新建examples文件夹"><a href="#新建examples文件夹" class="headerlink" title="新建examples文件夹"></a>新建examples文件夹</h2><p>做组件库跟业务开发不一样，它主要的文件全部用来放库，展示页面应该另起一个文件夹，在根目录下新建examples文件夹，并且加入<code>main.js</code>,<code>app.vue</code>,<code>index.html</code></p><p>之前习惯的事用vuecli2.x，但是毕竟3.x才是潮流，这次还是用了3.x</p><p>在<code>package.json</code>里配置serve的属性， 将原来的serve改为<code>&quot;serve&quot;: &quot;vue-cli-service serve --open ./examples/main.js&quot;,</code>，这样就指定了新的入口文件，测试一下，ok</p><h2 id="文档的编写"><a href="#文档的编写" class="headerlink" title="文档的编写"></a>文档的编写</h2><p>直接采用<a href="https://github.com/docsifyjs/docsify" target="_blank" rel="external">docsify</a></p><p>配置挺复杂的，折腾了一天</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写vue的项目多了，感觉越来越需要自己从头开始写一个UI组件库来系统地升华自己的能力&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>zIndex为什么会无效</title>
    <link href="http://yoursite.com/2019/05/31/zIndex%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%97%A0%E6%95%88/"/>
    <id>http://yoursite.com/2019/05/31/zIndex为什么会无效/</id>
    <published>2019-05-31T14:24:01.000Z</published>
    <updated>2019-09-09T14:31:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做项目的过程中遇到了这样的问题，即z-index为什么会有时候没有效果？</p><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们首先来看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index" target="_blank" rel="external">MDN</a>里，z-index是怎么描述的</p><blockquote><p>z-index 属性指定了一个具有定位属性的元素及其子代元素的 z-order。 当元素之间重叠的时候，z-order 决定哪一个元素覆盖在其余元素的上方显示。 通常来说 z-index 较大的元素会覆盖较小的一个。</p><p>对于一个已经定位的元素（即position属性值不是static的元素），z-index 属性指定：</p><p>元素在当前堆叠上下文中的堆叠层级。<br>元素是否创建一个新的本地堆叠上下文</p></blockquote><p>z-index 可以取值<code>auto</code>或者数字（auto会互相层叠，但是只要指定正的z-index，就会比auto高）</p><p>需要注意的是z-index需要是对有<code>position</code>不为<code>static</code>属性的元素才做效的</p><h1 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h1><ul><li>该标签无<code>position</code>属性</li><li>该标签父元素是relative（IE6）</li><li>该标签为浮动元素（IE6）</li></ul><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>添加position标签</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做项目的过程中遇到了这样的问题，即z-index为什么会有时候没有效果？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自定义vue-cli脚手架</title>
    <link href="http://yoursite.com/2019/03/25/%E8%87%AA%E5%AE%9A%E4%B9%89vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/03/25/自定义vue-cli脚手架/</id>
    <published>2019-03-25T05:48:13.000Z</published>
    <updated>2019-03-25T05:58:33.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为最近写了很多的vue小工程练手，但是越来越发现vuecli的webpack模板不够用了，每次重新构建的时候都需要花很多心思，花了一天的时间来研究和使用vuecli的自定义构建，非常好用</p></blockquote><a id="more"></a><h1 id="Fork一份标准库"><a href="#Fork一份标准库" class="headerlink" title="Fork一份标准库"></a>Fork一份标准库</h1><p>去<a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">vue-webpack模板</a>的标准库下fork一份，并且创建一份自己的分支</p><h1 id="在本地进行修改"><a href="#在本地进行修改" class="headerlink" title="在本地进行修改"></a>在本地进行修改</h1><p>将fork的项目clone到本地，进行修改</p><p>具体的步骤和解释参考<a href="https://segmentfault.com/a/1190000012074462" target="_blank" rel="external">这个文章</a></p><p>我只讲一下我做了哪些改动</p><h2 id="1-打开config-index-js中的autoOpenBrowser"><a href="#1-打开config-index-js中的autoOpenBrowser" class="headerlink" title="1 打开config/index.js中的autoOpenBrowser"></a>1 打开<code>config/index.js</code>中的autoOpenBrowser</h2><h2 id="2-editorConfig中调整indent-size为4，并且将其风格改为tab"><a href="#2-editorConfig中调整indent-size为4，并且将其风格改为tab" class="headerlink" title="2 .editorConfig中调整indent_size为4，并且将其风格改为tab"></a>2 <code>.editorConfig</code>中调整<code>indent_size</code>为4，并且将其风格改为tab</h2><h2 id="3-增加-vuex版块"><a href="#3-增加-vuex版块" class="headerlink" title="3 增加 vuex版块"></a>3 增加 <code>vuex</code>版块</h2><h2 id="4-增加mock和api版块"><a href="#4-增加mock和api版块" class="headerlink" title="4 增加mock和api版块"></a>4 增加mock和api版块</h2><h2 id="5-增加page版块"><a href="#5-增加page版块" class="headerlink" title="5 增加page版块"></a>5 增加page版块</h2><h2 id="6-增加less"><a href="#6-增加less" class="headerlink" title="6 增加less"></a>6 增加less</h2><h2 id="7-增加common文件夹，并且写了一些公共样式"><a href="#7-增加common文件夹，并且写了一些公共样式" class="headerlink" title="7 增加common文件夹，并且写了一些公共样式"></a>7 增加common文件夹，并且写了一些公共样式</h2><h2 id="8-增加less的全局变量"><a href="#8-增加less的全局变量" class="headerlink" title="8 增加less的全局变量"></a>8 增加less的全局变量</h2><p>参考<a href="https://blog.csdn.net/hani_wen/article/details/81007852" target="_blank" rel="external">这篇文章</a></p><blockquote><p>注意，增加的全部变量只能引用一个less文件，不能在这个文件里引用其他的文件</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因为最近写了很多的vue小工程练手，但是越来越发现vuecli的webpack模板不够用了，每次重新构建的时候都需要花很多心思，花了一天的时间来研究和使用vuecli的自定义构建，非常好用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术细节" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年新计划</title>
    <link href="http://yoursite.com/2019/02/18/2019%E5%B9%B4%E6%96%B0%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2019/02/18/2019年新计划/</id>
    <published>2019-02-18T02:49:33.000Z</published>
    <updated>2019-02-18T03:08:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>新的一年已经开始了，去年做的还不够好，新的一年在技术上还是应该多抓紧一些</p></blockquote><a id="more"></a><h1 id="1-研究生生活"><a href="#1-研究生生活" class="headerlink" title="1.研究生生活"></a>1.研究生生活</h1><ul><li>下个学期每天认真看论文，还有自己写论文，主题暂定为动物迁徙，主要是去认真看一些有意思的话题</li><li>公众号完善一下</li></ul><h1 id="2-生活方面"><a href="#2-生活方面" class="headerlink" title="2.生活方面"></a>2.生活方面</h1><ul><li>去蹭日语课，今年要达到日语N3的水平</li><li>上公开课（苏德超，赵林，周玄毅）</li><li>健身</li><li>学会基础的摄影</li><li>有闲暇的时间就去看书</li></ul><h1 id="3-编程方面"><a href="#3-编程方面" class="headerlink" title="3.编程方面"></a>3.编程方面</h1><ul><li>学习node的教程</li><li>看自己之前买的几本书，并且开始做笔记</li><li>微信的开发</li><li>极客时间上的教程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;新的一年已经开始了，去年做的还不够好，新的一年在技术上还是应该多抓紧一些&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js类型详解</title>
    <link href="http://yoursite.com/2018/09/29/js%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/09/29/js类型详解/</id>
    <published>2018-09-29T11:23:41.000Z</published>
    <updated>2018-09-29T14:33:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>js的类型实际上是一个基本问题，但它总能在一些小的细节上给人困扰，这次就一口气把这个问题好好解决了</p><a id="more"></a><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="external">阮一峰的教程</a></li><li><a href="http://www.cnblogs.com/qiantuwuliang/archive/2010/01/12/1645302.html" target="_blank" rel="external">一个博客</a></li></ul><h1 id="js类型详解"><a href="#js类型详解" class="headerlink" title="js类型详解"></a>js类型详解</h1><blockquote><p>js分为基本类型和引用类型</p></blockquote><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型一共5种</p><h3 id="1-Undefined"><a href="#1-Undefined" class="headerlink" title="1.Undefined"></a>1.Undefined</h3><blockquote><p>使用var声明变量时，如果没有对其赋值就引用它就会产生undefined值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a</div><div class="line"></div><div class="line">a <span class="comment">// -&gt; undefined</span></div><div class="line"></div><div class="line">a == <span class="literal">undefined</span> <span class="comment">// -&gt; true</span></div><div class="line"></div><div class="line">c === <span class="literal">undefined</span> <span class="comment">// -&gt; true</span></div></pre></td></tr></table></figure><h3 id="2-Null"><a href="#2-Null" class="headerlink" title="2.Null"></a>2.Null</h3><blockquote><p>从逻辑上说，null值表示一个空对象指针，这也正是使用typeof来检测null会返回object的原因</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">null</span>)) <span class="comment">// -&gt; 'object'</span></div></pre></td></tr></table></figure><h3 id="3-boolean"><a href="#3-boolean" class="headerlink" title="3.boolean"></a>3.boolean</h3><h3 id="4-number"><a href="#4-number" class="headerlink" title="4.number"></a>4.number</h3><h3 id="5-string"><a href="#5-string" class="headerlink" title="5.string"></a>5.string</h3><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h3><h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h3><h3 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h3><h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h3><h3 id="Symbol类型（es6新加）"><a href="#Symbol类型（es6新加）" class="headerlink" title="Symbol类型（es6新加）"></a>Symbol类型（es6新加）</h3><h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><blockquote><p>ECMAScript提供了3种特殊的引用类型 Boolean，Number，String.也就是是它们三个实际上都是function的实例罢辽</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="string">"a"</span></div><div class="line"><span class="keyword">let</span> b = <span class="built_in">String</span>(<span class="string">"a"</span>)</div><div class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"a"</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a)) <span class="comment">// -&gt; "string"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(b)) <span class="comment">// -&gt; "string"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(c)) <span class="comment">// -&gt; "object"</span></div></pre></td></tr></table></figure><h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><h2 id="1-NaN的类型"><a href="#1-NaN的类型" class="headerlink" title="1.NaN的类型"></a>1.NaN的类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">NaN</span>))</div><div class="line"><span class="comment">// -&gt; 'number'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>)</div><div class="line"><span class="comment">// -&gt; false</span></div></pre></td></tr></table></figure><h3 id="2-Undefined和Null"><a href="#2-Undefined和Null" class="headerlink" title="2.Undefined和Null"></a>2.Undefined和Null</h3><blockquote><p>null表示此处不该有值，undefined表示此处应该有值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">null</span>)</div><div class="line"><span class="comment">// -&gt; true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="literal">null</span>)</div><div class="line"><span class="comment">// -&gt; false</span></div></pre></td></tr></table></figure><h3 id="3-和-的区别"><a href="#3-和-的区别" class="headerlink" title="3.== 和 === 的区别"></a>3.== 和 === 的区别</h3><blockquote><p>Show code</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">100</span> == <span class="string">"100"</span> <span class="comment">// -&gt; true</span></div><div class="line"><span class="number">100</span> === <span class="string">"100"</span> <span class="comment">// -&gt; false</span></div></pre></td></tr></table></figure><h4 id="3-1-判断规则"><a href="#3-1-判断规则" class="headerlink" title="3.1 === 判断规则"></a>3.1 === 判断规则</h4><p>首先要等号两边类型相同，然后才是值相同</p><h4 id="3-2-判断规则"><a href="#3-2-判断规则" class="headerlink" title="3.2 == 判断规则"></a>3.2 == 判断规则</h4><ul><li>如果两边存在boolean，string，number任意两者进行比较，优先转化为数字</li><li>null == undefined</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js的类型实际上是一个基本问题，但它总能在一些小的细节上给人困扰，这次就一口气把这个问题好好解决了&lt;/p&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2018/09/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/29/设计模式/</id>
    <published>2018-09-29T09:25:31.000Z</published>
    <updated>2018-09-29T11:16:37.641Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设计模式始终是一个巨大的话题，总是要涉及，干脆写一篇博客来进行总结那些常见的设计模式</p></blockquote><a id="more"></a><h1 id="构建函数模式"><a href="#构建函数模式" class="headerlink" title="构建函数模式"></a>构建函数模式</h1><blockquote><p>在es6中，这种模式和原型模式统一了，都是很好的设计模式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, gender, score) &#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">      <span class="keyword">this</span>.gender = gender;</div><div class="line">      <span class="keyword">this</span>.score = score;</div><div class="line">      <span class="keyword">this</span>.quality = <span class="number">100</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sumScore() &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.score + <span class="keyword">this</span>.quality;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> whh = <span class="keyword">new</span> Student(<span class="string">'王花花'</span>, <span class="string">'男'</span>, <span class="number">89</span>);</div><div class="line">  <span class="keyword">var</span> lsd = <span class="keyword">new</span> Student(<span class="string">'李拴蛋'</span>, <span class="string">'女'</span>, <span class="number">40</span>);</div><div class="line"></div><div class="line">  whh.score = <span class="number">100</span>;</div><div class="line">  <span class="built_in">console</span>.log(whh.name, whh.sumScore())</div><div class="line">  <span class="built_in">console</span>.log(lsd.name, lsd.sumScore())</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, gender, score) &#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">      <span class="keyword">this</span>.gender = gender;</div><div class="line">      <span class="keyword">this</span>.score = score;</div><div class="line">      <span class="keyword">this</span>.quality = <span class="number">100</span>;</div><div class="line"></div><div class="line">      <span class="keyword">this</span>.mount();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mount() &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h1 id="构建者模式"><a href="#构建者模式" class="headerlink" title="构建者模式"></a>构建者模式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> studentCount = <span class="number">0</span>;</div><div class="line"></div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">StudentBuilder</span> </span>&#123;</div><div class="line">   <span class="keyword">constructor</span>() &#123;</div><div class="line">     <span class="keyword">this</span>.student = <span class="keyword">new</span> Student();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   setName(name) &#123;</div><div class="line">     <span class="keyword">this</span>.student.name = name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   setGender(gender) &#123;</div><div class="line">     <span class="keyword">if</span> (gender != <span class="string">'男'</span> &amp;&amp; gender != <span class="string">'女'</span>)</div><div class="line">       <span class="keyword">throw</span> <span class="string">'好玩不'</span>;</div><div class="line"></div><div class="line">     <span class="keyword">this</span>.student.gender = gender;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   setHairLength(hairLength) &#123;</div><div class="line">     <span class="keyword">if</span> (</div><div class="line">       (<span class="keyword">this</span>.student.gender == <span class="string">'男'</span> &amp;&amp; hairLength &gt; <span class="number">1</span>) ||</div><div class="line">       (<span class="keyword">this</span>.student.gender == <span class="string">'女'</span> &amp;&amp; hairLength &gt; <span class="number">25</span>)</div><div class="line">     ) <span class="keyword">throw</span> <span class="string">'回去剪头'</span>;</div><div class="line"></div><div class="line">     <span class="keyword">this</span>.student.hairLength = hairLength;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   build() &#123;</div><div class="line">     studentCount++;</div><div class="line">     <span class="built_in">console</span>.log(studentCount);</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.student;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">const</span> builder = <span class="keyword">new</span> StudentBuilder();</div><div class="line"> builder.setName(<span class="string">'王花花'</span>);</div><div class="line"> builder.setGender(<span class="string">'男'</span>);</div><div class="line"> builder.setHairLength(<span class="number">1</span>);</div><div class="line"> <span class="keyword">const</span> whh = builder.build();</div><div class="line"></div><div class="line"> <span class="keyword">const</span> builder2 = <span class="keyword">new</span> StudentBuilder();</div><div class="line"> builder2.setName(<span class="string">'李拴蛋'</span>);</div><div class="line"> builder2.setGender(<span class="string">'女'</span>);</div><div class="line"> builder2.setHairLength(<span class="number">20</span>);</div><div class="line"> <span class="keyword">const</span> lsd = builder2.build();</div><div class="line"></div><div class="line"> <span class="built_in">console</span>.log(lsd);</div></pre></td></tr></table></figure><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><blockquote><p>工厂模式的特点就是使用<strong>函数</strong>来封装特定接口的细节.它虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, subjects) &#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">      <span class="comment">// ...</span></div><div class="line"></div><div class="line">      <span class="comment">// 如果是文科生：['政治', '历史', '地理']</span></div><div class="line">      <span class="comment">// 如果是文科生：['数学', '物理', '化学']</span></div><div class="line">      <span class="keyword">this</span>.subjects = subjects;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">factory</span>(<span class="params">name, type</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'文科'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, [<span class="string">'政治'</span>, <span class="string">'历史'</span>, <span class="string">'地理'</span>])</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'理科'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, [<span class="string">'数学'</span>, <span class="string">'物理'</span>, <span class="string">'化学'</span>])</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'体育'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, [<span class="string">'长跑'</span>, <span class="string">'...'</span>])</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">throw</span> <span class="string">'没有这个专业，别瞎填'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> whh = factory(<span class="string">'王花花'</span>, <span class="string">'文科'</span>);</div><div class="line">  <span class="keyword">const</span> lsd = factory(<span class="string">'李拴蛋'</span>, <span class="string">'理科'</span>);</div><div class="line">  <span class="keyword">const</span> zks = factory(<span class="string">'赵可爽'</span>, <span class="string">'体育'</span>);</div><div class="line">  <span class="keyword">const</span> lbb = factory(<span class="string">'刘备备'</span>, <span class="string">'撒盐'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(whh);</div><div class="line">  <span class="built_in">console</span>.log(lsd);</div><div class="line">  <span class="built_in">console</span>.log(zks);</div></pre></td></tr></table></figure><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote><p>单例模式最突出的特点就是这个类只有一个实例，并且提供一个全局访问他的接口  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span> () &#123;</div><div class="line">    <span class="comment">// 如果不是第一次new（instance肯定是存在的）</span></div><div class="line">    <span class="keyword">if</span> (Resource.instance)</div><div class="line">      <span class="keyword">return</span> Resource.instance;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 否则（instance不存在）</span></div><div class="line">      <span class="comment">// 组装新对象</span></div><div class="line">      <span class="keyword">this</span>.balance = <span class="number">100</span>;</div><div class="line"></div><div class="line">      <span class="comment">// 将其存到Resource机器上</span></div><div class="line">      Resource.instance = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> r = <span class="keyword">new</span> Resource();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'r:'</span>, r);</div><div class="line">r.balance = <span class="number">50</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'r:'</span>, r);</div><div class="line"></div><div class="line"><span class="keyword">const</span> r2 = <span class="keyword">new</span> Resource();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'r2:'</span>, r2);</div><div class="line"></div><div class="line">r.balance = <span class="number">55</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'r2:'</span>, r2);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计模式始终是一个巨大的话题，总是要涉及，干脆写一篇博客来进行总结那些常见的设计模式&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>npm使用指南</title>
    <link href="http://yoursite.com/2018/09/27/npm%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/09/27/npm使用指南/</id>
    <published>2018-09-27T13:16:08.000Z</published>
    <updated>2018-10-05T02:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>只要你做前端，就必定躲不开npm这个工具。这篇文章总结了npm的入门和对应的指令<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="npm是什么？"><a href="#npm是什么？" class="headerlink" title="npm是什么？"></a>npm是什么？</h2><p>要说npm是什么，首先要说<a href="http://nodejs.cn/" target="_blank" rel="external">node</a>是什么。</p><blockquote><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p></blockquote><p>处于安全性等方面的考虑，原本只能存在于浏览器环境的js存在诸多限制比如IO操作，或者是读取本地文件，nodejs的存在，让js可以在系统环境下运行，这大大提升了js的发挥空间</p><p>npm（node package manager）顾名思义即node的包管理工具</p><blockquote><p>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。<br>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p></blockquote><h1 id="npm-指令"><a href="#npm-指令" class="headerlink" title="npm 指令"></a>npm 指令</h1><p>注：</p><blockquote><p>在npm中，包（package）、模块（module）、依赖（dependency）说的都是一回事儿。</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>npm init</code> 初始化项目，其实就是创建一个package.json文件。</li><li><code>npm install</code> 安装所有项目依赖。</li><li><code>npm help xxx</code> 查看xxx命令的帮助信息。</li></ul><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><ul><li><code>npm -g install npm</code></li></ul><h2 id="设置npm配置"><a href="#设置npm配置" class="headerlink" title="设置npm配置"></a>设置npm配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config set &lt;key&gt; <span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span> [–global]</span></div></pre></td></tr></table></figure><h3 id="查看npm配置"><a href="#查看npm配置" class="headerlink" title="查看npm配置"></a>查看npm配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config ls</div></pre></td></tr></table></figure><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config set proxy=http:<span class="comment">//xx.xx.xx.xx:8080</span></div></pre></td></tr></table></figure><h3 id="设置npm的镜像源"><a href="#设置npm的镜像源" class="headerlink" title="设置npm的镜像源"></a>设置npm的镜像源</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config set registry https:<span class="comment">//registry.npm.taobao.org</span></div></pre></td></tr></table></figure><h2 id="发布项目到npm"><a href="#发布项目到npm" class="headerlink" title="发布项目到npm"></a>发布项目到npm</h2><p>1.在官网注册npm账号</p><p>2.用户验证，命令行执行</p><blockquote><p>npm adduser</p></blockquote><p>3.发布模块，在模块的根文件夹执行</p><blockquote><p>npm publish</p></blockquote><p>4.更新版本</p><blockquote><p>如果是git库时，会为新版本号创建一条提交信息，package版本号会自动递增。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm version <span class="number">0.0</span><span class="number">.4</span></div><div class="line">npm publish</div></pre></td></tr></table></figure><h2 id="npm-search-搜索（快捷方式：find-s）"><a href="#npm-search-搜索（快捷方式：find-s）" class="headerlink" title="npm search 搜索（快捷方式：find, s）"></a>npm search 搜索（快捷方式：find, s）</h2><ul><li><code>xxx</code> 搜索xxx 如：npm search jquery。</li></ul><h2 id="npm-install-安装-（快捷方式：i）"><a href="#npm-install-安装-（快捷方式：i）" class="headerlink" title="npm install 安装 （快捷方式：i）"></a>npm install 安装 （快捷方式：i）</h2><ul><li>xxx 搜索并安装xxx（局部）。安装多个依赖可用空格分割，如npm i jquery bootstrap。</li><li>xxx -g 搜索并安装xxx（全局）。安装多个同上。</li><li>xxx -D 安装并将依赖信息写在package.json中的devDependencies中。</li><li>快捷方式 i均可，如npm i jquery。</li><li>xxx@版本号 指定需要安装的版本号，若不指定将安装最新的稳定版本。</li></ul><h2 id="npm-uninstall-卸载（快捷方式：rm-r）"><a href="#npm-uninstall-卸载（快捷方式：rm-r）" class="headerlink" title="npm uninstall 卸载（快捷方式：rm, r）"></a>npm uninstall 卸载（快捷方式：rm, r）</h2><ul><li>xxx 卸载xxx。多个依赖可用空格分割。</li><li>xxx -D 卸载xxx，并将依赖信息从package.json中的devDependencies中清除。</li></ul><h2 id="npm-list-列出已安装依赖（快捷方式：ls）"><a href="#npm-list-列出已安装依赖（快捷方式：ls）" class="headerlink" title="npm list 列出已安装依赖（快捷方式：ls）"></a>npm list 列出已安装依赖（快捷方式：ls）</h2><ul><li>默认列出局部依赖。</li><li>npm list -g 列出已安装的全局依赖。</li></ul><h2 id="npm-outdated-检查过期依赖"><a href="#npm-outdated-检查过期依赖" class="headerlink" title="npm outdated 检查过期依赖"></a>npm outdated 检查过期依赖</h2><h2 id="npm-update-更新依赖（快捷方式：up）"><a href="#npm-update-更新依赖（快捷方式：up）" class="headerlink" title="npm update 更新依赖（快捷方式：up）"></a>npm update 更新依赖（快捷方式：up）</h2><ul><li>xxx 局部更新xxx。</li><li>xxx -g 全局更新xxx。</li></ul><h2 id="npm-root-查看依赖安装路径（也就是node-modules的路径）"><a href="#npm-root-查看依赖安装路径（也就是node-modules的路径）" class="headerlink" title="npm root 查看依赖安装路径（也就是node_modules的路径）"></a>npm root 查看依赖安装路径（也就是node_modules的路径）</h2><ul><li>默认查看局部安装路径。</li><li>-g 查看全局安装路径。</li></ul><h2 id="npm-view-查看模块的注册信息"><a href="#npm-view-查看模块的注册信息" class="headerlink" title="npm view 查看模块的注册信息"></a>npm view 查看模块的注册信息</h2><ul><li>xxx versions 列出xxx的所有版本， 如：npm view jquery versions。</li><li>xxx dependencies 列出xxx的所有依赖， 如：npm view gulp dependencies。</li></ul><h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><blockquote><p>npm run <em>*</em></p></blockquote><h1 id="nvm-指令"><a href="#nvm-指令" class="headerlink" title="nvm 指令"></a>nvm 指令</h1><h2 id="nvm是什么"><a href="#nvm是什么" class="headerlink" title="nvm是什么"></a>nvm是什么</h2><blockquote><p>在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。</p></blockquote><p>nvm 应运而生，nvm 是 Mac 下的 node 管理工具，有点类似管理 Ruby 的 rvm，如果需要管理 Windows 下的 node，官方推荐使用 nvmw 或 nvm-windows。不过，nvm-windows 并不是 nvm 的简单移植，他们也没有任何关系。但下面介绍的所有命令，都可以在 nvm-windows 中运行。</p><h2 id="安装多版本的node-npm"><a href="#安装多版本的node-npm" class="headerlink" title="安装多版本的node/npm"></a>安装多版本的node/npm</h2><p>例如，我们要安装4.2.2版本，可以用如下命令：</p><blockquote><p>nvm install 4.2.2</p></blockquote><p>nvm 遵守语义化版本命名规则。例如，你想安装最新的 4.2 系列的最新的一个版本的话，可以运行：</p><blockquote><p>nvm install 4.2</p></blockquote><p>nvm 会寻找 4.2.x 中最高的版本来安装。</p><p>你可以通过以下命令来列出远程服务器上所有的可用版本：</p><blockquote><p>nvm ls-remote</p></blockquote><h2 id="在多个版本中个切换"><a href="#在多个版本中个切换" class="headerlink" title="在多个版本中个切换"></a>在多个版本中个切换</h2><p>每当我们安装了一个新版本 Node 后，全局环境会自动把这个新版本设置为默认。</p><p>nvm 提供了 nvm use 命令。这个命令的使用方法和 install 命令类似。</p><p>例如，切换到 4.2.2：</p><blockquote><p>nvm use 4.2.2</p></blockquote><h2 id="列出已安装实例"><a href="#列出已安装实例" class="headerlink" title="列出已安装实例"></a>列出已安装实例</h2><blockquote><p>nvm ls</p></blockquote><h2 id="在项目中使用不同版本的-Node"><a href="#在项目中使用不同版本的-Node" class="headerlink" title="在项目中使用不同版本的 Node"></a>在项目中使用不同版本的 Node</h2><p>我们可以通过创建项目目录中的 .nvmrc 文件来指定要使用的 Node 版本。之后在项目目录中执行 nvm use 即可。.nvmrc 文件内容只需要遵守上文提到的语义化版本规则即可。另外还有个工具叫做 avn，可以自动化这个过程。</p><h2 id="在多环境中，npm该如何使用呢？"><a href="#在多环境中，npm该如何使用呢？" class="headerlink" title="在多环境中，npm该如何使用呢？"></a>在多环境中，npm该如何使用呢？</h2><p>每个版本的 Node 都会自带一个不同版本的 npm，可以用 npm -v 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 <code>~/.nvm/versions/node/&lt;version&gt;/lib/node_modules&lt;/version&gt;</code> 这样的目录。这刚好也省去我们在 Linux 中使用 sudo 的功夫了。因为这是用户的主文件夹，并不会引起权限问题。</p><p>但问题来了，我们安装过的 npm 包，都要重新再装一次？幸运的是，我们有个办法来解决我们的问题，运行下面这个命令，可以从特定版本导入到我们将要安装的新版本 Node：</p><blockquote><p>nvm install v5.0.0 –reinstall-packages-from=4.2</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只要你做前端，就必定躲不开npm这个工具。这篇文章总结了npm的入门和对应的指令&lt;br&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>ES6和ES7全面入门</title>
    <link href="http://yoursite.com/2018/09/26/ES5%E5%92%8CES6%E5%85%A8%E9%9D%A2%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/26/ES5和ES6全面入门/</id>
    <published>2018-09-26T14:22:17.000Z</published>
    <updated>2018-10-06T02:27:22.666Z</updated>
    
    <content type="html"><![CDATA[<p>ES2015（ES6）和ES2016(ES7)的知识总结<br><a id="more"></a></p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><p>本篇博客的大部分内容和案例均来源于互联网，因为自己也算不上权威就暂时没有这个必要</p><h2 id="1-2-参考资料"><a href="#1-2-参考资料" class="headerlink" title="1.2 参考资料"></a>1.2 参考资料</h2><ul><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰的es6入门</a></li><li><a href="https://www.jianshu.com/p/76dbe1cd5732" target="_blank" rel="external">一篇简书教程</a></li><li><a href="https://babeljs.io/docs/en/learn" target="_blank" rel="external">babel的教程</a></li><li><a href="https://gank.io/post/564151c1f1df1210001c9161" target="_blank" rel="external">一篇特别良心的es6入门到实战的教程</a></li></ul><h1 id="2-ES6"><a href="#2-ES6" class="headerlink" title="2.ES6"></a>2.ES6</h1><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><h2 id="ECMAScript-和-JavaScript-的关系"><a href="#ECMAScript-和-JavaScript-的关系" class="headerlink" title="ECMAScript 和 JavaScript 的关系"></a>ECMAScript 和 JavaScript 的关系</h2><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p><p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p><p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p><p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p><h2 id="let、const"><a href="#let、const" class="headerlink" title="let、const"></a>let、const</h2><p>在 ES2015 的新语法中，影响速度最为直接，范围最大的，恐怕得数 let 和 const 了，它们是继 var 之后，新的变量定义方法。与 let 相比，const 更容易被理解：const 也就是 constant 的缩写，跟 C/C++ 等经典语言一样，用于定义常量，即不可变量。</p><p>但由于在 ES6 之前的 ECMAScript 标准中，并没有原生的实现，所以在降级编译中，会马上进行引用检查，然后使用 var 代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// foo.js</span></div><div class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span></div><div class="line"></div><div class="line">foo = <span class="string">'newvalue'</span></div></pre></td></tr></table></figure><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>在 ES6 诞生之前，我们在给 JavaScript 新手解答困惑时，经常会提到一个观点：</p><blockquote><p>JavaScript 没有块级作用域</p></blockquote><p>在 ES6 诞生之前的时代中，JavaScript 确实是没有块级作用域的。这个问题之所以为人所熟知，是因为它引发了诸如历遍监听事件需要使用闭包解决等问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;button&gt;一&lt;<span class="regexp">/button&gt;</span></div><div class="line"><span class="regexp">&lt;button&gt;二&lt;/</span>button&gt;</div><div class="line">&lt;button&gt;三&lt;<span class="regexp">/button&gt;</span></div><div class="line"><span class="regexp">&lt;button&gt;四&lt;/</span>button&gt;</div><div class="line"></div><div class="line">&lt;div id=<span class="string">"output"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">  <span class="keyword">var</span> buttons = <span class="built_in">document</span>.querySelectorAll(<span class="string">'button'</span>)</div><div class="line">  <span class="keyword">var</span> output = <span class="built_in">document</span>.querySelector(<span class="string">'#output'</span>)</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</div><div class="line">    buttons[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      output.innerText = buttons[i].innerText</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure><p>前端新手非常容易写出类似的代码，因为从直观的角度看这段代码并没有语义上的错误，但是当我们点击任意一个按钮时，就会报出这样的错误信息：</p><p><code>Uncaught TypeError: Cannot read property &#39;innerText&#39; of undefined</code></p><p>出现这个错误的原因是因为 buttons[i] 不存在，即为 undefined。</p><p>为什么会出现按钮不存在结果呢？通过排查，我们可以发现，每次我们点击按钮时，事件监听回调函数中得到的变量 i 都会等于 buttons.length，也就是这里的 4。而 buttons[4] 恰恰不存在，所以导致了错误的发生。</p><p>再而导致 i 得到的值都是 buttons.length 的原因就是因为 JavaScript 中没有块级作用域，而使对 i 的变量引用(Reference)一直保持在上一层作用域（循环语句所在层）上，而当循环结束时 i 则正好是 buttons.length。</p><p>而在 ES6 中，<strong>我们只需做出一个小小的改动</strong>，便可以解决该问题（假设所使用的浏览器已经支持所需要的特性）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">for</span> (<span class="comment">/* var */</span> <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure><p>通过把 for 语句中对计数器 i 的定义语句从 var 换成 let，即可。因为 let 语句会使该变量处于一个块级作用域中，从而让事件监听回调函数中的变量引用得到保持。我们不妨看看改进后的代码经过 babel 的编译会变成什么样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">var</span> _loop = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</div><div class="line">  buttons[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    output.innerText = buttons[i].innerText</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</div><div class="line">  _loop(i)</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure><p>实现方法一目了然，通过传值的方法防止了 i 的值错误。</p><h2 id="箭头函数-Arrow-Function"><a href="#箭头函数-Arrow-Function" class="headerlink" title="箭头函数(Arrow Function)"></a>箭头函数(Arrow Function)</h2><p>继 let 和 const 之后，箭头函数就是使用率最高的新特性了。当然了，如果你了解过 Scala 或者曾经如日中天的 JavaScript 衍生语言 CoffeeScript，就会知道箭头函数并非 ES6 独创。</p><p>箭头函数，顾名思义便是使用箭头(=&gt;)进行定义的函数，属于匿名函数（Lambda）一类。当然了，也可以作为定义式函数使用，但我们并不推荐这样做，随后会详细解释。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>箭头函数有好几种使用语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">foo =&gt; foo + <span class="string">' world'</span> <span class="comment">// means return `foo + ' world'`</span></div><div class="line"></div><div class="line">(foo, bar) =&gt; foo + bar</div><div class="line"></div><div class="line">foo =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> foo + <span class="string">' world'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">(foo, bar) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> foo + bar</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上都是被支持的箭头函数表达方式，其最大的好处便是简洁明了，省略了 function 关键字，而使用 =&gt; 代替。</p><p>箭头函数语言简洁的特点使其特别适合用於单行回调函数的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> names = [ <span class="string">'Will'</span>, <span class="string">'Jack'</span>, <span class="string">'Peter'</span>, <span class="string">'Steve'</span>, <span class="string">'John'</span>, <span class="string">'Hugo'</span>, <span class="string">'Mike'</span> ]</div><div class="line"></div><div class="line"><span class="keyword">let</span> newSet = names</div><div class="line">  .map(<span class="function">(<span class="params">name, index</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      id: index,</div><div class="line">      name: name</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  .filter(<span class="function"><span class="params">man</span> =&gt;</span> man.id % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">  .map(<span class="function"><span class="params">man</span> =&gt;</span> [man.name])</div><div class="line">  .reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(b))</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(newSet) <span class="comment">//=&gt; [ 'Will', 'Peter', 'John', 'Mike' ]</span></div></pre></td></tr></table></figure><h3 id="箭头函数与上下文绑定"><a href="#箭头函数与上下文绑定" class="headerlink" title="箭头函数与上下文绑定"></a>箭头函数与上下文绑定</h3><p>事实上，箭头函数在 ES2015 标准中，并不只是作为一种新的语法出现。就如同它在 CoffeeScript 中的定义一般，是用于对函数内部的上下文 （this）绑定为定义函数所在的作用域的上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  hello: <span class="string">'world'</span>,</div><div class="line">  foo() &#123;</div><div class="line">    <span class="keyword">let</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.hello</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bar</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.hello = <span class="string">'ES6'</span></div><div class="line"><span class="built_in">window</span>.bar = obj.foo()</div><div class="line"><span class="built_in">window</span>.bar() <span class="comment">//=&gt; 'world'</span></div></pre></td></tr></table></figure><p>上面代码中的 obj.foo 等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">foo() &#123;</div><div class="line">  <span class="keyword">let</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hello</div><div class="line">  &#125;).bind(<span class="keyword">this</span>)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> bar</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>另外，要注意的是，箭头函数对上下文的绑定是强制性的，无法通过 apply 或 call 方法改变其上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  init() &#123;</div><div class="line">    <span class="keyword">this</span>.bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.dam</div><div class="line">  &#125;,</div><div class="line">  dam: <span class="string">'hei'</span>,</div><div class="line">  foo() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dam</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> b = &#123;</div><div class="line">  dam: <span class="string">'ha'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">a.init()</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a.foo()) <span class="comment">//=&gt; hei</span></div><div class="line"><span class="built_in">console</span>.log(a.foo.bind(b).call(a)) <span class="comment">//=&gt; ha</span></div><div class="line"><span class="built_in">console</span>.log(a.bar.call(b)) <span class="comment">//=&gt; hei</span></div></pre></td></tr></table></figure><p>另外，因为箭头函数会绑定上下文的特性，故不能随意在顶层作用域使用箭头函数，以防出错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设当前运行环境为浏览器，故顶层作上下文为 `window`</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  msg: <span class="string">'pong'</span>,</div><div class="line"></div><div class="line">  ping: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.msg <span class="comment">// Warning!</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.ping() <span class="comment">//=&gt; undefined</span></div><div class="line"><span class="keyword">let</span> msg = <span class="string">'bang!'</span></div><div class="line">obj.ping() <span class="comment">//=&gt; bang!</span></div></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串模板出现简直对 Node.js 应用的开发和 Node.js 自身的发展起到了相当大的推动作用！我的意思并不是说这个原生的模板字符串能代替现有的模板引擎，而是说它的出现可以让非常多的字符串使用变得尤为轻松。</p><p>模板字符串要求使用 ` 代替原本的单/双引号来包裹字符串内容。它有两大特点：</p><ol><li>支持变量注入</li><li>支持换行</li></ol><h3 id="支持变量注入-useful"><a href="#支持变量注入-useful" class="headerlink" title="支持变量注入(useful)"></a>支持变量注入(useful)</h3><p>模板字符串之所以称之为“模板”，就是因为它允许我们在字符串中引用外部变量，而不需要像以往需要不断地相加、相加、相加……</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'Will Wen Gunn'</span></div><div class="line"><span class="keyword">let</span> title = <span class="string">'Founder'</span></div><div class="line"><span class="keyword">let</span> company = <span class="string">'LikMoon Creation'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> greet = <span class="string">`Hi, I'm <span class="subst">$&#123;name&#125;</span>, I am the <span class="subst">$&#123;title&#125;</span> at <span class="subst">$&#123;company&#125;</span>`</span></div><div class="line"><span class="built_in">console</span>.log(greet) <span class="comment">//=&gt; Hi, I'm Will Wen Gunn, I am the Founder at LikMoon Creation</span></div></pre></td></tr></table></figure><h3 id="支持换行"><a href="#支持换行" class="headerlink" title="支持换行"></a>支持换行</h3><p>无论是上面的哪一种，都会让我们感到很不爽。但若使用模板字符串，仿佛打开了新世界的大门~</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sql = <span class="string">`</span></div><div class="line"><span class="string">SELECT * FROM Users</span></div><div class="line"><span class="string">WHERE FirstName='Mike'</span></div><div class="line"><span class="string">LIMIT 5;</span></div><div class="line"><span class="string">`</span></div></pre></td></tr></table></figure><h2 id="对象字面量扩展语法"><a href="#对象字面量扩展语法" class="headerlink" title="对象字面量扩展语法"></a>对象字面量扩展语法</h2><p>(本质上还是语法糖，但是挺爽的)</p><h3 id="方法属性省略-function-useful"><a href="#方法属性省略-function-useful" class="headerlink" title="方法属性省略 function (useful)"></a>方法属性省略 function (useful)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="comment">// before</span></div><div class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'foo'</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// after</span></div><div class="line">  bar() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'bar'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="同名方法属性省略语法"><a href="#同名方法属性省略语法" class="headerlink" title="同名方法属性省略语法"></a>同名方法属性省略语法</h3><p>也是看上去有点鸡肋的新特性，不过在做 JavaScript 模块化工程的时候则有了用武之地。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// module.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  someMethod</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">someMethod</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">import</span> Module <span class="keyword">from</span> <span class="string">'./module'</span></div><div class="line"></div><div class="line">Module.someMethod()</div></pre></td></tr></table></figure><h3 id="可以动态计算的属性名称"><a href="#可以动态计算的属性名称" class="headerlink" title="可以动态计算的属性名称"></a>可以动态计算的属性名称</h3><p>这个特性相当有意思，也是可以用在一些特殊的场景中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">let</span> outArr = arr.map(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    [ n ]: n,</div><div class="line">    [ <span class="string">`<span class="subst">$&#123;n&#125;</span>^2`</span> ]: <span class="built_in">Math</span>.pow(n, <span class="number">2</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.dir(outArr) <span class="comment">//=&gt;</span></div><div class="line">  [</div><div class="line">    &#123; <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'1^2'</span>: <span class="number">1</span> &#125;,</div><div class="line">    &#123; <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'2^2'</span>: <span class="number">4</span> &#125;,</div><div class="line">    &#123; <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'3^2'</span>: <span class="number">9</span> &#125;</div><div class="line">  ]</div></pre></td></tr></table></figure><h3 id="表达式解构-useful"><a href="#表达式解构-useful" class="headerlink" title="表达式解构(useful)"></a>表达式解构(useful)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Matching with object</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">query</span>) </span>&#123;</div><div class="line">  <span class="comment">/* 交换变量 */</span></div><div class="line">  [x, y] = [y, x];</div><div class="line"></div><div class="line">  <span class="comment">/* 从函数返回多个值 */</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    foo: <span class="number">1</span>,</div><div class="line">    bar: <span class="number">2</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">  <span class="keyword">let</span> &#123; foo, bar &#125; = example();</div><div class="line"></div><div class="line">  <span class="comment">/* 函数参数的定义 */</span></div><div class="line">  <span class="comment">// 参数是一组有次序的值</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class="line">  f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line">  <span class="comment">// 参数是一组无次序的值</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class="line">  f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* 提取json数据 */</span></div><div class="line">  <span class="keyword">let</span> jsonData = &#123;</div><div class="line">    id: <span class="number">42</span>,</div><div class="line">    status: <span class="string">"OK"</span>,</div><div class="line">    data: [<span class="number">867</span>, <span class="number">5309</span>]</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</div><div class="line"></div><div class="line">  <span class="comment">/* 函数参数的默认 */</span></div><div class="line">  jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></div><div class="line"><span class="function"><span class="params">    async = true,</span></span></div><div class="line"><span class="function"><span class="params">    beforeSend = function (</span>) </span>&#123;&#125;,</div><div class="line">    cache = <span class="literal">true</span>,</div><div class="line">    complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">    crossDomain = <span class="literal">false</span>,</div><div class="line">    global = <span class="literal">true</span>,</div><div class="line">    <span class="comment">// ... more config</span></div><div class="line">  &#125; = &#123;&#125;) &#123;</div><div class="line">    <span class="comment">// ... do stuff</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/* 导入模块 */</span></div><div class="line">  <span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</div></pre></td></tr></table></figure><h2 id="函数参数表达、传参"><a href="#函数参数表达、传参" class="headerlink" title="函数参数表达、传参"></a>函数参数表达、传参</h2><p>这个特性有非常高的使用频率，一个简单的语法糖解决了从前需要一两行代码才能实现的功能。</p><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>这个特性在类库开发中相当有用，比如实现一些可选参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span></div><div class="line"><span class="keyword">import</span> readline <span class="keyword">from</span> <span class="string">'readline'</span></div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLineInFile</span>(<span class="params">filename, callback = noop, complete = noop</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> rl = readline.createInterface(&#123;</div><div class="line">    input: fs.createReadStream(path.resolve(__dirname, filename))</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  rl.on(<span class="string">'line'</span>, line =&gt; &#123;</div><div class="line">    <span class="comment">//... do something with the current line</span></div><div class="line">    callback(line)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  rl.on(<span class="string">'close'</span>, complete)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> rl</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</div><div class="line"></div><div class="line">readLineInFile(<span class="string">'big_file.txt'</span>, line =&gt; &#123;</div><div class="line">  <span class="comment">// ...</span></div></pre></td></tr></table></figure><h3 id="后续参数"><a href="#后续参数" class="headerlink" title="后续参数"></a>后续参数</h3><p>我们知道，函数的 call 和 apply 在使用上的最大差异便是一个在首参数后传入各个参数，一个是在首参数后传入一个包含所有参数的数组。如果我们在实现某些函数或方法时，也希望实现像 call 一样的使用方法，在 ES2015 之前，我们可能需要这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchSomethings</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = [].slice.apply(<span class="built_in">arguments</span>)</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeOthers</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = [].slice.apply(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而在 ES2015 中，我们可以很简单的使用 … 语法糖来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchSomethings</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeOthers</span>(<span class="params">name, ...args</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>要注意的是，…args 后不可再添加</p><p>虽然从语言角度看，arguments 和 …args 是可以同时使用 ，但有一个特殊情况则不可：arguments 在箭头函数中，会跟随上下文绑定到上层，所以在不确定上下文绑定结果的情况下，尽可能不要再箭头函数中再使用 arguments，而使用 …args。</p><p>虽然 ECMA 委员会和各类编译器都无强制性要求用 …args 代替 arguments，但从实践经验看来，…args 确实可以在绝大部份场景下可以代替 arguments 使用，除非你有很特殊的场景需要使用到 arguments.callee 和 arguments.caller。所以我推荐都使用 …args 而非 arguments。</p><p>PS：在严格模式（Strict Mode）中，arguments.callee 和 arguments.caller 是被禁止使用的。</p><h3 id="解构传参"><a href="#解构传参" class="headerlink" title="解构传参"></a>解构传参</h3><p>在 ES2015 中，… 语法还有另外一个功能：无上下文绑定的 apply。什么意思？看看代码你就知道了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> args.map(<span class="built_in">Number</span>)</div><div class="line">    .reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sum(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">//=&gt; 6</span></div></pre></td></tr></table></figure><p>有什么卵用？我也不知道(⊙o⊙)… Sorry…</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>默认参数值</code>和<code>后续参数</code>需要遵循顺序原则，否则会出错。<br><code>function(...args, last = 1) {  // This will go wrong}</code></p><h2 id="新的数据结构"><a href="#新的数据结构" class="headerlink" title="新的数据结构"></a>新的数据结构</h2><p>在介绍新的数据结构之前，我们先复习一下在 ES2015 之前，JavaScript 中有哪些基本的数据结构。</p><ul><li>String 字符串</li><li>Number 数字（包含整型和浮点型）</li><li>Boolean 布尔值</li><li>Object 对象</li><li>Array 数组</li></ul><p>其中又分为<code>值类型</code>和<code>引用类型</code>，Array 其实是 Object 的一种子类。</p><h3 id="Set-和-WeakSet"><a href="#Set-和-WeakSet" class="headerlink" title="Set 和 WeakSet"></a>Set 和 WeakSet</h3><p>我们再来复习下高中数学吧，集不能包含相同的元素，我们可以根据元素画出多个集的韦恩图…………</p><p>好了跑题了。是的，在 ES2015 中，ECMA 委员会为 ECMAScript 增添了集(Set)和“弱”集(WeakSet)。它们都具有元素唯一性，若添加了已存在的元素，会被自动忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</div><div class="line">s.add(<span class="string">'hello'</span>).add(<span class="string">'world'</span>).add(<span class="string">'hello'</span>)</div><div class="line"><span class="built_in">console</span>.log(s.size) <span class="comment">//=&gt; 2</span></div><div class="line"><span class="built_in">console</span>.log(s.has(<span class="string">'hello'</span>)) <span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure><p>在实际开发中，我们有很多需要用到集的场景，如搜索、索引建立等。</p><p>WeakSet 在 JavaScript 底层作出调整（在非降级兼容的情况下），检查元素的变量引用情况。如果元素的引用已被全部解除，则该元素就会被删除，以节省内存空间。这意味著无法直接加入数字或者字符串。另外 WeakSet 对元素有严格要求，必须是 Object，当然了，你也可以用 new String(‘…’) 等形式处理元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> weaks = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</div><div class="line">weaks.add(<span class="string">"hello"</span>) <span class="comment">//=&gt; Error</span></div><div class="line">weaks.add(<span class="number">3.1415</span>) <span class="comment">//=&gt; Error</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"bar"</span>)</div><div class="line"><span class="keyword">let</span> pi = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3.1415</span>)</div><div class="line">weaks.add(foo)</div><div class="line">weaks.add(pi)</div><div class="line">weaks.has(foo) <span class="comment">//=&gt; true</span></div><div class="line">foo = <span class="literal">null</span></div><div class="line">weaks.has(foo) <span class="comment">//=&gt; false</span></div></pre></td></tr></table></figure><h3 id="Map-和-WeakMap"><a href="#Map-和-WeakMap" class="headerlink" title="Map 和 WeakMap"></a>Map 和 WeakMap</h3><p>从数据结构的角度来说，映射（Map）跟原本的 Object 非常相似，都是 Key/Value 的键值对结构。但是 Object 有一个让人非常不爽的限制：key 必须是字符串或数字。在一般情况下，我们并不会遇上这一限制，但若我们需要建立一个对象映射表时，这一限制显得尤为棘手。</p><p>而 Map 则解决了这一问题，可以使用任何对象作为其 key，这可以实现从前不能实现或难以实现的功能，如在项目逻辑层实现数据索引等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</div><div class="line"><span class="keyword">let</span> object = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</div><div class="line"></div><div class="line">map.set(object, <span class="string">'hello'</span>)</div><div class="line">map.set(<span class="string">'hello'</span>, <span class="string">'world'</span>)</div><div class="line">map.has(object) <span class="comment">//=&gt; true</span></div><div class="line">map.get(object) <span class="comment">//=&gt; hello</span></div></pre></td></tr></table></figure><p>而 WeakMap 和 WeakSet 很类似，只不过 WeakMap 的键和值都会检查变量引用，只要其一的引用全被解除，该键值对就会被删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> weakm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</div><div class="line"><span class="keyword">let</span> keyObject = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</div><div class="line"><span class="keyword">let</span> valObject = &#123; <span class="attr">score</span>: <span class="number">100</span> &#125;</div><div class="line"></div><div class="line">weakm.set(keyObject, valObject)</div><div class="line">weakm.get(keyObject) <span class="comment">//=&gt; &#123; score: 100 &#125;</span></div><div class="line">keyObject = <span class="literal">null</span></div><div class="line">weakm.has(keyObject) <span class="comment">//=&gt; false</span></div></pre></td></tr></table></figure><h2 id="类-Classes"><a href="#类-Classes" class="headerlink" title="类(Classes)"></a>类(Classes)</h2><p>类，作为自 JavaScript 诞生以来最大的痛点之一，终于在 ES2015 中得到了官方的妥协，“实现”了 ECMAScript 中的标准类机制。为什么是带有双引号的呢？因为我们不难发现这样一个现象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</div><div class="line">[<span class="built_in">Function</span>: Foo]</div></pre></td></tr></table></figure><p>回想一下在 ES2015 以前的时代中，我们是怎么在 JavaScript 中实现类的？<br><code>function Foo() {}var foo = new Foo()</code></p><p>是的，ES6 中的类只是一种语法糖，用于定义原型(Prototype)的。当然，饿死的厨师三百斤，有总比没有强，我们还是很欣然地接受了这一设定。</p><h3 id="遗憾与期望"><a href="#遗憾与期望" class="headerlink" title="遗憾与期望"></a>遗憾与期望</h3><p>就目前来说，ES2015 的类机制依然很鸡肋：</p><ol><li>不支持私有属性（private）</li><li>不支持前置属性定义，但可用 get 语句和 set 语句实现</li><li>不支持多重继承</li></ol><p>没有类似于协议（Protocl）或接口（Interface）等的概念<br>中肯地说，ES2015 的类机制依然有待加强。但总的来说，是值得尝试和讨论的，我们可以像从前一样，不断尝试新的方法，促进 ECMAScript 标准的发展。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise，作为一个老生常谈的话题，早已被聪明的工程师们“玩坏”了。</p><p>光是 Promise 自身，目前就有多种标准，而目前最为流行的是 Promises/A+。而 ES2015 中的 Promise 便是基于 Promises/A+ 制定的。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Promise 是一种用于解决回调函数无限嵌套的工具（当然，这只是其中一种），其字面意义为“保证”。它的作用便是“免去”异步操作的回调函数，保证能通过后续监听而得到返回值，或对错误处理。它能使异步操作变得井然有序，也更好控制。我们以在浏览器中访问一个 API，解析返回的 JSON 数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'http://example.com/api/users/top'</span>)</div><div class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    vm.data.topUsers = data</div><div class="line">  &#125;)</div><div class="line">  <span class="comment">// Handle the error crash in the chaining processes</span></div><div class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</div></pre></td></tr></table></figure><p>Promise 在设计上具有原子性，即只有两种状态：未开始和结束（无论成功与否都算是结束），这让我们在调用支持 Promise 的异步方法时，逻辑将变得非常简单，这在大规模的软件工程开发中具有良好的健壮性。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="创建-Promise-对象"><a href="#创建-Promise-对象" class="headerlink" title="创建 Promise 对象"></a>创建 Promise 对象</h4><p>要为一个函数赋予 Promise 的能力，先要创建一个 Promise 对象，并将其作为函数值返回。Promise 构造函数要求传入一个函数，并带有 resolve 和 reject 参数。这是两个用于结束 Promise 等待的函数，对应的成功和失败。而我们的逻辑代码就在这个函数中进行。</p><p>此处，因为必须要让这个函数包裹逻辑代码，所以如果需要用到 this 时，则需要使用箭头函数或者在前面做一个 this 的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="进行异步操作"><a href="#进行异步操作" class="headerlink" title="进行异步操作"></a>进行异步操作</h4><p>事实上，在异步操作内，并不需要对 Promise 对象进行操作（除非有特殊需求）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    api.call(<span class="string">'fetch_data'</span>, (err, data) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err)</div><div class="line"></div><div class="line">      resolve(data)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为在 Promise 定义的过程中，也会出现数层回调嵌套的情况，如果需要使用 this 的话，便显现出了箭头函数的优势了。</p><h4 id="使用-Promise"><a href="#使用-Promise" class="headerlink" title="使用 Promise"></a>使用 Promise</h4><p>让异步操作函数支持 Promise 后，我们就可以享受 Promise 带来的优雅和便捷了~</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fetchData()</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> storeInFileSystem(data)</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> renderUIAnimated(data)</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</div></pre></td></tr></table></figure><h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>虽说 Promise 确实很优雅，但是这是在所有需要用到的异步方法都支持 Promise 且遵循标准。而且链式 Promise 强制性要求逻辑必须是线性单向的，一旦出现如并行、回溯等情况，Promise 便显得十分累赘。</p><p>所以在目前的最佳实践中，Promise 会作为一种接口定义方法，而不是逻辑处理工具。后文将会详细阐述这种最佳实践。</p><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol 是一种很有意思的概念，它跟 Swift 中的 Selector 有点相像，但也更特别。在 JavaScript 中，对象的属性名称可以是字符串或数字。而如今又多了一个 Symbol。那 Symbol 究竟有什么用？</p><p>首先，我们要了解的是，Symbol 对象是具有唯一性的，也就是说，每一个 Symbol 对象都是唯一的，即便我们看不到它的区别在哪里。这就意味著，我们可以用它来保证一些数据的安全性。<br><code>console.log(Symbol(&#39;key&#39;) == Symbol(&#39;key&#39;)) //=&gt; false</code></p><p>如果将一个 Symbol 隐藏于一个封闭的作用域内，并作为一个对象中某属性的键，则外层作用域中便无法取得该属性的值，有效保障了某些私有库的代码安全性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> privateDataStore = &#123;</div><div class="line">  set(val) &#123;</div><div class="line">    <span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="built_in">Math</span>.random().toString(<span class="number">32</span>).substr(<span class="number">2</span>))</div><div class="line">    <span class="keyword">this</span>[key] = val</div><div class="line"></div><div class="line">    <span class="keyword">return</span> key</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  get(key) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[key]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> key = privateDateStore(<span class="string">'hello world'</span>)</div><div class="line">privateDataStore[key] <span class="comment">//=&gt; undefined</span></div><div class="line">privateDataStore.get(key) <span class="comment">//=&gt; hello world</span></div></pre></td></tr></table></figure><h2 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy(代理)"></a>Proxy(代理)</h2><p>Proxy 是 ECMAScript 中的一种新概念，它有很多好玩的用途，从基本的作用说就是：Proxy 可以在不入侵目标对象的情况下，对逻辑行为进行拦截和处理。</p><p>比如说我想记录下我代码中某些接口的使用情况，以供数据分析所用，但是因为目标代码中是严格控制的，所以不能对其进行修改，而另外写一个对象来对目标对象做代理也很麻烦。那么 Proxy 便可以提供一种比较简单的方法来实现这一需求。</p><blockquote><p>注意，要使得代理起作用，必须对proxy对象操作而不是原对象</p></blockquote><p>假设我要对 api 这一对象进行拦截并记录下代码行为，我就可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> apiProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;</div><div class="line">  get(receiver, name) &#123;</div><div class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">      min.sadd(<span class="string">`log:<span class="subst">$&#123;name&#125;</span>`</span>, args)</div><div class="line">      <span class="keyword">return</span> receiver[name].apply(receiver, args)</div><div class="line">    &#125;).bind(receiver)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">api.getComments(artical.id)</div><div class="line">  .then(<span class="function"><span class="params">comments</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;)</div></pre></td></tr></table></figure><h1 id="3-ES7"><a href="#3-ES7" class="headerlink" title="3.ES7"></a>3.ES7</h1><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>上文中我们提及到 co 是一个利用 Generator 模拟 ES7 中 async/await 特性的工具，那么，这个 async/await 究竟又是什么呢？它跟 co 又有什么区别呢？</p><p>我们知道，Generator Function 与普通的 Function 在执行方式上有著本质的区别，在某种意义上是无法共同使用的。但是，对于 ES7 的 Async Function 来说，这一点并不存在！它可以以普通函数的执行方式使用，并且有著 Generator Function 的异步优越性，它甚至可以作为事件响应函数使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(<span class="string">'/api/fetch/data'</span>)</div><div class="line">  <span class="keyword">let</span> reply = <span class="keyword">await</span> res.json()</div><div class="line"></div><div class="line">  <span class="keyword">return</span> reply</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> reply = fetchData() <span class="comment">//=&gt; DATA...</span></div></pre></td></tr></table></figure><h2 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a>Decorators</h2><p>对于 JavaScript 开发者来说，Decorators 又是一种新的概念，不过它在 Python 等语言中早已被玩出各种花式。</p><p>Decorator 的定义如下：</p><ul><li>是一个表达式</li><li>Decorator 会调用一个对应的函数</li><li>调用的函数中可以包含 target（装饰的目标对象）、name（装饰目标的名称）和 descriptor（描述器）三个参数</li><li>调用的函数可以返回一个新的描述器以应用到装饰目标对象上</li></ul><p>PS：如果你不记得 descriptor 是什么的话，请回顾一下 Object.defineProperty() 方法。</p><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>我们在实现一个类的时候，有的属性并不想被 for..in 或 Object.keys() 等方法检索到，那么在 ES5 时代，我们会用到 Object.defineProperty() 方法来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  foo: <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'bar'</span>, &#123;</div><div class="line">  enumerable: <span class="literal">false</span>,</div><div class="line">  value: <span class="number">2</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj.bar) <span class="comment">//=&gt; 2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> keys = []</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj)</div><div class="line">  keys.push(key)</div><div class="line"><span class="built_in">console</span>.log(keys) <span class="comment">//=&gt; [ 'foo' ]</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)) <span class="comment">//=&gt; [ 'foo' ]</span></div></pre></td></tr></table></figure><p>那么在 ES7 中，我们可以用 Decorator 来很简单地实现这个需求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.foo = <span class="number">1</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @nonenumerable</div><div class="line">  get bar() &#123; <span class="keyword">return</span> <span class="number">2</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonenumerable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</div><div class="line">  descriptor.enumerable = <span class="literal">false</span></div><div class="line">  <span class="keyword">return</span> descriptor</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obj()</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj.foo) <span class="comment">//=&gt; 1</span></div><div class="line"><span class="built_in">console</span>.log(obj.bar) <span class="comment">//=&gt; 2</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)) <span class="comment">//=&gt; [ 'foo' ]</span></div></pre></td></tr></table></figure><h2 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h2><blockquote><p>修饰器是一个对类进行处理的函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</div><div class="line">    target.isTestable = isTestable;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@testable(<span class="literal">true</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</div><div class="line">MyTestableClass.isTestable <span class="comment">// true</span></div><div class="line"></div><div class="line">@testable(<span class="literal">false</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</div><div class="line">MyClass.isTestable <span class="comment">// false</span></div></pre></td></tr></table></figure><h3 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h3><p>正如上面所说，Decorator 在编程中早已不是什么新东西，特别是在 Python 中早已被玩出各种花样。聪明的工程师们看到 ES7 的支持当然不会就此收手，就让我们看看我们还能用 Decorator 做点什么神奇的事情。</p><p>假如我们要实现一个类似于 Koa 和 PHP 中的 CI 的框架，且利用 Decorator 特性实现 URL 路由，我们可以这样做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 框架内部</span></div><div class="line"><span class="comment">// 控制器</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> handlers = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</div><div class="line"><span class="keyword">var</span> urls = &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义控制器</span></div><div class="line">@route(<span class="string">'/'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.msg = <span class="string">'World'</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">async</span> GET(ctx) &#123;</div><div class="line">    ctx.body = <span class="string">`Hello <span class="subst">$&#123;<span class="keyword">this</span>.msg&#125;</span>`</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Router Decorator</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">target</span> =&gt;</span> &#123;</div><div class="line">    target.url = url</div><div class="line">    <span class="keyword">let</span> urlObject = <span class="keyword">new</span> <span class="built_in">String</span>(url)</div><div class="line">    urls[url] = urlObject</div><div class="line"></div><div class="line">    handlers.set(urlObject, target)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 路由执行部份</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">router</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (urls[url]) &#123;</div><div class="line">    <span class="keyword">var</span> handlerClass = handlers.get(urls[url])</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> handlerClass()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> handler = router(<span class="string">'/'</span>)</div><div class="line"><span class="keyword">if</span> (handler) &#123;</div><div class="line">  <span class="keyword">let</span> context = &#123;&#125;</div><div class="line">  handler.GET(context)</div><div class="line">  <span class="built_in">console</span>.log(context.body)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最重要的是，同一个修饰对象是可以同时使用多个修饰器的，所以说我们还可以用修饰器实现很多很多有意思的功能。</p><h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><h2 id="let取代var"><a href="#let取代var" class="headerlink" title="let取代var"></a>let取代var</h2><blockquote><p>let和var作用相似，而且let没有副作用</p></blockquote><h2 id="全局常量和线程安全"><a href="#全局常量和线程安全" class="headerlink" title="全局常量和线程安全"></a>全局常量和线程安全</h2><blockquote><p>在let和const之间，建议优先选择const，尤其是在全局环境，不应该设置变量，只应该设置常量</p></blockquote><p>const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。</p><p>const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。<br>所有的函数都应该设置为常量。</p><p>长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>静态字符串一律使用单引号或者反引号，动态字符串使用双引号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> a = <span class="string">"foobar"</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="string">'foo'</span> + a + <span class="string">'bar'</span>;</div><div class="line"></div><div class="line"><span class="comment">// acceptable</span></div><div class="line"><span class="keyword">const</span> c = <span class="string">`foobar`</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> a = <span class="string">'foobar'</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="string">`foo<span class="subst">$&#123;a&#125;</span>bar`</span>;</div></pre></td></tr></table></figure><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>使用数组成员对变量赋值时，优先使用解构赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>];</div><div class="line"><span class="keyword">const</span> second = arr[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> [first, second] = arr;</div></pre></td></tr></table></figure><p>函数的参数如果是对象的成员，优先使用解构赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> firstName = user.firstName;</div><div class="line">  <span class="keyword">const</span> lastName = user.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; firstName, lastName &#125; = obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [left, right, top, bottom];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; left, right, top, bottom &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; left, right &#125; = processInput(input);</div></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2, &#125;;</div><div class="line"><span class="keyword">const</span> b = &#123;</div><div class="line">  k1: v1,</div><div class="line">  k2: v2</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2 &#125;;</div><div class="line"><span class="keyword">const</span> b = &#123;</div><div class="line">  k1: v1,</div><div class="line">  k2: v2,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> a = &#123;&#125;;</div><div class="line">a.x = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="comment">// if reshape unavoidable</span></div><div class="line"><span class="keyword">const</span> a = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(a, &#123; <span class="attr">x</span>: <span class="number">3</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="literal">null</span> &#125;;</div><div class="line">a.x = <span class="number">3</span>;</div></pre></td></tr></table></figure><p>对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ref = <span class="string">'some value'</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> atom = &#123;</div><div class="line">  ref: ref,</div><div class="line"></div><div class="line">  value: <span class="number">1</span>,</div><div class="line"></div><div class="line">  addValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> atom.value + value;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> atom = &#123;</div><div class="line">  ref,</div><div class="line"></div><div class="line">  value: <span class="number">1</span>,</div><div class="line"></div><div class="line">  addValue(value) &#123;</div><div class="line">    <span class="keyword">return</span> atom.value + value;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>使用扩展运算符（…）拷贝数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> len = items.length;</div><div class="line"><span class="keyword">const</span> itemsCopy = [];</div><div class="line"><span class="keyword">let</span> i;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">  itemsCopy[i] = items[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure><p>使用 Array.from 方法，将类似数组的对象转为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>);</div><div class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo);</div></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>立即执行函数可以写成箭头函数的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet.'</span>);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> x * x;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div></pre></td></tr></table></figure><p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, option = false </span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, &#123; option = false &#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用默认值语法设置函数参数的默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</div><div class="line">  opts = opts || &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="map结构"><a href="#map结构" class="headerlink" title="map结构"></a>map结构</h2><p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params">contents = []</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>._queue = [...contents];</div><div class="line">&#125;</div><div class="line">Queue.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">  <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(contents = []) &#123;</div><div class="line">    <span class="keyword">this</span>._queue = [...contents];</div><div class="line">  &#125;</div><div class="line">  pop() &#123;</div><div class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">    <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> inherits = <span class="built_in">require</span>(<span class="string">'inherits'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PeekableQueue</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">  Queue.apply(<span class="keyword">this</span>, contents);</div><div class="line">&#125;</div><div class="line">inherits(PeekableQueue, Queue);</div><div class="line">PeekableQueue.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekableQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">  peek() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'moduleA'</span>);</div><div class="line"><span class="keyword">const</span> func1 = moduleA.func1;</div><div class="line"><span class="keyword">const</span> func2 = moduleA.func2;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> &#123; func1, func2 &#125; <span class="keyword">from</span> <span class="string">'moduleA'</span>;</div></pre></td></tr></table></figure><blockquote><p>如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用</p></blockquote><p>不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</div></pre></td></tr></table></figure><p>如果模块默认输出一个函数，函数名的首字母应该小写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeStyleGuide</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> makeStyleGuide;</div></pre></td></tr></table></figure><p>如果模块默认输出一个对象，对象名的首字母应该大写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> StyleGuide = &#123;</div><div class="line">  es6: &#123;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> StyleGuide;</div></pre></td></tr></table></figure><h3 id="ES6的模块和commonJs的不同"><a href="#ES6的模块和commonJs的不同" class="headerlink" title="ES6的模块和commonJs的不同"></a>ES6的模块和commonJs的不同</h3><ul><li>commonjs模块输出的是一个值的拷贝，es6输出的是值的引用</li><li>commonjs是运行时加载，es6是编译时输出接口</li></ul><p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  counter: counter,</div><div class="line">  incCounter: incCounter,</div><div class="line">&#125;;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></div><div class="line">mod.incCounter();</div><div class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></div></pre></td></tr></table></figure><p>上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  get counter() &#123;</div><div class="line">    <span class="keyword">return</span> counter</div><div class="line">  &#125;,</div><div class="line">  incCounter: incCounter,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node main.js</div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure><p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</div><div class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></div><div class="line">incCounter();</div><div class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></div></pre></td></tr></table></figure><p>上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化</p><blockquote><p>ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块<br>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</div><div class="line"></div><div class="line">obj.prop = <span class="number">123</span>; <span class="comment">// OK</span></div><div class="line">obj = &#123;&#125;; <span class="comment">// TypeError</span></div></pre></td></tr></table></figure><blockquote><p>上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量</p></blockquote><p>最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mod.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.sum += <span class="number">1</span>;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sum);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</div></pre></td></tr></table></figure><p>上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES2015（ES6）和ES2016(ES7)的知识总结&lt;br&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>const,let,var</title>
    <link href="http://yoursite.com/2018/09/06/const-let-var/"/>
    <id>http://yoursite.com/2018/09/06/const-let-var/</id>
    <published>2018-09-06T00:50:03.000Z</published>
    <updated>2018-09-06T06:19:20.120Z</updated>
    
    <content type="html"><![CDATA[<p>一天看某位大佬的代码时，发现里面一个var也没有，当时就觉得惊为天人。当然学代码不能仅仅为了酷，酷当然是激励我们敲代码的一个重要理由，但我们也应该搞清楚为什么需要这么做，以便我们以后遇到了类似的问题知道该从什么样的思路出发<br><a id="more"></a></p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1背景介绍"><a href="#1-1背景介绍" class="headerlink" title="1.1背景介绍"></a>1.1背景介绍</h2><p>const，let实际上都是<a href="http://caibaojian.com/es6/" target="_blank" rel="external">es6</a>的新增内容</p><h2 id="1-2-参考资料"><a href="#1-2-参考资料" class="headerlink" title="1.2 参考资料"></a>1.2 参考资料</h2><ul><li><a href="http://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="external">阮一峰的es6标准入门</a></li><li><a href="http://www.infoq.com/cn/articles/es6-in-depth-let-and-const" target="_blank" rel="external">深入浅出es6</a></li></ul><h1 id="2-let"><a href="#2-let" class="headerlink" title="2.let"></a>2.let</h1><h2 id="2-1-let是更完美的var"><a href="#2-1-let是更完美的var" class="headerlink" title="2.1 let是更完美的var"></a>2.1 let是更完美的var</h2><blockquote><p>对于绝大多数代码而言，在es6的新标准下，你应该停止上使用var，能使用let就用吧</p></blockquote><h2 id="2-2-基本用法"><a href="#2-2-基本用法" class="headerlink" title="2.2 基本用法"></a>2.2 基本用法</h2><p>它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p><h2 id="2-3-不存在变量提升"><a href="#2-3-不存在变量提升" class="headerlink" title="2.3 不存在变量提升"></a>2.3 不存在变量提升</h2><h2 id="2-4-暂时性死区"><a href="#2-4-暂时性死区" class="headerlink" title="2.4 暂时性死区"></a>2.4 暂时性死区</h2><p>在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><p>暂时性死区”也意味着typeof不再是一个百分之百安全的操作。</p><blockquote><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p></blockquote><h2 id="2-5-不允许重复声明"><a href="#2-5-不允许重复声明" class="headerlink" title="2.5 不允许重复声明"></a>2.5 不允许重复声明</h2><h1 id="3-const"><a href="#3-const" class="headerlink" title="3 const"></a>3 const</h1><p>const在很多于语言都有体现，也很好理解了，即为声明一个只读的常量。一旦声明，常量的值就不能改变</p><h2 id="3-1-必须马上初始化"><a href="#3-1-必须马上初始化" class="headerlink" title="3.1 必须马上初始化"></a>3.1 必须马上初始化</h2><h2 id="3-2-不存在变量提升"><a href="#3-2-不存在变量提升" class="headerlink" title="3.2 不存在变量提升"></a>3.2 不存在变量提升</h2><h2 id="3-3-暂时性锁区"><a href="#3-3-暂时性锁区" class="headerlink" title="3.3 暂时性锁区"></a>3.3 暂时性锁区</h2><h2 id="3-4-const的本质"><a href="#3-4-const的本质" class="headerlink" title="3.4 const的本质"></a>3.4 const的本质</h2><p>对于简单数据类型const很好理解，但是对于符合类型的数据（数组和对象），只能保证那个变量所对应的地址不变，但对象本身还是可以修改的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一天看某位大佬的代码时，发现里面一个var也没有，当时就觉得惊为天人。当然学代码不能仅仅为了酷，酷当然是激励我们敲代码的一个重要理由，但我们也应该搞清楚为什么需要这么做，以便我们以后遇到了类似的问题知道该从什么样的思路出发&lt;br&gt;
    
    </summary>
    
      <category term="技术细节" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>前端工程师的ppt reveal.js</title>
    <link href="http://yoursite.com/2018/09/05/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84ppt-reveal-js/"/>
    <id>http://yoursite.com/2018/09/05/前端工程师的ppt-reveal-js/</id>
    <published>2018-09-05T06:23:17.000Z</published>
    <updated>2018-10-24T02:35:25.895Z</updated>
    
    <content type="html"><![CDATA[<p>不管是学生还是社畜，ppt始终是一个难以绕过的坎。没有艺术细胞的人对此的苦恼自不必说，即使对艺术感兴趣，限于时间和精力有限，我们也很难</p><a id="more"></a><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><h2 id="1-1-reveal-js是什么？"><a href="#1-1-reveal-js是什么？" class="headerlink" title="1.1 reveal.js是什么？"></a>1.1 reveal.js是什么？</h2><p>最开始我接触这个技术的时候是上次学习顾秩灵的<a href="http://justineo.github.io/slideshows/semantic-html/#/" target="_blank" rel="external">web语义化</a>，当时看的时候就觉得惊为天人，炫酷不说，而且和专业相关能够表现出自己的专业性</p><p>说了再多不如直接去看演示</p><p><img src="https://cdn.sspai.com/2017/08/29/4b2715265f01b94d10037572bf7f2948.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="gif"></p><p>它最突出的功能都在其官网主页展示得很清楚了，你只需要像坐火车一样静心欣赏它的美景就可以了</p><p>当然它最吸引我的还是其对markdown语法的支持，对于我这样重度md爱好者来说就是最好的福音</p><h2 id="1-2-它的优势"><a href="#1-2-它的优势" class="headerlink" title="1.2 它的优势"></a>1.2 它的优势</h2><ul><li>炫酷</li><li>可配置型不错（比不过ppt大佬，但强于一般人）</li><li>表现形式强</li><li>相比ppt碎片化表现感更强（ppt的基本展现单元是页，而这个可以是段）</li><li>支持markdown语法</li></ul><h2 id="1-3-相似的技术"><a href="#1-3-相似的技术" class="headerlink" title="1.3 相似的技术"></a>1.3 相似的技术</h2><ul><li><a href="http://imakewebthings.com/deck.js/#intro" target="_blank" rel="external">deck.js</a></li><li><a href="http://www.dowebok.com/107.html" target="_blank" rel="external">Scrollify</a></li><li><a href="https://github.com/alvarotrigo/fullPage.js/tree/master/lang/chinese#fullpagejs" target="_blank" rel="external">fullPage.js</a> [这个也非常好]</li><li><a href="http://bartaz.github.io/impress.js" target="_blank" rel="external">impress.js</a></li></ul><h1 id="2-参考资料"><a href="#2-参考资料" class="headerlink" title="2. 参考资料"></a>2. 参考资料</h1><ul><li><a href="https://sspai.com/post/40657" target="_blank" rel="external">把你的markdown变成PPT</a></li><li><a href="https://github.com/hakimel/reveal.js" target="_blank" rel="external">reveal.js的github地址</a></li><li><a href="https://revealjs.com/#/" target="_blank" rel="external">reveal.js的官方演示</a></li><li><a href="http://htmlcheats.com/reveal-js/reveal-js-tutorial-reveal-js-for-beginners/" target="_blank" rel="external">reveal.js tutorial</a></li></ul><h1 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h1><h2 id="3-1-一些快捷操作"><a href="#3-1-一些快捷操作" class="headerlink" title="3.1 一些快捷操作"></a>3.1 一些快捷操作</h2><ul><li>息屏 [B]</li><li>演讲者模式 [S] <img src="http://oy2kvpd7z.bkt.clouddn.com/md/1536131461154.png" alt="png"></li><li>缩放模式 [ESC]</li><li>全屏模式 [F]</li></ul><h2 id="3-2学习步骤"><a href="#3-2学习步骤" class="headerlink" title="3.2学习步骤"></a>3.2学习步骤</h2><p>多说无益，直接去看我上面列出的参考资料即可，虽然官方给出的api配置繁多，但想要实现基本功能却是非常简单。</p><p>我的建议是首先上它的github上下载源文件之后，首先学习它的index.html，这个比较简单而且一开始上手的话利于理解它整体的结构。这段代码很少，应该很快就能理解。然后再慢慢啃demo.html，理解完demo.html应该就差不多了，剩余的一些api就没有必要学得太详细了，需要用的时候再查就可以了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不管是学生还是社畜，ppt始终是一个难以绕过的坎。没有艺术细胞的人对此的苦恼自不必说，即使对艺术感兴趣，限于时间和精力有限，我们也很难&lt;/p&gt;
    
    </summary>
    
      <category term="系统学习" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="reveal.js" scheme="http://yoursite.com/tags/reveal-js/"/>
    
  </entry>
  
  <entry>
    <title>土拨鼠之日观后感</title>
    <link href="http://yoursite.com/2018/07/26/%E5%9C%9F%E6%8B%A8%E9%BC%A0%E4%B9%8B%E6%97%A5%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    <id>http://yoursite.com/2018/07/26/土拨鼠之日观后感/</id>
    <published>2018-07-26T12:38:21.000Z</published>
    <updated>2018-07-26T13:52:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>假如生命只剩下1天，你会做什么？</p><a id="more"></a><p>高中的时候其实就听说了这部电影，但是直到本科毕业才有机会看。最近看了两遍，真的感触很深，还是写一份影评来记录一下感受和自己的看法</p><blockquote><p>剧透警告</p></blockquote><p>主角菲尔是一个记者，他们当地的小镇在每年开春2月2号都有一个习俗，那就是通过土拨鼠能否看到自己的影子来判断春天是否来临</p><p>这当然只是一个引子，有趣的是当主角在2号之后醒来发现自己竟然还是处于2号的状态，一开始他以为只是一个无趣的骗局，可是当他走出旅馆时他惊恐地发现身边所有的事都和昨天经历过的一模一样。他发现了，自己已经陷入了一日囚，他尝试向自己的新同事丽塔倾诉，可被视作一个crazy guy</p><p>他愤怒继而失望</p><p>之后他意识到不管你当天做什么，第二天都会恢复原样，道德和规则对他来说就不存在任何意义。他通过一次次询问的方式来获取姑娘们的信息，然后第二天的时候自如地说出这些信息以尽可能博得姑娘们的好感，他这样的策略是成功的。但是他发现自己始终还有一个人无法攻克，那就是他的同事丽塔</p><p>他通过很多天来彻底摸清楚关于丽塔的一切，以尽可能地完成一个近乎完美的一日约会，可每次他都会失败，丽塔总是能在最关键的时刻发现他的阴谋</p><blockquote><p>“你在干什么？你甚至都不了解我？你在向我的好友们打电话以试图了解我的习惯吗？你这是真正的爱吗”</p></blockquote><p>他在彻底失败了很多次之后，彻底绝望了，他开始丧失了对生活的兴趣</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532610526991.png" alt=""></p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532610546245.png" alt=""></p><p>（男主的演技真的是没话说）</p><p>这一段我真的看的特别有感触，男主的那种绝望的眼神，我能明白</p><p>于是，他开始自杀，各种方式，火烧，撞车，电击，吃毒，无论他尝试哪一种第二天早上6点他都会回到最初旅馆的那张床上</p><p>他又一次陷入了另一种绝望，他开始找女主倾诉他的经历和一切，他说他是神“神之所以全知全能，只是因为他在人间待得够久”他能叫出小镇里每一个人的名字和经历，甚至能准确预报出接下里一段时间内会发生哪些事情。他说他自己因为无聊花了很多时间来训练一些平时可能根本不会注意的技巧，女主迷上了他，他们相爱了，但是男主这个时候眼里还是充满了暗淡</p><blockquote><p>我想说的是，你是我一生中见过的最善良，最体贴，最美丽的人。我从没见过任何人比你待人更好。第一次见到你，在我身上发生了奇妙的事情，我从没告诉过你，我知道我想用尽全身力气紧紧地拥抱你，我配不上像你这样的，但如果可以，我发誓我会爱你，一生一世<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532610944692.png" alt=""></p></blockquote><p>第二天起来，男主又回到了起点</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532611173610.png" alt=""></p><p>看看他这个眼神</p><p>男主之后开始改变了策略，他开始对生活中各式各样的东西感到新奇，并且每一项都花了大力气去学习，钢琴，冰雕，修车，急救术，他开始关心周围所有的人，他开始热爱身边所有的事物。当然他也碰到了当天必定会死救不回来的流浪汉</p><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532611390913.png" alt=""></p><p>当他开始真正积极地面对生活的时候，女主（或者说任何一个人）都情不自禁地爱上了他。</p><hr><p>说说我的想法吧</p><p>有一些瑕疵，但不失为一个精彩的电影。对现实很有指导意义。我指的瑕疵主要是剧情安排有一些刻意，比如最后的桥段，菲尔的改变导致大家都喜欢他，这当然是很好的事，但是桥段显得很刻意和突兀，一定程度上降低了这部电影在我心中的观感</p><p>当然，他揭示的道理，作为商业片来讲，还是非常深刻和鞭辟入里的。</p><p>当然我对片子里的真实性还是有一点存疑，这里并非是说一日囚这种奇遇，而是男主的态度。他的情感态度实际上是跟电影的节奏保持一致的，这也让我们在看的时候觉得连贯，但如果仔细推敲的话，这其实和男主实际经历的时间不一样。我之前看过有人分析说男主在这一天里已经困了二三十年了，假设真的有这么久的话，我很好奇男主是否还能对女主把持这样的激情呢</p><p>爱情究竟是一种怎么样的东西呢？</p><p>一见钟情，两相情悦这些都是经典的爱情理论和人们对于爱情的固有印象。那么如果是一方单方面的追求，这样的一段关系，究竟在多大程度上能够和爱情划上等号呢？</p><p>一种解释可能是这样的：追求只是让对方注意到你的机会，你可以在这个过程中尽情地展示你的魅力和决心，让对方逐渐对你产生好感。毕竟恋爱或者说爱情产生的必要条件就是双方都对对方产生水准之上的好感，而追求这个过程就是加速你们之间的进程。（自己把自己说服了）</p><p>同样，在恋爱或者说交往的过程，其实也是一个双方互相认同和成长的过程，我们能收获认同感，也能收获责任感</p><p>感觉我自己目前是享受不了这些特权了，一方面我自己的能力还不够强，另一方面我对感情的认识还很浅薄和肤浅。电影里揭示的道理简洁而深刻，感情从来就不是靠追，而是双方互相吸引，彼此喜欢，仅此而已。我们要做的就是尽可能地投资自己，让自己变得尽可能的充实</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假如生命只剩下1天，你会做什么？&lt;/p&gt;
    
    </summary>
    
      <category term="影评" scheme="http://yoursite.com/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>闲谈&amp;近期总结</title>
    <link href="http://yoursite.com/2018/07/20/%E9%97%B2%E8%B0%88-%E8%BF%91%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/07/20/闲谈-近期总结/</id>
    <published>2018-07-20T13:25:39.000Z</published>
    <updated>2018-09-29T09:34:28.249Z</updated>
    
    <content type="html"><![CDATA[<p>最近有一些事觉得很麻烦把，晚上去操场整理了一下思路，现在大概清晰一点了，写下来记录一下</p><a id="more"></a><h1 id="1-应该保持的习惯"><a href="#1-应该保持的习惯" class="headerlink" title="1.应该保持的习惯"></a>1.应该保持的习惯</h1><h2 id="思考的时候去操场散步"><a href="#思考的时候去操场散步" class="headerlink" title="思考的时候去操场散步"></a>思考的时候去操场散步</h2><p>已经很久没有去操场单独只是为了思考问题了，但事实证明这真的很有作用。在图书馆或者机房都无法完全沉浸式地去思考问题，但是操场可以，戴上bose就能体会到与世隔绝的感觉，真的对思考帮助很大</p><h1 id="2-关于爱情"><a href="#2-关于爱情" class="headerlink" title="2.关于爱情"></a>2.关于爱情</h1><p>晚上跟两个同学聊天，收货真的很大。但是后来仔细想了一下，问题还是远比我想象的复杂，这无关技巧，只在于恋爱本身，我想地越深入就会越觉得对它的本质感到好奇</p><p>当我在想到大学恋爱实际上不会很长久的时候，莫名地感到了一丝恐惧，进而突然想到，喜欢一个人究竟以意味着什么呢。</p><p>问题也许可以更深一步，那就是爱情或者说恋爱，对于一个独立个体来说，究竟意味什么呢？</p><p>从生理学的角度上讲无非就是多巴胺和荷尔蒙，但这样未免有失情趣。我以我少的可怜的经验去仔细揣度了一下，一对年轻的男女，相遇相恋，结婚生子，然后轮回。这是正常的较为理想的流程，可是如果是一个人的话，可能唯一的感觉就是孤独无靠吧。那么，为什么恋爱或者爱情已经固化为了人类的一项固有标签呢？繁衍后代的本能当然是一个很好的说辞，但这并不是我想要的答案。对于年轻人来说，恋爱对他们可能意味着新鲜，有趣，性，认同感。细化到生活中（或者说是用功利的眼光看待）可能是想想做的事能有人陪，一起分享开心，一起承担痛苦。</p><p>我在自己思考了一番之后打开了知乎，发现知乎现在果然跟我大二时的质量完全不能比了。不过这也算是我为了获取某个答案而采取捷径的恶果。当然后来才发现是自己选题质量不好，”爱情的本质是什么“这个问题下的回答质量普遍偏低，”爱情是什么“相对略好</p><p>看完答案之后我有点怅然若失，因为感觉不是自己想要的，突然意识到自己想要问的是”婚姻究竟以为着什么“ ”两个人的结合究竟意味着什么“</p><p>不过细想，爱情这种东西，似乎并不应然属于每一个人甚至是已经成家的人，再往深处想，就会开始质疑爱情本身的定义了</p><h1 id="3-关于自己"><a href="#3-关于自己" class="headerlink" title="3.关于自己"></a>3.关于自己</h1><p>爱好很杂并不一定是一件坏事，但是在该积累技术能力的时候把时间都浪费在这个上面就会显得很不为自己的未来负责</p><p>我决定未来一段时间不玩游戏（饥荒 &amp; 塞尔达）</p><p>自己的动力一直不足说到底还是不确信自己究竟未来应该做什么</p><p>现在差不多坚定下来了，还是主要做前端</p><p>另外，好久没写文章了。以前都是在ulysess上想到什么写什么，但其实这样不太好，因为输出还是最好在一个公共的平台，这样才有交流和获取更多信息的可能性。好久没有写文章&amp;看书的后果就是自己连一些基本的观点都说不利索了</p><p>之前翻阅原来的知乎答案的时候发现有时候自己连大二的时候都不如。曾经的自己对很多人文社科类的知识感兴趣，愿意看很多书来试图靠近一点点世界的真向，但是现在有的时候什么都不太想做，这样的自己又回到了原点</p><p>作为曾经尝试过很多的我，当然知道一些领域如哲学是很难入门的</p><p>已经很久没有体会到纯粹的智识性趣味了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有一些事觉得很麻烦把，晚上去操场整理了一下思路，现在大概清晰一点了，写下来记录一下&lt;/p&gt;
    
    </summary>
    
      <category term="随想" scheme="http://yoursite.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="个人成长" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>什么是Web语义化</title>
    <link href="http://yoursite.com/2018/07/11/%E4%BB%80%E4%B9%88%E6%98%AFWeb%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
    <id>http://yoursite.com/2018/07/11/什么是Web语义化/</id>
    <published>2018-07-11T12:10:52.000Z</published>
    <updated>2018-07-18T07:39:35.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>web语义元素的定义和我自己的理解</p></blockquote><a id="more"></a><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.zhihu.com/question/20455165" target="_blank" rel="external">知乎（如何理解Web语义化）</a></p><p><a href="http://justineo.github.io/slideshows/semantic-html/#/" target="_blank" rel="external">一个使用reveal.js写的挺炫酷的语义dom讲解</a></p><h1 id="权威解释"><a href="#权威解释" class="headerlink" title="权威解释"></a>权威解释</h1><blockquote><p>什么是语义化？其实简单说来就是让机器可以读懂内容。</p><p>先随便扯扯。对于当前的 Web 而言，HTML 是联系大多数 Web 资源的纽带，也是内容的载体。在 Web 被刚刚设计出来的时候，Tim Berners-Lee 可能不会想到它现在会达到的规模以及深入到我们生活的那么多方面。也许起初的想法很简单：用来发布 Web 内容和资源的索引，方便人们查看。</p><p>但是随着 Web 规模的不断扩大，信息量之大已经不在人肉处理的范围之内了。这个时候人们开始用机器来处理 Web 上发布的各种内容，搜索引擎就诞生了。再后来，人们又设计了各种智能程序来对索引好的内容作各种处理和挖掘。所以让机器能够更好地读懂 Web 上发布的各种内容就变得越来越重要。</p><p>其实 HTML 在刚开始设计出来的时候就是带有一定的「语义」的，包括段落、表格、图片、标题等等，但这些更多地只是方便浏览器等 UA 对它们作合适的处理。但逐渐地，机器也要借助 HTML 提供的语义以及自然语言处理的手段来「读懂」它们从网上获取的 HTML 文档，但它们无法读懂例如「红色的文字」或者是深度嵌套的表格布局中内容的含义，因为太多已有的内容都是专门为了可视化的浏览器设计的。面对这种情况，出现了两种观点：</p><p>1.我们可以让机器的理解能力越来越接近人类，人能看懂、听懂的东西，机器也能理解</p><p>2.我们应该在发布内容的时候，就用机器可读的、被广泛认可的语义信息来描述内容，来降低机器处理 Web 内容的难度（HTML 本身就已经是朝这个方向迈出的一小步了）。</p><p><img src="https://pic2.zhimg.com/01b4d93c152d2a9c2db734065be0f3f5_b.jpg" alt=""></p><p>我画的这个图，意思是说，内容的语义表达能力和 AI 的智能程度决定了机器分析处理 Web 内容能力的高低。上面观点 1 的方向是朝着人类水平的人工智能努力，而观点 2 的方向正是万维网创始人 Tim Berners-Lee 爵士提出的美好愿景：语义网。语义网我就不多说了，简单来说就是让一切内容和包括对关系的描述都成为 Web 上的资源，都可以由唯一的 URI 定义，语义明确、机器可读。显然，两条路都的终极目标都很遥远，第一条路技术上难以实现，而第二条路实施起来障碍太多。</p><p>我认为我们当前能够看得见摸得着的 Web 语义化，其实就是在往第二条路的方向上，迈出的一小步，即对已经有的被广泛认可的 HTML 标准做改进。我们刚开始意识到，我们必须回归内容本身，将内容本身的语义合理地表述出来，再为不同的用户代理设计不同的样式描述，也就是我们说的内容与样式分离。这样我们在提供内容的时候，首先要做的就是将内容本身进行合理的描述，暂时不用考虑它的最终呈现会是什么样子。</p><p>HTML 规范其实一直在往语义化的方向上努力，许多元素、属性在设计的时候，就已经考虑了如何让各种用户代理甚至网络爬虫更好地理解 HTML 文档。HTML5 更是在之前规范的基础上，将所有表现层（presentational）的语义描述都进行了修改或者删除，增加了不少可以表达更丰富语义的元素。为什么这样的语义元素是有意义的？因为它们被广泛认可。所谓语义本身就是对符号的一种共识，被认可的程度越高、范围越广，人们就越可以依赖它实现各种各样的功能。</p><p>HTML5 并非 Web 语义唯一倚仗的规范，除了 W3C 和 WHATWG 外，还有其它的组织在为扩展、标准化 Web 语义做着贡献。只要有浏览器厂商、搜索引擎原意支持，它们的规范一样可以成为通用的基础设施。例如 microformats 社区以及 <a href="http://Schema.org" target="_blank" rel="external">http://Schema.org</a> 上都有对 HTML 以及 Microdata（<a href="http://www.w3.org/TR/html5/microdata.html）" target="_blank" rel="external">http://www.w3.org/TR/html5/microdata.html）</a> 规范的扩展词汇表，Google、Bing、Yahoo! 等搜索引擎以及各个主流浏览器都不同程度地接纳了其中定义的语义扩展，并应用在了生产中。</p></blockquote><h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><p>首先要明确一点，这一次任务虽然非常简单，但是却是很重要的一节，我自己做项目的时候能够感觉得出来，div的语义化写得不明显就只能用class来凑，感觉很不规范。</p><p>我之前一直在想在网上找规范什么的，突然在IFE的笔记区里看到一个另我豁然开朗的答案————直接去大厂的html里看啊，看人家是怎么设定html的，直接对着写两个，自己马上就能明白</p><blockquote><p>发现自己还是too young，看了下淘宝和微博，发现它们都是用的div，根本没怎么在语义上下功夫</p></blockquote><p>记好这张图就好了<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1531313829236.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;web语义元素的定义和我自己的理解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>(转)js闭包问题解决</title>
    <link href="http://yoursite.com/2018/07/05/%E8%BD%AC-js%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/07/05/转-js闭包问题解决/</id>
    <published>2018-07-05T09:11:36.000Z</published>
    <updated>2018-09-06T00:49:25.991Z</updated>
    
    <content type="html"><![CDATA[<p>最近又碰到了js的闭包问题，感觉自己的基础还不扎实…在网上找到了一个文章已经把解决方法总结得很好了，直接搬运一下，之后再加点自己的东西<br><a id="more"></a></p><h1 id="JS中for循环里面的闭包问题的原因及解决办法"><a href="#JS中for循环里面的闭包问题的原因及解决办法" class="headerlink" title="JS中for循环里面的闭包问题的原因及解决办法"></a>JS中for循环里面的闭包问题的原因及解决办法</h1><p>我们先看一个正常的for循环，普通函数里面有一个for循环，for循环结束后最终返回结果数组</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">        arr[i] = i;        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line">alert(box()) <span class="comment">//正常情况不需要闭包，就可以达到预期效果</span></div><div class="line">   <span class="comment">//输出结果为一个数组 0,1,2,3,4</span></div></pre></td></tr></table></figure><p>有时我们需要在for循环里面添加一个匿名函数来实现更多功能，看下面代码</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//循环里面包含闭包函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">        arr[i] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> i;                            <span class="comment">//由于这个闭包的关系，他是循环完毕之后才返回，最终结果是4++是5</span></div><div class="line">        &#125;                                        <span class="comment">//这个匿名函数里面根本没有i这个变量，所以匿名函数会从父级函数中去找i，</span></div><div class="line">    &#125;                                            <span class="comment">//当找到这个i的时候，for循环已经循环完毕了，所以最终会返回5</span></div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="comment">//alert(box());                                    //执行5次匿名函数本身</span></div><div class="line"><span class="comment">//alert(box()[1]);　　　　　　　　　　　　　　　　　　　//执行第2个匿名函数本身</span></div><div class="line"><span class="comment">//alert(box().length);                            //最终返回的是一个数组，数组的长度为5</span></div><div class="line">alert(box()[<span class="number">0</span>]());                                <span class="comment">//数组中的第一个数返回的是5，这是为什么？</span></div></pre></td></tr></table></figure><p>上面这段代码就形成了一个闭包：</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见的方式，就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量。</p></blockquote><p>在for循环里面的匿名函数执行 return i 语句的时候，由于匿名函数里面没有i这个变量，所以这个i他要从父级函数中寻找i，而父级函数中的i在for循环中，当找到这个i的时候，是for循环完毕的i，也就是5，所以这个box得到的是一个数组[5,5,5,5,5]。</p><h1 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h1><p>在看解决方案一之前，我们先看一下匿名函数的自我执行：</p><p>匿名函数自我执行的写法是，在函数体外面加一对圆括号，形成一个表达式，在圆括号后面再加一个圆括号，里面可传入参数。</p><p>例如下代码：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">function</span>()&#123;</div><div class="line">    alert(<span class="name">'lee'</span>)<span class="comment">;                //匿名函数自我执行(匿名函数)()</span></div><div class="line">&#125;)()<span class="comment">;</span></div></pre></td></tr></table></figure><p>我们再来看解决方案1：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">        arr[i] = (<span class="function"><span class="keyword">function</span><span class="params">(num)</span></span>&#123;                    <span class="comment">//自我执行，并传参(将匿名函数形成一个表达式)(传递一个参数)</span></div><div class="line">            <span class="keyword">return</span> num;                            <span class="comment">//这里的num写什么都可以                    </span></div><div class="line">        &#125;)(i);                                    <span class="comment">//这时候这个括号里面的i和上面arr[i]的值是一样的都是取自for循环里面的i                            </span></div><div class="line">    &#125;                                            </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="comment">//alert(box());                                </span></div><div class="line"><span class="comment">//alert(box()[1]);</span></div><div class="line"><span class="comment">//alert(box().length);                            </span></div><div class="line">alert(box()[<span class="number">0</span>]);</div></pre></td></tr></table></figure><p>通过给匿名函数传参，而传递的这个参数i是每次执行for循环里面的i，每次传递的参数i的值都不一样，匿名函数里面的num接收传递的参数i，所以box()最终输出结果为[0,1,2,3,4]</p><h1 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h1><p>这种方案的原理就是在匿名函数1里面再写入一个匿名函数2，这个匿名函数2需要的num值会在他的父级函数匿名函数1里面去寻找，而匿名函数1里面的num值就是传入的这个参数i，和上面例子中的i是一样的，</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function box()&#123;</div><div class="line"><span class="code">    var arr = [];</span></div><div class="line"><span class="code">    for(var i=0;i&lt;5;i++)&#123;</span></div><div class="line"><span class="code">        arr[i] = (function(num)&#123;</span></div><div class="line"><span class="code">        //num在这里                                    //原理和上面一种方法一样的，所以可以实现闭包                    </span></div><div class="line"><span class="code">            return function()&#123;                        //在这个闭包里面再写一个匿名函数</span></div><div class="line"><span class="code">                return num;                            </span></div><div class="line"><span class="code">            &#125;;                                                                </span></div><div class="line"><span class="code">        &#125;)(i)                                                </span></div><div class="line"><span class="code">    &#125;</span></div><div class="line"><span class="code">    return arr;</span></div><div class="line">&#125;</div><div class="line">//alert(box());                                </div><div class="line">//alert(box()[1]);</div><div class="line">//alert(box().length);</div><div class="line">var b = box();                            </div><div class="line">alert(b[<span class="string">0</span>](<span class="link"></span>));</div><div class="line">alert(box()[<span class="string">0</span>](<span class="link"></span>));</div></pre></td></tr></table></figure><p>box()最终返回结果[0,1,2,3,4],</p><h1 id="解决方案3"><a href="#解决方案3" class="headerlink" title="解决方案3"></a>解决方案3</h1><p>如果将一个匿名函数自我执行的时候赋值给一个变量，那么这个匿名函数中的圆括号的可以去掉的，看下面代码，</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tip = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;         <span class="comment">//这样把匿名函数自我执行的时候赋值给一个变量，那么圆括号是可以去掉的</span></div><div class="line">    alert(<span class="string">'lee'</span>);</div><div class="line">&#125;();</div></pre></td></tr></table></figure><p>利用匿名函数的这一特点，我们可以将解决方案1中的代码改进一下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">        arr[i] = <span class="function"><span class="keyword">function</span><span class="params">(num)</span></span>&#123;                </div><div class="line">            <span class="keyword">return</span> num;                            </div><div class="line">        &#125;(i);                                </div><div class="line">    &#125;                                            </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="comment">//alert(box());                                </span></div><div class="line"><span class="comment">//alert(box()[1]);</span></div><div class="line"><span class="comment">//alert(box().length);                            </span></div><div class="line">alert(box()[<span class="number">4</span>]);</div></pre></td></tr></table></figure><h1 id="解决方案4"><a href="#解决方案4" class="headerlink" title="解决方案4"></a>解决方案4</h1><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1536194960944.png" alt=""></p><p>匿名函数在执行的时候他本身就传递给了一个变量arr[i]，所以匿名函数的圆括号是可以去掉的。</p><p>以上就是几种解决for循环中闭包的办法，当然还有更多办法，大家可自行google或者bing其他资料来加深印象(百度是基本上搜不到什么有用的文章的)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又碰到了js的闭包问题，感觉自己的基础还不扎实…在网上找到了一个文章已经把解决方法总结得很好了，直接搬运一下，之后再加点自己的东西&lt;br&gt;
    
    </summary>
    
      <category term="技术细节" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
</feed>
