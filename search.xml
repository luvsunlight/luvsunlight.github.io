<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019年终总结</title>
    <url>/2019/12/30/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2019年的年度总结</p>
<a id="more"></a>
<p>2019年在这个博客上写的东西很少了，主要是因为感觉在这个blog上东一篇西一篇地写文章很没有章法，也不利于记忆。于是在github上另开了两个仓库，<a href="https://github.com/luvsunlight/front-end-cookbook" target="_blank" rel="noopener">前端知识手册</a>和<a href="https://github.com/luvsunlight/frontend-interview-archive" target="_blank" rel="noopener">前端面试手册</a>，关于系统性知识的总结都放在了github的仓库上面。</p>
<p>一时间都有种想要废弃这个blog的打算，但是意识到知识手册终究是知识手册，想要有一个全面性的知识输出，还是得靠博客，于是我又回来了</p>
<p>正式开始之前先感慨一句，去年9月份才刚刚研究生入学，但是一晃眼，我就又到了要准备两个月后的春招了，时间真的不等人啊，不过小组内一届的专硕更加不容易，研究生生涯开始半年就要开始准备工作的事宜了，想想大家都还是挺不容易的</p>
<p>2019年，这一年的我是既勤奋又不勤奋的一年，我虽自诩为前端行业从事者也是爱好者，本科阶段的课程作业也均是使用前端相关技术，但说来惭愧，我从去年9月份才开始接触vue，进而引入前端的新浪潮，在这短短的一年里，我接触并学习了无数的新名词和新领域。新知识之多让我不禁感慨，怎么本科阶段通杀的那些技术到了如今显得如此不堪，再回首以前的经历时感觉自己好像在玩泥巴。</p>
<p>正式总结如下</p>
<p>在这一年里，我在技术方面做了如下的事</p>
<blockquote>
<p>项目方面</p>
</blockquote>
<ul>
<li>happy-question项目，学习vue全家桶做一个稍大型的项目</li>
<li>在学习css布局各种知识时，使用vue-cli创建了<a href="https://github.com/luvsunlight/css-layout-demo" target="_blank" rel="noopener">一个项目</a>用于加深理解</li>
<li>vue-beauty项目，<code>vue</code>+<code>vuex</code>+<code>vue-router</code>+<code>vue-infinite-scroll</code>+<code>vue-awesome</code>+<code>axios</code>+<code>懒加载</code>+<code>less</code>，做了一个懒加载好康图片的应用（github上找的练手项目）</li>
<li><a href="https://github.com/luvsunlight/vue-chat" target="_blank" rel="noopener">vue-chat项目</a>，<code>vue全家桶</code>+<code>mock</code>+<code>less</code>等，一个仿微信聊天的应用，练手之作</li>
<li><a href="https://github.com/luvsunlight/vue-todos" target="_blank" rel="noopener">vue-todos项目</a>，技术栈同上，也是一个练手之作，主要是好看，自己觉得特别舒服</li>
<li><a href="https://github.com/luvsunlight/js-archive-creator" target="_blank" rel="noopener">js-archive项目</a>，最开始是因为在整理知识网的时候，有好几个项目想要整理，感觉都可以写成一个工具，以便复用，现在是一个半完成体，只支持localStorage，还没有做数据库的存储</li>
<li><a href="https://github.com/luvsunlight/vuelegant" target="_blank" rel="noopener">vuelegant</a>，打算自己从头写一个UI框架，参考的是<a href="https://vue.ant.design/components/message-cn/" target="_blank" rel="noopener">ant-design-vue</a>和<a href="https://www.iviewui.com/components/icon" target="_blank" rel="noopener">iView</a>的源码，虽然尚未完成，但是学习了很多组件库的组织方式，命名规范等</li>
<li>osm-track-proj，这个是研究生期间导师要求完成的项目，技术栈为<code>vue全家桶</code>+<code>mock</code>+<code>ant-design-vue</code>+<code>less</code>+<code>axios</code>+<code>Web GL</code>+<code>nodejs</code>+<code>mySql</code>,是一个很全面的项目，不过导师并没有采纳此方案</li>
<li>完成了两个小程序，一个是给女朋友的生日礼物，还有一个是给机房设计的月报系统</li>
</ul>
<blockquote>
<p>开源方面</p>
</blockquote>
<ul>
<li>学习了vue-cli2.x版本的自定义template，自己写了一个<a href="https://github.com/luvsunlight/webpack" target="_blank" rel="noopener">常用的template</a>并且push到github上了（后已全部改用vue-cli3.x ~ ？）</li>
<li>耗时两个月，系统学习了数据结构和算法，并且在leetcode上刷了一定量的题目（后来因为准备前端系统知识而暂时搁置），对基本的数据结构和算法有较为熟练的掌握和理解。并且在github上基于docsify建立了一个<a href="https://github.com/luvsunlight/algorithm" target="_blank" rel="noopener">项目</a></li>
<li><code>gulp</code>+<code>babel</code>+<code>npm script</code>做了一个<a href="https://github.com/luvsunlight/docsify-vuepress-theme" target="_blank" rel="noopener">docsify的theme</a>，这个时候还不知道CI，自己写了一个脚本用于打包和部署npm仓库，但也算正式脱离vue-cli工具，自己构建工具流。<ul>
<li>可以改进的地方有很多，比如持续构建，AST代替正则会更好</li>
</ul>
</li>
<li>基于<code>webpack</code>+<code>babel</code>+<code>travis CI</code>+<code>semantic release</code>+<code>mocha+chai</code>做了一个自定义log的库，正式用持续构建的思想去维护开源项目</li>
<li>基于<code>rollup</code>+<code>travis CI</code>+<code>semantic release</code>+<code>babel</code>，将本科阶段写的webGL封装库优化并且以npm仓库的形式发布，rollup比起webpack更适合打包第三方库</li>
<li>建立了一套<a href="https://github.com/luvsunlight/fjl-cli" target="_blank" rel="noopener">脚手架工具</a>，类似yeoman，用于快速生成代码模板，并且创建了两套模板，<a href="https://github.com/luvsunlight/oslib-template" target="_blank" rel="noopener">一套</a>用于快速生成js第三方库，基于rollup打包，<a href="https://github.com/luvsunlight/doc-template" target="_blank" rel="noopener">另一套</a>用于快速生成文档模板</li>
<li>维护了两个前端知识仓库，<a href="https://github.com/luvsunlight/front-end-cookbook" target="_blank" rel="noopener">前端知识手册</a>和<a href="https://github.com/luvsunlight/frontend-interview-archive" target="_blank" rel="noopener">前端面试手册</a>，可以说这两个仓库占据了我下半年的绝大部分精力，我意识到光会使用vue做项目根本算不上精通前端，也意识到一年前看的书如今再次回顾宛如新书，我决定以在线笔记的形式维护这两个大型的项目（第二个项目是在准备面经时创建的，主要还是第一个项目）</li>
</ul>
<p>看起来好像今年做了很多事，但其实难度都很浅，只是更高程度的CURD，这里单指项目方面，在知识学习方面还是汲取了很多的，尤其在js基础知识上认真巩固了一下。前面之所以说今年也是很不勤奋的一年，就是因为我本可以做更多更有趣更深入的事情，但是我贪图玩乐(?)，将很多时间浪费在了娱乐上，每次看到大神都会感到冷汗直冒，深感惭愧。明年将是转折的一年，我需要同时面临毕业和找工作的压力，希望新的一年我可以学习更多的知识，更好地巩固自己的能力</p>
<p>11月份的时候和机房的几个同学一起想要参加qq小程序比赛，这个时候的我自诩在前端方面做一个简单的业务开发还是问题不大的，再加上自己年初的时候有小程序的开发经验，在和小组成员头脑风暴一个晚上初步定下项目的方案后，就拍胸脯承诺下了全包此事（组队的除了我之外只有一个初级前端）。现在想想这可能是本科阶段我参加项目的后遗症，本科时我负责过很多项目都是我一个人承担，但万万没想到这样的工作模式一旦工作量大了就会带来巨大的隐患。真正接手这个项目才发现它的各种棘手之处，首先qq小程序平台开发体验极其极其极其恶心，要啥功能啥功能没有，我不明白都是一个公司的产品，该编辑器还在微信开发者工具之后，咋功能还反过来落后微信的几个档次呢？它连基本的emmet也没有，组件页面一键生成也没有，而且热更新的执行效率也非常差（估计是编译的问题），平时用vsc开发vue的程序，保存文件后1s之内html就发生了对应的更新，qq小程序开发工具将这个时间成功得延长了5-10倍，整个人像吃了屎一样的恶心，还不如手动刷新页面来得快。此外这个工具还有各式各样的bug，在pc端能够正常运行，一到真机调试就会出现问题。在这里可以剧透了，我们小组最终放弃了该比赛，而导致我们真正放弃比赛的原因还不是前面那些，而是小程序端和服务端的交互，在微信小程序开发中，它提供了免费的云开发，但是到qq这里，没门，不仅如此，它还要求你在短短一个月的时间里办好域名，服务器和相应的域名备案。而我们团队知晓这一点时，距离比赛结束的时间已经不足以备案了，再加上组内的几位小伙伴一点也不擅长此事，只得就此作罢。</p>
<p>以上这些是我们放弃比赛的客观原因，当然也是存在主观原因的，那就是我对一个产品的开发流程过于乐观和松懈了，尽管我之前已经了解了软件工程里的敏捷开发和瀑布模型等知识，但真正上手一个产品开发时还是硬着头皮一把梭，初步订好功能模块之后，也不设计原型，也不考虑各个模块的复杂程度和可实现度，代码写到哪就是哪，再加上我之前把开发的工作全都揽下了，产品UI和代码全部都是我一个人负责，我在开发完产品的二分之一部分时就感觉到了严重的力不从心，难度不大，但无奈要设计的部分实在太多了，全部工程交由一人负责实在困难。我本来指向安心地写代码，现在产品设计和UI还有代码架构的事全要负责，而且还要限时一个月之内完成，我着实感觉有些困难。</p>
<p>现在回过头来看这次比赛，还是能有不少收获和反省的</p>
<ul>
<li>对于在校生来说瀑布模型显得不够灵活，敏捷开发也太捉襟见肘，那么快速迭代模型显然是一个可以采取的方案</li>
<li>设计产品方案时，在讨论好产品定位和大概模块之后，也不要急着开写，可以细分模块，再做进一步的讨论</li>
<li>模块也要细分讨论，主要商议细节怎么处理，以及该模块可能的复杂度</li>
<li>PD和美工一起设计原型，然后再开会讨论，组内一致通过后，再可以开始前端页面的构建</li>
<li>代码方面至少要两个人，前后端分离，如果人员有空闲，最好再分一个人解决服务器，域名和备案这方面的配置准备</li>
<li>讨论方案时的复杂度可能和实际施工时的复杂度有出入，这个时候可以慢慢啃让这个模块成为程序中的亮点，也可以适当缩减模块的内容，让单位时间的产出比更高</li>
<li>一个人全揽活不适合大型开发除非你有异常充盈的知识储备和充足的时间</li>
<li>代码全部完成后要快速迭代，可以组内讨论也可以请人来测试，然后再按模块修改产品功能</li>
</ul>
<p>今年我比较满意的点是认真学习了数据结构，这让我在思考代码和平时的很多场景中都充满自信，还有认真学习了js的基础知识。事实证明任何时候学习编程的基本能力才能真正提升人的编程水准和自信。不满的地方在于项目过于单薄，明天争取做几个有挑战性的项目，让能力和水准上一层台阶</p>
<blockquote>
<p>2020计划</p>
</blockquote>
<p>技术方面</p>
<ul>
<li style="list-style: none"><input type="checkbox"> 初步完成深度学习入门，看完《深度学习入门》，并且做出知识整合</li>
<li style="list-style: none"><input type="checkbox"> 学习编译原理</li>
<li style="list-style: none"><input type="checkbox"> 学习ts，并且完成项目落地</li>
<li style="list-style: none"><input type="checkbox"> 学习node，基础的后端知识</li>
<li style="list-style: none"><input type="checkbox"> 学习react</li>
<li style="list-style: none"><input type="checkbox"> 学习Electron</li>
<li style="list-style: none"><input type="checkbox" checked> 重看红宝书（2遍）</li>
<li style="list-style: none"><input type="checkbox"> 项目<ul>
<li style="list-style: none"><input type="checkbox"> 重新维护vuelegant项目</li>
<li style="list-style: none"><input type="checkbox"> 重新维护js-archive-creator项目</li>
<li style="list-style: none"><input type="checkbox"> 实现一个简易版的vue</li>
<li style="list-style: none"><input type="checkbox"> 实现一个美团仿版</li>
<li style="list-style: none"><input type="checkbox"> 使用PWA重构vue-todo</li>
<li style="list-style: none"><input type="checkbox"> 做一个复杂一点的后台系统</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"> 开启看源码计划<ul>
<li style="list-style: none"><input type="checkbox"> vue</li>
<li style="list-style: none"><input type="checkbox"> jquery</li>
<li style="list-style: none"><input type="checkbox"> ant-design-vue架构剖析</li>
</ul>
</li>
</ul>
<blockquote>
<p>生活方面</p>
</blockquote>
<ul>
<li style="list-style: none"><input type="checkbox"> 找到心仪的offer</li>
<li style="list-style: none"><input type="checkbox"> 初步学习制作音乐</li>
</ul>
<blockquote>
<p>结语</p>
</blockquote>
<p>这算是正儿八经的第一次年度总结和计划，以后这个版块我希望自己能越做越好，自己的博客也要慢慢</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年终总结</title>
    <url>/2020/12/25/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今年的主题词是得与失</p>
<a id="more"></a>
<p>今年因为疫情的原因，发生了很多很多事，说出来可能觉得光怪陆离，但回头再看的时候又会觉得没什么，就如我现在心情丧到了极点，但是还是要跑过来写这篇年终总结</p>
<p>心情丧是写年终总结的原因，这一点你可能想象不出来，起因是我下午和本科室友聊了一会天，自信心被严重打击到了，他和我的对比是次要的，这一番谈话让我积压已久缺乏疏导的规划问题彻底暴露了出来，我再一次面临着灵魂拷问，我是谁，我到底要干什么。这不是玩梗，我真的对未来产生了迷茫</p>
<p>多的话等会再说，现在先梳理下今年我到底干了哪些事吧</p>
<blockquote>
<p>P.S.这里翻了一下去年的年终总结，恨不得把自己埋到土里，去年的自己多认真啊，今年咋拉胯成这样<br>P.S.但是保持年终总结的习惯还是好的，起码写了之后让人不至于觉得一年白干了</p>
</blockquote>
<ul>
<li>1月份。记不得了，应该是在学校做事吧，1月中回家之后应该就是玩和吃东西了，也没啥正经事做，这里注明一下：回家期间吃了大量的巧克力和小鱼仔，伤了喉咙，导致一年的时间里自己的喉咙都很不舒服，一直在咳嗽，以后一定要注意吃东西要节制，不要一次吃个没玩</li>
<li>2月份。疫情爆发了，至此开始了漫长的家里蹲生涯（感谢这段时间，让我静下心来学了点东西）。在家里赖了很长时间之后也会无聊，并且要准备工作相关的事宜了，其实之前的积累已经挺充足了，但还是学习了浏览器相关的知识，事实证明，这些知识非常重要，可以说影响了我整个前端生涯。学习完这些之后大概准备了半个月的八股，就开始上战场啦</li>
<li>3月份。这个月就是各种面试和相关的准备，前后面了美团，阿里和字节。也顺利拿到了阿里和字节的实习offer，最后选择去了阿里</li>
<li>4月份。其实这个月我应该还有部分面试，但是当阿里的面试结束之后（其他的流程也都走完了），我就开始放松了，每天在家里打麻将</li>
<li>5月份。因为6月要去实习啦，在家里闲鱼到5月中旬的我提前半个月去了武汉</li>
<li>6月-9月初。在阿里的漫长3个月，也顺利拿到了转正的资格。期间过了字节的提前批，春风得意回到了学校</li>
<li>9月-10月。期间和阿里字节分别谈了薪资，最终选择了阿里。科研方面没有啥特别的进展，学习=0</li>
<li>11月-12月。签三方，硕士开题答辩，科研方面有了一点的进展，学习方面报了一个培训班，对现有知识体系进行查漏补缺</li>
<li>over</li>
</ul>
<p>今年真的经历了很多事，自己的心态也发生了很大的变化，但我觉得并不是一件好事，拿了一份好offer让我变得有些傲慢，和女朋友的吵架次数也越来越频繁，做事情也越来越敷衍，总觉得这也不重要，那也不重要，身体素质每况愈下，脖子痛和腰痛是常有的事，人也感觉变笨了，不记东西，看到了新东西，学习起来既没动力也没有经历，和女朋友合租的房子也越来越脏乱。除此之外，今年还发生了一些客观的不好的因素，陪我到大的老太国庆节去世了，我和女朋友租房被中介骗了等等，一系列的事情看上去都不是那么好过</p>
<p>过去的事情已经过去了，我们始终还是要往前看，死也不敢死，何况活着也有挺多有意思的事情</p>
<p>我今年对自己最大的不满意就是对很多事情变得不在乎。在公司的编码没有那么的快乐，想着回学校之后自由一些，可以做自己想做的事，结果一直都没有，说这要改造自己的博客，以及写一个游戏，啥也没干</p>
<p>还好一切都来得及，我在这里写下年终总结，一方面是回顾自己，另一方面也是鞭策自己，自己还远远做得不够好，新的一年，不要沉迷游戏，把时间多陪陪伴侣，多放在生活上，多放在提升自己上</p>
<p>今年的年终总结显得有些意识流，想到哪写到哪，不过无所谓，写的东西取悦自己就好</p>
<p>现在我正在空无一人的机房里写下这个总结，心情还是一团乱麻，回家之后，先收拾好房间，把房间收拾好了，放下电脑，好好地做点事</p>
<p>有规划的同时也要脚踏实地，不要再划水混日子了</p>
<p>看书的话，今年看完了一本刑法学讲义，感觉自己现在再很难读下一些晦涩的书了，看一些杂文挺好的</p>
<p>好了，最后写下自己对新年的期许吧</p>
<p>希望明年的我</p>
<ul>
<li>技术上<ul>
<li>写一个够复杂的博客系统</li>
<li>有空的话写一个游戏玩</li>
</ul>
</li>
<li>生活上<ul>
<li>能够以更好的生活态度对待生活和身边人</li>
<li>看更多的书</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年新计划</title>
    <url>/2019/02/18/2019%E5%B9%B4%E6%96%B0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<blockquote>
<p>新的一年已经开始了，去年做的还不够好，新的一年在技术上还是应该多抓紧一些</p>
</blockquote>
<a id="more"></a>
<h1 id="1-研究生生活"><a href="#1-研究生生活" class="headerlink" title="1.研究生生活"></a>1.研究生生活</h1><ul>
<li>下个学期每天认真看论文，还有自己写论文，主题暂定为动物迁徙，主要是去认真看一些有意思的话题</li>
<li>公众号完善一下</li>
</ul>
<h1 id="2-生活方面"><a href="#2-生活方面" class="headerlink" title="2.生活方面"></a>2.生活方面</h1><ul>
<li>去蹭日语课，今年要达到日语N3的水平</li>
<li>上公开课（苏德超，赵林，周玄毅）</li>
<li>健身</li>
<li>学会基础的摄影</li>
<li>有闲暇的时间就去看书</li>
</ul>
<h1 id="3-编程方面"><a href="#3-编程方面" class="headerlink" title="3.编程方面"></a>3.编程方面</h1><ul>
<li>学习node的教程</li>
<li>看自己之前买的几本书，并且开始做笔记</li>
<li>微信的开发</li>
<li>极客时间上的教程</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2020春招总结</title>
    <url>/2020/04/14/2020%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>其实我的春招在上一周就完成地差不多了，但是一直在整理剑指offer的一个项目再加上被学校的事占用了一些时间，这才有机会好好整理一下自己春招的情况和最近的学习状态，东西很杂，但我会尽量按逻辑梳理</p>
<a id="more"></a>
<h1 id="春招之路"><a href="#春招之路" class="headerlink" title="春招之路"></a>春招之路</h1><p>首先我这这篇文章不是讲面经的，我的面经早就已经整理在<a href="https://luvsunlight.github.io/front-end-cookbook/#/_posts/%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86" target="_blank" rel="noopener">我的项目里</a>，感兴趣的可以去看看</p>
<p>今年的春招也是我第一次正经的技术面试，我一共投递了五家企业，都是在牛客上找的内推，其中猿辅导没有暑假实习，美团二面之后就没有消息了，字节给了offer，然后阿里走到了hr面，还在等后续。快手我最后拒了，因为效率太慢了…</p>
<p>面试的感受的话，其实面经也讲了很多，这里也聊聊吧，不过只讲感受不讲细节。这次春招之前我做了接近一个月的准备，其实真正的准备是去年开始的，包括算法数据结构/JS基础，今年2月系统整理了浏览器知识和网络知识，再去刷了一周面经，差不多查漏补缺了就去面试了。事实证明，应届生面试，基础知识真的非常非常重要，我的工程化知识大部分面试官都不会太刁难，基础知识我自己感觉占了面试过程中80%的比重。</p>
<p>当然面试过程中也有很多插曲，阿里的面试是我在牛客上找的一位学长，最开始他帮我修改简历，到最后我每次面试的进度跟进还有平时疑惑的地方，这位学长都会不厌其烦地解惑，真的非常感谢!（阿里面试过程中遇到的每位前辈人都超级nice!，一面二面三面面试官包括校招的leader）字节的hr比较慢等offer等了很久…美团我一二面感觉没啥问题，不知道为啥被泡了池子。快手效率比阿里还慢…我上述五个岗位是同时投递的，但是字节美团和阿里都接近面试的尾声了，快手过了一个月才通知我一面，最后我因为这段时间想要静下心来学习还是委婉拒绝了后续的面试。面试的过程能够收获很多东西，比如你有哪些知识属于短板，比如现在招聘市场上面试官看中哪些功能，还有你可以借此机会结识很多大牛，不管后续结果如何，总归是多了一份机会。但是同时面试也是一个比较痛苦的过程，它对心理素质和身体素质都是一次考验，等待陌生电话的感觉既紧张又刺激，同时你也很难抽出大块的时间来武装你自己，毕竟这个时候的准备都是有限面向面试的</p>
<p>最后是一句老话，虽然基础功的积累很难突击，这需要平时的日积月累，但是也无需对自己太过不自信，永远没有完全准备好的那一天，面试官问的问题总有你不知道的，这也不是丢脸的事情，但重要的是你基础知识牢靠，见招拆招，你虽然不了解这个领域，但是可以结合自己的内功尝试向面试官阐述自己的理解，比如我字节一面时面试官问了我一个大量插入DOM的场景该怎么设计策略，我虽然没有做过这种业务，但是涉及大量DOM操作肯定要往重绘重排上考虑。当然如果技术性太强，自己又完全不知道就老实向面试官承认即可</p>
<h1 id="关于未来一段时间的学习"><a href="#关于未来一段时间的学习" class="headerlink" title="关于未来一段时间的学习"></a>关于未来一段时间的学习</h1><p>通过春招这接近一个月的面试体验来说，我对自己的能力边界也有一个大概的了解。首先我前端基础知识基本没有太大的问题，不管是哪一家的面试，我在这方面没有出过大的纰漏，这也和我自己系统的复习有关，从JS基础，到浏览器机制，网络和安全，工程化和框架。这些问题目前我都有自己的理解和体系，就算没接触过的业务也可以快速定位到知识点，这是我目前最大的优势，要保持但是也不能松懈</p>
<p>但是也有一些硬的点我在面试过程中表现不太好，给我拉低了分的</p>
<ul>
<li>计算机基础知识。比如我知道进程和线程的区别，但是我不知道其运行的原理</li>
<li>算法和数据结构。算法和数据结构对于编码能力的进阶非常重要</li>
<li>复杂业务的实践</li>
</ul>
<p>上述三点是我仔细总结自己在面试过程中暴露的三个主要问题，那么接下来的时间我将会就这几个问题专门突破</p>
<ul>
<li>计算机基础知识 =&gt; CSSAPP</li>
<li>算法 =&gt; 剑指offer(已完成)/leetcode做题+系统整理</li>
<li>复杂业务 =&gt; 找一个复杂业务/自己实施从想法到落地</li>
</ul>
<h1 id="关于知识输出"><a href="#关于知识输出" class="headerlink" title="关于知识输出"></a>关于知识输出</h1><p>之前写了一篇文章讲自己对知识输出的思考，最近又有了一些新的思考。我自己平时因为加入社区不多，也不可能说有事没事上技术网站上看有没有新的热点技术（网站文章质量参差不齐也是一个原因），这种情况下，推送式的服务就显得尤为重要了，目前我摄入知识性文章最多的还是公众号和微博，掘金和InfoQ只是闲暇时看一下，毕竟轮询的效率摆在这哈哈哈。话说回来，我自己目前阶段不会开公众号的，以后想法会不会变再另说，但是我必须承认公众号是一个非常有效的知识摄入手段</p>
<p>再说说自己目前的知识输出计划吧，自己的知识输出也是历经多个平台，从最开始的在onenote上以笔记的形式记录，到个人博客，再到github仓库，可以说有一定自己的心得体会，个人博客是个非常好的平台，它不仅可以用于记录技术，也可以记录生活，我觉得部分层面上它可以支撑起一个精神自留地的作用，但是坏处是略微有点零散，不适合做系统知识的整理，所以我后来选择了docsify和自己写的插件的组合来整理系统知识，比如算法，比如前端知识，但是这样其实也有缺陷，因为这样只适合系统的开源知识，一些比如业务知识或者日常的记录，其实并不适合以文档的形式记录。我个人不支持直接在github上维护，因为这样阅读体验会很差（但是好像有github issue转blog的工具），不过还是不推荐，docsify可以直接在线看，效率也很可以</p>
<p>春招期间，神三元的经历深深打动了我，让我明白了自己目前其实还是处于舒适区，还需要学习的东西有很多很多，还需要继续努力</p>
<h1 id="关于GTD"><a href="#关于GTD" class="headerlink" title="关于GTD"></a>关于GTD</h1><p>自己的GTD一直在变，最开始是onenote，后来转奇妙清单，最近因为在用MWeb，所以就用MWeb做GTD，MWeb写文档非常爽，但是其启动慢，多端同步慢，我已经逐渐感觉到其局限性，前几天用了滴答清单，社区评价还可以，但是说实话我自己使用是怎么都不顺手，于是想着重新用回奇妙清单，发现奇妙清单转移到微软的Todo了，下载之后，发现，非常好用！</p>
<p>想了一个模式，即todo的事都记录在微软Todo上，然后每周周末的时候再在MWeb在总结做存档，毕竟微软的那个没有存档的功能</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>{}&lt;3表达式的返回值什么</title>
    <url>/2020/01/02/3%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>在看红宝书的时候，测试{}&lt;3时，发生了出乎意料的返回结果…</p>
<a id="more"></a>
<p>今天系统重新巩固红宝书，在词法的操作符版块，看到了关系操作符，兴致上来了自己测试了几个用例</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">"23"</span> &lt; <span class="string">"3"</span> <span class="string">//</span> <span class="literal">true</span></span><br><span class="line"><span class="string">"a"</span> &lt; 1 <span class="string">//</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们先来看看红宝书上对该操作符的描述</p>
</blockquote>
<ul>
<li>如果两个操作数都是数值类型，则进行数值比较</li>
<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值</li>
<li>如果一个操作数是数值，则将另外一个转化为数值，然后再比较</li>
<li>如果一个操作符是对象，则调用valueOf，用得到的结果按照前面的规则执行比较，如果没有valueOf方法或者返回的值不是基本类型，则用toString方法</li>
<li>如果一个操作数是NaN则返回false，因为NaN不能比较</li>
</ul>
<p>那么，我们来看一下<code>{}&lt;3</code>这个表达式，3是数值类型，那么我们就对另外一个值操作，先调用valueOf操作,返回{}不是基本数据类型，则调用toString方法，返回”[object Object]”是基本类型,现在变成了一个数值3和一个字符串”[object Object]”进行该操作,我们对字符串进行强制类型转换，转化为NaN，那么实际应该是NaN &lt; 3,返回false才对，但是在chrome浏览器上则是抛出未知语法错误，我就产生了巨大的疑惑，难道是我哪一步推导产生了错误？</p>
<p>打开vsc写了一个脚本如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">	valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"o1 valueOf"</span>)</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	&#125;,</span><br><span class="line">	toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"o1 toString"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"[object Object]"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o1 &lt; <span class="number">3</span>) </span><br><span class="line"><span class="comment">// o1 valueOf</span></span><br><span class="line"><span class="comment">// o1 toString</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>我自己在这里模拟了一个object，但是为什么在node下就没有报错呢？我又测试了一下更简单直接的版本</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(&#123;&#125; &lt; <span class="number">3</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>到这里才恍然大悟，原来之前的语法报错是chrome浏览器自己做的手段，跟ECMAScript规范没有关系</p>
<p>但是也要注意对象在这里的处理情况，并不是对象调用[ToPrimitive]属性直接作为返回值，而是将返回值再带入规则中，可能还要进行第二轮的类型转换</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">var o1 = &#123;</span><br><span class="line">	valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"o1 valueOf"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"1"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"o1 toString"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"a"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var o2 = &#123;</span><br><span class="line">	valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"o2 valueOf"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">	&#125;,</span><br><span class="line">	toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"o2 toString"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o1 &lt; o2)</span><br><span class="line"><span class="regexp">//</span> o1 valueOf </span><br><span class="line"><span class="regexp">//</span> o2 valueOf</span><br><span class="line"><span class="regexp">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上例中，”1”和2比较，套用规则，再将”1”转换成1之后进行比较</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">var o1 = &#123;</span><br><span class="line">	valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"o1 valueOf"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;,</span><br><span class="line">	toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"o1 toString"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"a"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var o2 = &#123;</span><br><span class="line">	valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"o2 valueOf"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"a"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"o2 toString"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o1 &lt; o2)</span><br><span class="line"><span class="regexp">//</span> o1 valueOf </span><br><span class="line"><span class="regexp">//</span> o2 valueOf</span><br><span class="line"><span class="regexp">//</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>上例中1和”a”比较，”a”转换为NaN，则返回false</p>
]]></content>
      <categories>
        <category>技术细节</category>
      </categories>
  </entry>
  <entry>
    <title>Atom改造计划</title>
    <url>/2017/10/19/Atom%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<blockquote>
<p>之前写前端一直使用的是<code>webstorm</code>,这个ide很好，功能也集成得不错，但是缺点太显著那就是慢，启动慢，打字有时候还会卡帧，这导致我不得不寻找一个轻量级的替代品，这次我考虑的有<code>vsc</code>和<code>atom</code>，最终还是决定使用atom，理由就是好看且顺手。我从今天上午开始到现在已经下载了很多好用的插件，写了这篇博客来梳理一下思绪</p>
</blockquote>
<a id="more"></a>
<h1 id="关于atom"><a href="#关于atom" class="headerlink" title="关于atom"></a>关于atom</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>atom是<code>github</code>出版的编辑器，插件也非常丰富。<a href="https://atom.io/" target="_blank" rel="noopener">官网</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://www.cnblogs.com/fuhuixiang/p/4840866.html" target="_blank" rel="noopener">1</a></li>
<li><a href="https://github.com/shery15/awesome-atom-packages/blob/master/README-zh.md" target="_blank" rel="noopener">2</a></li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>UI好看(感觉比spacemacs还好看)<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1508417989030.png" alt></li>
<li>前端友好</li>
<li>插件市场简便且强大</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在介绍atom配置之前首先需要更改一下源（参考<a href="http://blog.csdn.net/qianghaohao/article/details/52331432" target="_blank" rel="noopener">这篇文章</a>），我最开始的时候就没有改，下载速度非常慢而且易出错，f**kGFW！</p>
<p>首先找到这个路径<code>\Users\用户名\.atom</code>，在这个下面新建一个<code>.apmrc</code>的文件，代码如下</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">registry</span>=https://registry.npm.taobao.org/  </span><br><span class="line"><span class="attr">strict-ssl</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>也就是把源换成淘宝源（brew，npm，pip也应该同理换一下，当然这就不是本文的讨论范围了）</p>
<h2 id="atom安装插件"><a href="#atom安装插件" class="headerlink" title="atom安装插件"></a>atom安装插件</h2><h3 id="应用内打开"><a href="#应用内打开" class="headerlink" title="应用内打开"></a>应用内打开</h3><p>我更偏爱这种方法，一是简单，而是内容也更丰富（可以看到评价和简介）mac下直接按<code>command + ,</code>，在里面找到<code>install</code>栏即可</p>
<h3 id="终端安装"><a href="#终端安装" class="headerlink" title="终端安装"></a>终端安装</h3><p><code>apm install + 插件名</code>，不太推荐这种方法，不要为了装逼冒这个风险。python，node都可以通过终端安装包，但atom没必要，应用内更丰富且易定制。</p>
<h2 id="atom快捷键"><a href="#atom快捷键" class="headerlink" title="atom快捷键"></a>atom快捷键</h2><ul>
<li><code>command+\</code> toggle文件夹</li>
<li><code>command+p</code> 查找文件</li>
<li><code>command+enter</code>跳转到下一行</li>
<li><code>command+k  + 方向键</code>分屏</li>
</ul>
<h1 id="插件篇"><a href="#插件篇" class="headerlink" title="插件篇"></a>插件篇</h1><h2 id="主题插件"><a href="#主题插件" class="headerlink" title="主题插件"></a>主题插件</h2><h3 id="atom-material-ui"><a href="#atom-material-ui" class="headerlink" title="atom-material-ui"></a>atom-material-ui</h3><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ul>
<li>git-plus<br>这个方便git使用，我之后写git的文章时会结合这个来说的（主要是方便我这种不记命令的懒人XD）<br>##markdown<br>说一下，我最开始的时候也是想把atom改造成一个markdown编辑器的，后来尝试了很多插件，最后发现还是<code>macdown</code>好用，配色鲜明（这个很重要）+空间大（屏幕小的痛）</li>
</ul>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="project-manager"><a href="#project-manager" class="headerlink" title="project-manager"></a>project-manager</h3><p>暂时没有搞明白</p>
<h3 id="file-icons"><a href="#file-icons" class="headerlink" title="file-icons"></a>file-icons</h3><p>为文件添加各种icon，方便识别</p>
<h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>主要就是呈现跟手机端一样，当tab栏过多时，按下<code>comamnd+shift+e</code>查看所有的tab</p>
<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><h3 id="emmet"><a href="#emmet" class="headerlink" title="emmet"></a>emmet</h3><p>不解释</p>
<h3 id="auto-completepaths"><a href="#auto-completepaths" class="headerlink" title="auto-completepaths"></a>auto-completepaths</h3><p>文件路径补全</p>
<h3 id="autocomplete-modules"><a href="#autocomplete-modules" class="headerlink" title="autocomplete-modules"></a>autocomplete-modules</h3><p>自动补全模组名</p>
<h3 id="atom-ternjs"><a href="#atom-ternjs" class="headerlink" title="atom-ternjs"></a>atom-ternjs</h3><p>ES5, ES6, ES7, Node.js, jQuery, Angular 等等 js 代码自动补全</p>
<h3 id="css-snippets"><a href="#css-snippets" class="headerlink" title="css-snippets"></a>css-snippets</h3><h2 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h2><h3 id="linter"><a href="#linter" class="headerlink" title="linter"></a>linter</h3><p>这是一个系列，主要作用是代码优化和检测</p>
<h3 id="linter-jshint"><a href="#linter-jshint" class="headerlink" title="linter-jshint"></a>linter-jshint</h3><p>基于 jshint 的 JavaScript 语法检查插件</p>
<h3 id="linter-eslint"><a href="#linter-eslint" class="headerlink" title="linter-eslint"></a>linter-eslint</h3><p>基于 ESLint 的 JavaScript 语法检查插件</p>
<h3 id="linter-htmlhint"><a href="#linter-htmlhint" class="headerlink" title="linter-htmlhint"></a>linter-htmlhint</h3><h3 id="linter-jsonhint"><a href="#linter-jsonhint" class="headerlink" title="linter-jsonhint"></a>linter-jsonhint</h3><h3 id="linter-csslint"><a href="#linter-csslint" class="headerlink" title="linter-csslint"></a>linter-csslint</h3><h2 id="前端细节"><a href="#前端细节" class="headerlink" title="前端细节"></a>前端细节</h2><h3 id="autoprefixer"><a href="#autoprefixer" class="headerlink" title="autoprefixer"></a>autoprefixer</h3><p>这个是用来解决兼容性前缀的，你只需要写完之后，使用控制命令调用<code>autofixer</code>即可，非常方便</p>
<h3 id="open-in-browser"><a href="#open-in-browser" class="headerlink" title="open-in-browser"></a>open-in-browser</h3><p>按下组合键<code>control+alt+o</code>，即可使用默认浏览器打开当前html（默认是chrome），当然也可以通过底栏的按钮来打开html</p>
<h3 id="hyperclick"><a href="#hyperclick" class="headerlink" title="hyperclick"></a>hyperclick</h3><h3 id="js-hyperclick"><a href="#js-hyperclick" class="headerlink" title="js-hyperclick"></a>js-hyperclick</h3><h2 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h2><h3 id="color-picker"><a href="#color-picker" class="headerlink" title="color-picker"></a>color-picker</h3><p><code>conmand+shift+c</code>直接显示出选色器，非常方便！！！！</p>
<h3 id="docblockr"><a href="#docblockr" class="headerlink" title="docblockr"></a>docblockr</h3><p>这个功能<strong>非常强大</strong>，可定制型也比较高…我琢磨了很久也只挖掘了几个我目前暂时能用到的。主打功能：高级注释。<code>/*</code>或<code>/**</code>之后按下<code>tab</code>，就能自动转化成批量注释。另外，在函数前使用这个功能，就能自动衍生出有关函数的相关注释</p>
<h3 id="minimap"><a href="#minimap" class="headerlink" title="minimap"></a>minimap</h3><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1508423304575.png" alt><br>缩略图</p>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>atom</tag>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY Vue UI组件库之路</title>
    <url>/2019/05/31/DIY-Vue-UI%E7%BB%84%E4%BB%B6%E5%BA%93%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<blockquote>
<p>写vue的项目多了，感觉越来越需要自己从头开始写一个UI组件库来系统地升华自己的能力</p>
</blockquote>
<a id="more"></a>
<h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><ul>
<li>vue</li>
<li>vuex</li>
<li>vueRouter</li>
<li>less</li>
</ul>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>首先使用vue-cli3.x来构建项目，因为是特别正式的项目，不是平时的业务开发，所以加入了单测和eslinit</p>
<h2 id="测试了下npm发布包的功能"><a href="#测试了下npm发布包的功能" class="headerlink" title="测试了下npm发布包的功能"></a>测试了下npm发布包的功能</h2><p>首先在npm官网注册账号，然后在本地项目文件夹下<code>npm login</code>,然后<code>npm publish --access public</code></p>
<p>注意npm的淘宝源是不行的，最好是使用<code>nrm</code>来管理npm源。常用操作<code>nrm ls</code>，<code>nrm use ***</code></p>
<h2 id="新建examples文件夹"><a href="#新建examples文件夹" class="headerlink" title="新建examples文件夹"></a>新建examples文件夹</h2><p>做组件库跟业务开发不一样，它主要的文件全部用来放库，展示页面应该另起一个文件夹，在根目录下新建examples文件夹，并且加入<code>main.js</code>,<code>app.vue</code>,<code>index.html</code></p>
<p>之前习惯的事用vuecli2.x，但是毕竟3.x才是潮流，这次还是用了3.x</p>
<p>在<code>package.json</code>里配置serve的属性， 将原来的serve改为<code>&quot;serve&quot;: &quot;vue-cli-service serve --open ./examples/main.js&quot;,</code>，这样就指定了新的入口文件，测试一下，ok</p>
<h2 id="文档的编写"><a href="#文档的编写" class="headerlink" title="文档的编写"></a>文档的编写</h2><p>直接采用<a href="https://github.com/docsifyjs/docsify" target="_blank" rel="noopener">docsify</a></p>
<p>配置挺复杂的，折腾了一天</p>
]]></content>
  </entry>
  <entry>
    <title>Hexo 绑定个性域名</title>
    <url>/2017/10/11/Hexo-%E7%BB%91%E5%AE%9A%E4%B8%AA%E6%80%A7%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<blockquote>
<p>每次都通过githubpages来访问可能稍显冗长，而且github最近越来越不稳定，几次我都以为是被墙了。在偷懒心的作用下我开始了一场有惊无险的更换域名之旅…</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于<code>github pages</code>+<code>hexo</code>+<code>个性域名</code>的教程网上很多，我这里只列出我自己的亲身经历，以供参考</p>
<h1 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h1><p>域名的购买有很多途径</p>
<ul>
<li><a href="https://wanwang.aliyun.com/?spm=a2c0j.8903112.388261.221.5348e51fe828vr" target="_blank" rel="noopener">阿里云</a></li>
<li><a href="https://dcc.godaddy.com/" target="_blank" rel="noopener">godaddy</a></li>
</ul>
<p>以上两个都可以,随便选一个自己喜欢的就可以了。首先进入上述链接，在搜索栏里输入自己理想的域名，如果未被抢注就可以购买之，一般价格在几十块一年。我最终选用的是<a href="https://dcc.godaddy.com/" target="_blank" rel="noopener">godaddy</a>的，以下的教程也以其为例。（其实阿里云更好，可以域名+解析一条龙）</p>
<h1 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h1><p>如果是买的阿里云的域名的话，应该可以直接在<code>我的产品</code>里找到解析选项，我这里虽然购买的是<code>godaddy</code>的域名，但是并没有使用它提供的DNS解析服务，因为<code>dodaddy</code>是一个新加坡的网站，因为某些不可描述的原因，为了稳定性着想，最好是采用国内的域名解析服务，我采用的是<a href="www.dnspod.cn">DNSPod</a>，这个是腾讯的服务，而且是免费的</p>
<h1 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h1><p><img src="http://img.hb.aicdn.com/d1afe5b8fbf2cfd74fc9394f15092c7c1c7a5ef91181c-0vZed9_fw192" alt></p>
<p>在这里点击添加域名，输入你刚购买的个性域名，如我的就是<a href="prozac-laputa.com">prozac-laputa.com</a></p>
<p>点进去按这样设置</p>
<p><img src="http://img.hb.aicdn.com/1863242101714f5ed882842add7328112b804acb2ad95-SmHU1s_fw192" alt></p>
<p>其中，第一项第二项为gituhub的ip，三四项无法修改，第五项，类型设置为<code>CNAME</code>,值设置为githubpages的链接如<code>username.github.io</code></p>
<h1 id="设置域名服务器"><a href="#设置域名服务器" class="headerlink" title="设置域名服务器"></a>设置域名服务器</h1><p>因为我这个购买域名的网站和域名解析的服务商不是一家，所以需要在<code>域名商</code>也就是<code>godaddy</code>这里设置<code>域名服务器</code>。</p>
<p><img src="http://img.hb.aicdn.com/5e8d8502cd63107258a3096f1b21d8b79cd4fded23f88-fSsMGp_fw192" alt></p>
<blockquote>
<p>注意，上述这个页面是要邮箱验证之后才会显示。我其实一星期前就买了这个网站，但是发现一直无法修改，突然在另外一个博客里看到域名购买之后需要马上验证，要不然会有被<strong>封锁的风险</strong>。急忙打开邮箱，完成了验证</p>
</blockquote>
<p>将域名服务器的两个值分别设置为我图中的设置即可</p>
<h1 id="设置github的CNAME"><a href="#设置github的CNAME" class="headerlink" title="设置github的CNAME"></a>设置github的CNAME</h1><p>需要在github里你这个项目的根目录下创建一个名为<code>CNAME</code>的文件（注意没有后缀），里面就写上你购买的域名即可，但是这样麻烦的是每次<code>deploy</code>之后就需要重新建立一次，非常麻烦。实际上，只需要在你本地的<code>source</code>（hexo的source，不是主题的source）里新建这个<code>CNAME</code>即可，这样就可以每次自动生成CNAME文件</p>
<h1 id="我的经历"><a href="#我的经历" class="headerlink" title="我的经历"></a>我的经历</h1><p>设置完上面的各个步骤之后，理论上应该只需要等待即可。但是我因为是第一次设置比较紧张，经历了一个非常惊心动魄的过程。我在完成上述步骤之后，突然发现不仅新网站打不开，原来的githubpages页面也自动定向到了<code>yoursite.com</code>这个页面，把我吓了一跳，可是当我把<code>DNSPod</code>的解析服务给停了之后，我的githubpages还是没有恢复！也就是说，还有dns服务商在解析我这个网址!使用网上的解析跟踪服务时发现，<code>github.io</code>这个后缀的根本解析不到，也就是说暂时找不到谁在解析我github域名.瞬间有种博客废掉了的感觉，只能自己本地访问的博客有什么用…我甚至还有换个github账号的冲动，还好等待了一段时间之后我发现新域名可以访问了，原来的链接依旧链接为<code>yoursite.com</code>，这才明白这就是解析本身的问题，相当于dns服务器会把我的githubpages链接解析成新地址的ip，但是新地址还没有部署好，所以就会出现之前那样的错误，至于为什么会是<code>yoursite.com</code>，我也不太清楚，可能是因为我最开始的时候CNAME里的值为默认的<code>yoursite.com</code>没有修改（但是我还是没有想明白为什么在停掉dns解析服务之后还是会出现那样的错误…）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>遇到问题不要轻易放弃，要尽可能地想办法解决（本来我计划是之后找学校计院的老师问一下的…）</p>
</blockquote>
]]></content>
      <categories>
        <category>技术细节</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>LBS应用中的定位问题</title>
    <url>/2017/11/03/LBS%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>这个问题是我在做一次LBS课程设计时遇到的问题，前后纠结了我好久。最后终于得以解决，畅快之余，还是想将整个过程记录下来，以备将来遇到了类似的问题来回顾</p>
</blockquote>
<a id="more"></a>
<h1 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h1><h2 id="问题的缘由"><a href="#问题的缘由" class="headerlink" title="问题的缘由"></a>问题的缘由</h2><p>大四下的LBS课程设计中，我设想的方案是一款签到应用。当我前后忙活了近三个星期终于把这款应用完工时，却发现其定位系统效果很不好。我总共是做了三个版本，一个pc一个演示用移动端，还有一个是发布在服务器上的移动端。三个版本的定位精度都不尽如人意。在宿舍还好，时好时坏，但是在教室给老师演示时却屡屡失误。众所周知，LBS应用的核心就在于定位上，这个问题不解决，整个应用都白搭。</p>
<h2 id="定位的原理"><a href="#定位的原理" class="headerlink" title="定位的原理"></a>定位的原理</h2><p>要想彻底解决这个问题，就需要首先搞明白它运作的原理。我是在高德地图的<a href="http://lbs.amap.com/api/javascript-api/summary/" target="_blank" rel="noopener">api</a>的基础上进行二次开发的（因为我在比较了国内现行的比较大型的类似产品之后觉得高德的api文档做得最好）。我们首先来看一下高德官方对它定位原理的解释</p>
<blockquote>
<p>JS-API的Geolocation定位插件，融合了HTML5 Geolocation定位接口、精确IP定位服务，以及安卓定位sdk定位。其中与安卓定位sdk的结合使用适用于开发安卓系统的H5应用，需同时使用安卓定位sdk和JS-API。</p>
<p>在<strong>PC端</strong>，因为原生接口成功率很低，JS-API会优先调用精确IP定位服务，在IP定位失败的时候，尝试使用浏览器原生定位接口进行定位，如果原生定位接口也定位失败，则返回error事件或回调error信息。定位成功之后我们会对浏览器定位的经纬度结果进行向高德坐标的转化，并对所有有效定位结果融合地址信息后返回complete事件或者回调complete信息。</p>
<p>在<strong>移动端</strong>，如果开发者开启了sdk辅助定位，那么安卓手机上我们会优先尝试调用sdk的定位接口，失败之后优先调用浏览器原生定位接口进行定位，浏览器定位失败之后尝试进行精确IP定位，如果以上三种定位全部尝试失败则返回error事件或回调error信息，否则和PC端的一样，定位成功之后进行高德坐标转化和地址融合。</p>
</blockquote>
<p>也就是说，本质上高德定位有两套方案，一个是<code>ip定位</code>，另一个是<code>html5定位</code>。在pc端，优先调用ip（精度差，但一般都能调到），移动端则完全相反。下面是<code>html5定位</code>的解释（实际上就是一个杂糅）</p>
<blockquote>
<p>geolocation的位置信息来源包括GPS、IP地址、RFID、WIFI和蓝牙的MAC地址、以及GSM/CDMS的ID等等。规范中没有规定使用这些设备的先后顺序，在HTML5的实现中，手机等移动设备当然优先使用GPS定位，而笔记本和部分平板，最准的定位是WIFI，至于网线上网的台式机，一般就只能使用IP来定位了，这个准确度最低。</p>
</blockquote>
<h2 id="对于目前情况的剖析"><a href="#对于目前情况的剖析" class="headerlink" title="对于目前情况的剖析"></a>对于目前情况的剖析</h2><h3 id="我目前的设置"><a href="#我目前的设置" class="headerlink" title="我目前的设置"></a>我目前的设置</h3><p>将定位里设置一个参数<code>geoLocationFirst</code>设置为true之后，现在我的应用的定位策略变成了无论是pc还是移动端，都是优先<code>h5</code>，然后是<code>ip</code></p>
<h3 id="我目前的定位结果"><a href="#我目前的定位结果" class="headerlink" title="我目前的定位结果"></a>我目前的定位结果</h3><p>对于pc端和演示版移动端（也是在pc上运行），在宿舍里80%的概率能够h5定位成功，这种情况下，地理位置还是比较精确的。<strong>但是</strong>，对于部署在服务器上的移动端版本，始终定位失败。当我把移动端的ip定位禁掉之后，它竟然什么数据都定位不了了。之后我把error给alert出来了，问题描述为</p>
<blockquote>
<p>geoLocation permission denied</p>
</blockquote>
<p>关于这个问题的错误具体情况描述可以参考<a href="http://www.cnblogs.com/milkmap/p/6138519.html" target="_blank" rel="noopener">这篇文章</a>，总之我的问题出现在<code>chrome和safari等浏览器不再支持来自非安全域的定位请求，但是它们不会拒绝类似localhost形式的文件的请求</code>。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>网上给出来的解决方法是升级站点至<code>https</code>，这又是一项浩大的工程，不仅是站点升级麻烦，另外一个原因是我这个HTML里有很多http的资源（比如图床和一些外部加载的js），而且这些资源都不太可能更改为https协议的，这意味着，如果我把我自己的网站更改为https，这些http的外部资源都会被block掉（我自己试了一下，用https来访问，确实如此）。问题到此仿佛一下子陷入了绝境，直到我看到了<a href="http://www.cnblogs.com/jishuzhaichen/p/5933660.html" target="_blank" rel="noopener">这篇文章</a>，这篇文章里提到了这样一段话</p>
<blockquote>
<p>我这时候有点绝望了，疯狂的找解决方案，最后还真让我找到了——腾讯地图。我一直觉得腾讯很坑爹，网页游戏都被人骂，但是这次不得不感谢它。腾讯地图也是使用html5定位技术但人家是https请求，所以腾讯抓住了这个机会，建立一个类似中转站的请求转发（我个人的理解）。我们的请求会到腾讯的中转站（https）然后在（https）返回给我们这样我们的请求就是https请求IOS用户端就会为我们的定位提供地理位置定位服务了，这次测试终于过了</p>
</blockquote>
<p>这个时候就体现出功能板块化的好处了，如果腾讯地图真的如它所言能够帮我解决这个问题的话，我完全可以只把定位这个版块的功能交给腾讯来处理。</p>
<p>这里不得不吐槽一句，腾讯地图api的<a href="http://lbs.qq.com/tool/component-geolocation.html" target="_blank" rel="noopener">官网</a>虽然UI挺不错的，但是api文档真的是水，连百度也不如。完全没有高德那么清晰易懂。随便梳理一下都有下面一些缺点：    </p>
<ul>
<li>官网上只有干巴巴几个例子，连可编辑的demo都没有</li>
<li>接口没有具体的参数描述</li>
<li>error回调函数没有任何参数输入（这意味着不能知道错误类型）</li>
<li>调用位置服务时，不知道为什么总是调用error的回调函数</li>
</ul>
<p>正当我绝望时，我突然发现它们还有一个<a href="http://bbs.map.qq.com/forum-69-1.html" target="_blank" rel="noopener">官方论坛</a>，我不得不说，虽然腾讯地图官方的api写得烂，但是它们这个论坛是真的不错，比如我在论坛里才明白了（我看到一个人出现了跟我一样的错误）</p>
<blockquote>
<p>腾讯位置定位组件这个js的api是用来给移动端准备的！pc上根本运行不了</p>
</blockquote>
<p>真是要吐血了，这么重要的消息为什么不在官网上说明，我就奇怪为什么不管怎么定位最后都是调用onError函数。不过还是有好消息的，腾讯地图和高德地图的坐标系都是通用的，不需要转换。最后，我战战兢兢地<code>git push</code>了一下，在手机上测试了一下，发现定位效果非常好。但是还是要注意，这个只针对移动端有效，pc端的定位还是存在很大的问题。</p>
<h1 id="后续的问题"><a href="#后续的问题" class="headerlink" title="后续的问题"></a>后续的问题</h1><p>我又在室外测试了一天，发现一半的情况下，腾讯提供的h5定位效果还不错，但是又有大概一半的情况下，定位数据出现了延后的情况，也就是说现在定位的是上一个地点的定位点。我想着我的代码里好像没有这样的设定，上<a href="http://bbs.map.qq.com/forum-69-1.html" target="_blank" rel="noopener">论坛</a>搜了一下，很多人也反映这个问题。应该是h5定位的技术特点，这个技术设定如果此时h5获取定位获取不到，就会返回上一次缓存的成功定位的地址信息。这个就比较尴尬了，因为这意味着如果你在一个定位效果很差的地方（比如食堂，我在食堂测试时，无论是网页的高德地图还是我自己写的程序定位都是失败），那么你无论如何都不能自辨清白了，想了一下，比较好的解决方案是增加一个定时上传信息的功能，在后台每隔一段时间就获取一次位置信息，保证上一次成功定位的地点和你现在的位置接近。</p>
]]></content>
      <categories>
        <category>技术细节</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>定位</tag>
        <tag>LBS</tag>
      </tags>
  </entry>
  <entry>
    <title>SICP第一章笔记</title>
    <url>/2018/06/28/SICP%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>第一章的内容相对来说比较基础 </p>
</blockquote>
<a id="more"></a>
<h1 id="1-应用序和正则序"><a href="#1-应用序和正则序" class="headerlink" title="1.应用序和正则序"></a>1.应用序和正则序</h1><ul>
<li>正则序 </li>
</ul>
<blockquote>
<p>首先不计算运算对象的值，首先展开原有的式子，直到实际需要的时候再计算。缺陷是可能有重复计算</p>
</blockquote>
<ul>
<li>应用序 </li>
</ul>
<blockquote>
<p>与正则序完全相反，首先求值，然后应用。</p>
</blockquote>
<p>大部分情况下，两种方法得到的结果都是一样的。但是大部分的解释器现在都是<code>应用序</code>。正则序一方面会比较复杂，但另一方面它也可以特别有价值</p>
<p>一个辨别正则序和应用序的例子</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1530191611264.png" alt></p>
<p>如果是正则序，则不会陷入求p的循环中，而如果是应用序则会陷入死循环</p>
<h1 id="2-迭代和递归"><a href="#2-迭代和递归" class="headerlink" title="2.迭代和递归"></a>2.迭代和递归</h1><p>这也是我在重读SICP之前印象最深的一点，但是直到手写了几个函数之后才发现这两者之间真正的差别.</p>
<p>首先要声明，大部分情况下，迭代的效率都比递归更高。但是递归更加符合人们的直觉，即其易于理解。当我们把代码拆开之后，会发现迭代不仅占用的内存小，而且避免了很多重复计算。在处理大量数据时，建议还是使用迭代。</p>
<blockquote>
<p>对于任何递归过程的解释，所需要消耗的内存总是和过程调用的数目成正比。而迭代过程则不受影响。</p>
</blockquote>
<p>在代码结构上讲，迭代的特点我总结共<strong>3</strong>个本质特点</p>
<ul>
<li>最终需要输出的值一定是作为参数放在函数里</li>
<li>在递归中需要调用到自身函数的时候，迭代里不再通过调用自己，而是有几个调用自己的次数就在迭代的函数里增加几个新的参数。</li>
<li>迭代的版本中的判断条件一般是<code>到了某个值之后，抛出结果的参量</code></li>
</ul>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title>const,let,var</title>
    <url>/2018/09/06/const-let-var/</url>
    <content><![CDATA[<p>一天看某位大佬的代码时，发现里面一个var也没有，当时就觉得惊为天人。当然学代码不能仅仅为了酷，酷当然是激励我们敲代码的一个重要理由，但我们也应该搞清楚为什么需要这么做，以便我们以后遇到了类似的问题知道该从什么样的思路出发<br><a id="more"></a></p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1背景介绍"><a href="#1-1背景介绍" class="headerlink" title="1.1背景介绍"></a>1.1背景介绍</h2><p>const，let实际上都是<a href="http://caibaojian.com/es6/" target="_blank" rel="noopener">es6</a>的新增内容</p>
<h2 id="1-2-参考资料"><a href="#1-2-参考资料" class="headerlink" title="1.2 参考资料"></a>1.2 参考资料</h2><ul>
<li><a href="http://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="noopener">阮一峰的es6标准入门</a></li>
<li><a href="http://www.infoq.com/cn/articles/es6-in-depth-let-and-const" target="_blank" rel="noopener">深入浅出es6</a></li>
</ul>
<h1 id="2-let"><a href="#2-let" class="headerlink" title="2.let"></a>2.let</h1><h2 id="2-1-let是更完美的var"><a href="#2-1-let是更完美的var" class="headerlink" title="2.1 let是更完美的var"></a>2.1 let是更完美的var</h2><blockquote>
<p>对于绝大多数代码而言，在es6的新标准下，你应该停止上使用var，能使用let就用吧</p>
</blockquote>
<h2 id="2-2-基本用法"><a href="#2-2-基本用法" class="headerlink" title="2.2 基本用法"></a>2.2 基本用法</h2><p>它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<h2 id="2-3-不存在变量提升"><a href="#2-3-不存在变量提升" class="headerlink" title="2.3 不存在变量提升"></a>2.3 不存在变量提升</h2><h2 id="2-4-暂时性死区"><a href="#2-4-暂时性死区" class="headerlink" title="2.4 暂时性死区"></a>2.4 暂时性死区</h2><p>在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<p>暂时性死区”也意味着typeof不再是一个百分之百安全的操作。</p>
<blockquote>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
</blockquote>
<h2 id="2-5-不允许重复声明"><a href="#2-5-不允许重复声明" class="headerlink" title="2.5 不允许重复声明"></a>2.5 不允许重复声明</h2><h1 id="3-const"><a href="#3-const" class="headerlink" title="3 const"></a>3 const</h1><p>const在很多于语言都有体现，也很好理解了，即为声明一个只读的常量。一旦声明，常量的值就不能改变</p>
<h2 id="3-1-必须马上初始化"><a href="#3-1-必须马上初始化" class="headerlink" title="3.1 必须马上初始化"></a>3.1 必须马上初始化</h2><h2 id="3-2-不存在变量提升"><a href="#3-2-不存在变量提升" class="headerlink" title="3.2 不存在变量提升"></a>3.2 不存在变量提升</h2><h2 id="3-3-暂时性锁区"><a href="#3-3-暂时性锁区" class="headerlink" title="3.3 暂时性锁区"></a>3.3 暂时性锁区</h2><h2 id="3-4-const的本质"><a href="#3-4-const的本质" class="headerlink" title="3.4 const的本质"></a>3.4 const的本质</h2><p>对于简单数据类型const很好理解，但是对于符合类型的数据（数组和对象），只能保证那个变量所对应的地址不变，但对象本身还是可以修改的。</p>
]]></content>
      <categories>
        <category>技术细节</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>dat.gui库详解</title>
    <url>/2018/02/28/dat-gui%E5%BA%93%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>最近在做可视化方面的毕设，经常要用到dat.gui这个库，经常需要查比较麻烦，干脆自己写一篇攻略来认真梳理一下这个库.</p>
</blockquote>
<a id="more"></a>
<h1 id="关于dat-gui-js"><a href="#关于dat-gui-js" class="headerlink" title="关于dat.gui.js"></a>关于dat.gui.js</h1><p>这个是一个辅助<strong>可视化交互</strong>的库。<a href="https://github.com/dataarts/dat.gui" target="_blank" rel="noopener">官网</a>。主要功能是帮助我们<code>实时修改参数</code>，提高实验或者可视化的效果。它大概长这个样子</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1519780956339.png" alt></p>
<p>最开始接触这个库是在去年学习threejs的时候，后来看到很多可视化的开源项目里都用到了它，这足以证明其魅力。</p>
<p>细数了一下，优点有以下：</p>
<ul>
<li>好看</li>
<li>api简单易用</li>
<li>功能齐全</li>
</ul>
<p>基本没有任何缺点，足以应对任何中小型的可视化项目，当然如果是大型的项目最好还是从头造轮子比较合适。</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="1-首先在html开头引入该js文件"><a href="#1-首先在html开头引入该js文件" class="headerlink" title="1.首先在html开头引入该js文件"></a>1.首先在html开头引入该js文件</h3><p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;../libs/dat.gui.js&quot;&gt;&lt;/script&gt;</code></p>
<h3 id="2-然后新建一个对象（字典），用来存储你需要修改的参数。"><a href="#2-然后新建一个对象（字典），用来存储你需要修改的参数。" class="headerlink" title="2.然后新建一个对象（字典），用来存储你需要修改的参数。"></a>2.然后新建一个对象（字典），用来存储你需要修改的参数。</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ASSETS = new function()&#123;</span><br><span class="line">            <span class="keyword">this</span>.speed = <span class="number">0.01</span>;</span><br><span class="line">            <span class="keyword">this</span>.numParticles = <span class="number">5000</span>;</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">40</span>;</span><br><span class="line">            <span class="keyword">this</span>.lineWidth = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">this</span>.opacityDelta = <span class="number">0.1</span>;</span><br><span class="line">            <span class="keyword">this</span>.frequency = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">this</span>.acceleratable = <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-新建gui对象，并且加入之前对象里的参数"><a href="#3-新建gui对象，并且加入之前对象里的参数" class="headerlink" title="3.新建gui对象，并且加入之前对象里的参数"></a>3.新建gui对象，并且加入之前对象里的参数</h3><p><code>gui.add(ASSETS,&#39;age&#39;, 20, 100)</code></p>
<p>add函数第一个参数表示对象，第二个是对象的属性，第三个，第四个是该对象浮动的范围</p>
<h3 id="4-得到结果"><a href="#4-得到结果" class="headerlink" title="4.得到结果"></a>4.得到结果</h3><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1519781700136.png" alt></p>
<h2 id="各种类型的控件"><a href="#各种类型的控件" class="headerlink" title="各种类型的控件"></a>各种类型的控件</h2><h3 id="1-数字型"><a href="#1-数字型" class="headerlink" title="1.数字型"></a>1.数字型</h3><h4 id="无范围，则表现为input"><a href="#无范围，则表现为input" class="headerlink" title="无范围，则表现为input"></a>无范围，则表现为input</h4><p><code>gui.add(ASSETS,&#39;age)</code></p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1519781911579.png" alt></p>
<h4 id="有范围，则表现为滑块"><a href="#有范围，则表现为滑块" class="headerlink" title="有范围，则表现为滑块"></a>有范围，则表现为滑块</h4><p><code>gui.add(ASSETS,&#39;age&#39;, 20, 100)</code></p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1519781700136.png" alt></p>
<h4 id="可以设置步长"><a href="#可以设置步长" class="headerlink" title="可以设置步长"></a>可以设置步长</h4><p><code>gui.add(ASSETS,&#39;age&#39;, 20, 100).step(1)</code></p>
<h4 id="如果数字类型有限，则可以以下拉框的形式进行选择"><a href="#如果数字类型有限，则可以以下拉框的形式进行选择" class="headerlink" title="如果数字类型有限，则可以以下拉框的形式进行选择"></a>如果数字类型有限，则可以以下拉框的形式进行选择</h4><p><code>gui.add(ASSETS,&#39;age&#39;,{&#39;slow&#39;:20,&#39;normal&#39;:40,&#39;long&#39;:60});</code></p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1519782143202.png" alt></p>
<h3 id="2-布尔类型"><a href="#2-布尔类型" class="headerlink" title="2.布尔类型"></a>2.布尔类型</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ASSETS = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.acceleratable = <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line">gui.add(ASSETS, <span class="string">'acceleratable'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1519782309300.png" alt></p>
<h3 id="3-字符串型"><a href="#3-字符串型" class="headerlink" title="3.字符串型"></a>3.字符串型</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ASSETS = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.str = <span class="string">"str"</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line">gui.add(ASSETS, <span class="string">'str'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="4-自定义函数"><a href="#4-自定义函数" class="headerlink" title="4.自定义函数"></a>4.自定义函数</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ASSETS = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            		xxxxxxxx</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line">gui.add(ASSETS, <span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="5-颜色"><a href="#5-颜色" class="headerlink" title="5.颜色"></a>5.颜色</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ASSETS = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clr = <span class="string">'#66ccff'</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line">gui.addColor(ASSETS, <span class="string">'clr'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1519782545710.png" alt></p>
<h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>分为两个函数，<code>onChange</code>和<code>onChangeFinish</code>，这两个方法的参数是一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ASSETS = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clr = <span class="string">'#66ccff'</span>;</span><br><span class="line">            <span class="keyword">this</span>.redraw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            		<span class="built_in">console</span>.log(<span class="string">"refresh!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line">gui.addColor(ASSETS, <span class="string">'clr'</span>).onChange(ASSETS.redraw);</span><br></pre></td></tr></table></figure>
<p>这样的话，每次选中的值每次发生改动过之后就会触发redraw函数，如果你想要值修改完才触发函数的话可以选用onChangeFinish函数</p>
<h2 id="修改标签项文字"><a href="#修改标签项文字" class="headerlink" title="修改标签项文字"></a>修改标签项文字</h2><p>出现在gui中的name如果没有特殊指定的话一般是对象属性的名称，但是我们有时候为了增加辨识度可能想取更简单的名字，但是又不方便直接修改属性的名称，这个时候可以采用一个name函数</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ASSETS = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clr = <span class="string">'#66ccff'</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line">gui.addColor(ASSETS, <span class="string">'clr'</span>).name(<span class="string">'颜色'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="控制项分组"><a href="#控制项分组" class="headerlink" title="控制项分组"></a>控制项分组</h2><p>即根据功能本身对其进行分类，方便管理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ASSETS = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clr = <span class="string">'#66ccff'</span>;</span><br><span class="line">            <span class="keyword">this</span>.redraw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            		<span class="built_in">console</span>.log(<span class="string">"refresh!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line"><span class="keyword">var</span> folder1 = gui.addFolder();</span><br><span class="line">folder1.addColor(ASSETS, <span class="string">'clr'</span>).onChange(ASSETS.redraw);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
  </entry>
  <entry>
    <title>es6...运算符</title>
    <url>/2019/10/23/es6-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>很多人可能看见三个点的运算符都不知道能干什么。我从最开始的不知道，到现在知道能用来展开数据，但是你知道它的具体含义和进阶用法吗</p>
<a id="more"></a>
<h1 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a>1. 基础用法</h1><ul>
<li>展开</li>
<li>收集</li>
<li>类数组转化为数组</li>
<li>增加元素或者属性</li>
<li>合并数组/对象</li>
</ul>
<p>官方定义 =&gt;</p>
<blockquote>
<p>Spread syntax allows an iterable, such as an array expression or string, to be expanded in places where 0 or more arguments or elements are expected or an object expression to be expanded in places where 0 or more key-value pairs (for object literals) are expected.</p>
</blockquote>
<p>就是说，这个运算符可以展开为一个可迭代对象中的所有项</p>
<h2 id="1-1-展开"><a href="#1-1-展开" class="headerlink" title="1.1 展开"></a>1.1 展开</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">const</span> <span class="string">a</span> <span class="string">=</span> <span class="string">[2,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">]</span></span><br><span class="line"><span class="string">const</span> <span class="string">b</span> <span class="string">=</span> <span class="string">[1,</span> <span class="string">...a,</span> <span class="number">5</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="string">b;</span> <span class="string">//</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">5</span><span class="string">]</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-收集"><a href="#1-2-收集" class="headerlink" title="1.2 收集"></a>1.2 收集</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a, b, <span class="rest_arg">...c</span>)</span> </span>&#123;</span><br><span class="line">    console.log(a, b, c)     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 1, 2, [3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>注意，这里的运算符一定要在最后一个参数的位置或者只有它一个参数</p>
<h2 id="1-3-类数组转化为数组"><a href="#1-3-类数组转化为数组" class="headerlink" title="1.3 类数组转化为数组"></a>1.3 类数组转化为数组</h2><blockquote>
<p>类数组，即和数组非常接近，都拥有一系列元素，也有length属性,也支持按下标访问，常见的如字符串，选择器返回的结果,arguments</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test"</span>);</span><br><span class="line"><span class="keyword">const</span> array = [...nodeList];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nodeList); <span class="comment">//Result: HTMLCollection [ div.test, div.test ]</span></span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">//Result: Array [ div.test, div.test ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在es5时代，我们需要</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure>
<h2 id="1-4-增加元素或者属性"><a href="#1-4-增加元素或者属性" class="headerlink" title="1.4 增加元素或者属性"></a>1.4 增加元素或者属性</h2><blockquote>
<p>给数组新增元素</p>
</blockquote>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = [<span class="string">'KK'</span>, <span class="string">'Peter'</span>]<span class="comment">;</span></span><br><span class="line"><span class="keyword">const</span> charmander = <span class="string">'郑伊健'</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pokedex = [...pokemon, charmander]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(pokedex)<span class="comment">; </span></span><br><span class="line"></span><br><span class="line">//Result: [ <span class="string">'KK'</span>, <span class="string">'Peter'</span>, <span class="string">'郑伊健'</span> ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给对象新增属性</p>
</blockquote>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> basicSquirtle = &#123; name: <span class="string">'Squirtle'</span>, type: <span class="string">'Water'</span> &#125;<span class="comment">;</span></span><br><span class="line"><span class="keyword">const</span> fullSquirtle = &#123;</span><br><span class="line">  ...basicSquirtle,</span><br><span class="line">  species: <span class="string">'Tiny Turtle'</span>,</span><br><span class="line">  evolution: <span class="string">'Wartortle'</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(fullSquirtle)<span class="comment">; </span></span><br><span class="line"></span><br><span class="line">//Result: &#123; name: <span class="string">'Squirtle'</span>, type: <span class="string">'Water'</span>, species: <span class="string">'Tiny Turtle'</span>, evolution: <span class="string">'Wartortle'</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-合并数组-对象"><a href="#1-5-合并数组-对象" class="headerlink" title="1.5 合并数组/对象"></a>1.5 合并数组/对象</h2><blockquote>
<p>合并数组</p>
</blockquote>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">const pokemon = <span class="meta">[</span><span class="string">'Squirtle'</span>, <span class="string">'Bulbasur'</span>, <span class="string">'Charmander'</span><span class="meta">]</span>;</span><br><span class="line">const morePokemon = <span class="meta">[</span><span class="string">'Totodile'</span>, <span class="string">'Chikorita'</span>, <span class="string">'Cyndaquil'</span><span class="meta">]</span>;</span><br><span class="line"></span><br><span class="line">const pokedex = <span class="meta">[</span><span class="params">...</span>pokemon, <span class="params">...</span>morePokemon<span class="meta">]</span>;</span><br><span class="line"></span><br><span class="line">console.log(pokedex); </span><br><span class="line">//Result: <span class="meta">[</span> <span class="string">'Squirtle'</span>, <span class="string">'Bulbasur'</span>, <span class="string">'Charmander'</span>, <span class="string">'Totodile'</span>, <span class="string">'Chikorita'</span>, <span class="string">'Cyndaquil'</span> <span class="meta">]</span></span><br><span class="line"></span><br><span class="line">// 对象数组也一样：</span><br><span class="line">const pokemon = <span class="meta">[</span></span><br><span class="line">  &#123; name: <span class="string">'Squirtle'</span>, <span class="keyword">type</span>: <span class="string">'Water'</span> &#125;,</span><br><span class="line">  &#123; name: <span class="string">'Bulbasur'</span>, <span class="keyword">type</span>: <span class="string">'Plant'</span> &#125;</span><br><span class="line"><span class="meta">]</span>;</span><br><span class="line">const morePokemon = <span class="meta">[</span>&#123; name: <span class="string">'Charmander'</span>, <span class="keyword">type</span>: <span class="string">'Fire'</span> &#125;<span class="meta">]</span>;</span><br><span class="line"></span><br><span class="line">const pokedex = <span class="meta">[</span><span class="params">...</span>pokemon, <span class="params">...</span>morePokemon<span class="meta">]</span>;</span><br><span class="line"></span><br><span class="line">console.log(pokedex); </span><br><span class="line"></span><br><span class="line">//Result: <span class="meta">[</span> &#123; name: <span class="string">'Squirtle'</span>, <span class="keyword">type</span>: <span class="string">'Water'</span> &#125;, &#123; name: <span class="string">'Bulbasur'</span>, <span class="keyword">type</span>: <span class="string">'Plant'</span> &#125;, &#123; name: <span class="string">'Charmander'</span>, <span class="keyword">type</span>: <span class="string">'Fire'</span> &#125; <span class="meta">]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>合并对象</p>
</blockquote>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> baseSquirtle = &#123;</span><br><span class="line">  name: <span class="string">'Squirtle'</span>,</span><br><span class="line">  type: <span class="string">'Water'</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squirtleDetails = &#123;</span><br><span class="line">  species: <span class="string">'Tiny Turtle Pokemon'</span>,</span><br><span class="line">  evolution: <span class="string">'Wartortle'</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squirtle = &#123; ...baseSquirtle, ...squirtleDetails &#125;<span class="comment">;</span></span><br><span class="line">console.<span class="built_in">log</span>(squirtle)<span class="comment">; </span></span><br><span class="line">//Result: &#123; name: <span class="string">'Squirtle'</span>, type: <span class="string">'Water'</span>, species: <span class="string">'Tiny Turtle Pokemon'</span>, evolution: <span class="string">'Wartortle'</span> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-进阶"><a href="#2-进阶" class="headerlink" title="2. 进阶"></a>2. 进阶</h1><ul>
<li>deepClone</li>
<li>增加条件属性</li>
</ul>
<h2 id="2-1-复制一个嵌套对象"><a href="#2-1-复制一个嵌套对象" class="headerlink" title="2.1 复制一个嵌套对象"></a>2.1 复制一个嵌套对象</h2><p>修改克隆对象的属性时，原对象属性不变。但是原对象如果有数组或者对象类型的属性，这些属性变化时，克隆对象属性改变。因为复制过来的对象是一个引用类型</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  name: <span class="string">'Squirtle'</span>,</span><br><span class="line">  type: <span class="string">'Water'</span>,</span><br><span class="line">  abilities: [<span class="string">'Torrent'</span>, <span class="string">'Rain Dish'</span>]</span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squirtleClone = &#123; ...pokemon &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">pokemon.name = <span class="string">'Charmander'</span><span class="comment">;</span></span><br><span class="line">pokemon.abilities.push(<span class="string">'Surf'</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(squirtleClone)<span class="comment">; </span></span><br><span class="line"></span><br><span class="line">//Result: &#123; name: <span class="string">'Squirtle'</span>, type: <span class="string">'Water'</span>, abilities: [ <span class="string">'Torrent'</span>, <span class="string">'Rain Dish'</span>, <span class="string">'Surf'</span> ]</span><br></pre></td></tr></table></figure>
<p>解决方法也很简单</p>
<p>复制引用类型的数据/deepClone</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  name: <span class="string">'Squirtle'</span>,</span><br><span class="line">  type: <span class="string">'Water'</span>,</span><br><span class="line">  abilities: [<span class="string">'Torrent'</span>, <span class="string">'Rain Dish'</span>]</span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squirtleClone = &#123; ...pokemon, abilities: [...pokemon.abilities] &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">pokemon.name = <span class="string">'Charmander'</span><span class="comment">;</span></span><br><span class="line">pokemon.abilities.push(<span class="string">'Surf'</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(squirtleClone)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//Result: &#123; name: <span class="string">'Squirtle'</span>, type: <span class="string">'Water'</span>, abilities: [ <span class="string">'Torrent'</span>, <span class="string">'Rain Dish'</span> ] &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-增加条件属性"><a href="#2-2-增加条件属性" class="headerlink" title="2.2 增加条件属性"></a>2.2 增加条件属性</h2><p>实际上就是新增属性的延伸</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemon = &#123;</span><br><span class="line">  name: <span class="string">'Squirtle'</span>,</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'Water'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> abilities = [<span class="string">'Torrent'</span>, <span class="string">'Rain dish'</span>];</span><br><span class="line"><span class="keyword">const</span> fullPokemon = abilities ? &#123; ...pokemon, abilities &#125; : pokemon;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fullPokemon);</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullPokemon = &#123;</span><br><span class="line">  ...pokemon,</span><br><span class="line">  ...(abilities &amp;&amp; &#123; abilities &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="3-Refer"><a href="#3-Refer" class="headerlink" title="3. Refer"></a>3. Refer</h1><p><a href="https://mp.weixin.qq.com/s/HSyYrqfjYYh35ctpbnjrNA" target="_blank" rel="noopener">深入了解es6强大的…运算符</a></p>
]]></content>
      <categories>
        <category>技术细节</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>知识</tag>
      </tags>
  </entry>
  <entry>
    <title>gulp入门之入门</title>
    <url>/2017/10/12/gulp%E5%85%A5%E9%97%A8%E4%B9%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>之所以这篇文章取名为“入门之入门”，因为连入门都算不上，只是暂时了解一下这门技术，并且应用于我的博客的优化中。其实<code>gulp</code>很早之前就有所接触了，这次终于有机会体验一把了</p>
</blockquote>
<a id="more"></a>
<p>我的gulp学习历程比较奇葩，是首先按教程和自己摸索，使用gulp把网站优化了之后再去看gulp的有关资料的，事实证明gulp的源码非常明了，我从来没接触过的人看一眼也能明白每段代码具体是干什么的。首先还是介绍一下如何使用<code>gulp</code>优化网站吧。</p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>因为我们发现每次<code>deploy</code>都是先将<code>public</code>文件夹下的内容清理干净（事实上，public文件夹就是你上传到github上的最终内容），然后把全部文件编译生成一遍，再次生成<code>public</code>文件夹，再上传，如果博客数一旦变多，这个过程就会很慢且效率底下，我们需要<code>gulp</code>这个工具来压缩代码（这个功能是教程里提供的，事实上<code>gulp</code>能做的远不止这么些）</p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="安装gulp"><a href="#安装gulp" class="headerlink" title="安装gulp"></a>安装gulp</h2><p>在博客的<code>根目录</code>，执行以下命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> gulp -g</span><br><span class="line">$ npm <span class="keyword">install</span> gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp <span class="comment">--save</span></span><br><span class="line">$ npm <span class="keyword">install</span> gulp-babel</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的<code>gulp-babel</code>是我后来自己加的，原教程没有加，但是在之后的<code>deploy</code>会出错</p>
</blockquote>
<h2 id="新建配置文件"><a href="#新建配置文件" class="headerlink" title="新建配置文件"></a>新建配置文件</h2><p>在博客的根目录下，新建名为<code>gulp.js</code>的文件，文件内容为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="comment">// 压缩 public 目录 css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public 目录 html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">         removeComments: <span class="literal">true</span>,</span><br><span class="line">         minifyJS: <span class="literal">true</span>,</span><br><span class="line">         minifyCSS: <span class="literal">true</span>,</span><br><span class="line">         minifyURLs: <span class="literal">true</span>,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public/js 目录 js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</span><br><span class="line">        .pipe(babel())</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">    <span class="string">'minify-html'</span>,<span class="string">'minify-css'</span>,<span class="string">'minify-js'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有添加<code>babel()</code>环节时，终端会报错说压缩js文件出错，我查了一下，说是es6需要编译，那么还需要引入<code>gulp-babel</code>文件，并且在<code>gulp</code>的<code>pipe</code>里添加一个<code>.pipe(babel())</code></p>
</blockquote>
<h2 id="修改deploy-sh文件"><a href="#修改deploy-sh文件" class="headerlink" title="修改deploy.sh文件"></a>修改deploy.sh文件</h2><p>gulp的基本配置已经完成了，我们只需要在生成hexo的public文件时，使用之就可以了，具体操作是，打开<code>deploy.sh</code>文件，将其</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">hexo g <span class="meta">&amp; gulp</span></span><br></pre></td></tr></table></figure>
<p>完成，这样每次运行`deploy.sh脚本时，在生成文件都会提高效率</p>
<h1 id="关于gulp"><a href="#关于gulp" class="headerlink" title="关于gulp"></a>关于gulp</h1><p>接下来就是我对<code>gulp</code>的一些了解，看一下一位前端工作者对<code>gulp</code>的描述</p>
<blockquote>
<p>Gulp / Grunt 是工具链、构建工具，它们能够优化前端工作流程。比如自动刷新页面、combo、压缩css、js、编译less等等。使用Gulp/Grunt，然后配置你需要的插件，就可以替代手工实现自动化工作。</p>
</blockquote>
<p>我自己的理解就是是一个自动化工具，配合各种插件（几千种），能够自定义实现很多流水线工作，尤其是和<code>less</code>或者<code>sass</code>等css预编译语言配合，但是现在还不是我学习这个的最佳时机，因为我暂时平时用到这个的地方很少，等到研究生阶段做项目的时候再深入理解之。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>越学习发现需要学习的东西越多，自己掌握的还是太少了。通过这次实践之后，坚定了我学习<code>gulp</code>&amp;<code>less</code>&amp;<code>脚手架工具</code>的决心。此外，我还深切体会到了<code>懒是程序员的第一动力</code>这句话的真谛，要始终明白，程序员的首要工作是<code>创造</code>，而不是<code>重复性工作</code>。感觉好像回到了学习<code>SICP</code>的时候，当时被书里抽象了又抽象的思想震撼到了。唉，要不是被考研束缚住了，我现在就想每天抱着笔记本再买些书天天泡前端…（bu cun zai de）</p>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>js类型详解</title>
    <url>/2018/09/29/js%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>js的类型实际上是一个基本问题，但它总能在一些小的细节上给人困扰，这次就一口气把这个问题好好解决了</p>
<a id="more"></a>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">阮一峰的教程</a></li>
<li><a href="http://www.cnblogs.com/qiantuwuliang/archive/2010/01/12/1645302.html" target="_blank" rel="noopener">一个博客</a></li>
</ul>
<h1 id="js类型详解"><a href="#js类型详解" class="headerlink" title="js类型详解"></a>js类型详解</h1><blockquote>
<p>js分为基本类型和引用类型</p>
</blockquote>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型一共5种</p>
<h3 id="1-Undefined"><a href="#1-Undefined" class="headerlink" title="1.Undefined"></a>1.Undefined</h3><blockquote>
<p>使用var声明变量时，如果没有对其赋值就引用它就会产生undefined值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"></span><br><span class="line">a <span class="comment">// -&gt; undefined</span></span><br><span class="line"></span><br><span class="line">a == <span class="literal">undefined</span> <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line">c === <span class="literal">undefined</span> <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Null"><a href="#2-Null" class="headerlink" title="2.Null"></a>2.Null</h3><blockquote>
<p>从逻辑上说，null值表示一个空对象指针，这也正是使用typeof来检测null会返回object的原因</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">null</span>)) <span class="comment">// -&gt; 'object'</span></span><br></pre></td></tr></table></figure>
<h3 id="3-boolean"><a href="#3-boolean" class="headerlink" title="3.boolean"></a>3.boolean</h3><h3 id="4-number"><a href="#4-number" class="headerlink" title="4.number"></a>4.number</h3><h3 id="5-string"><a href="#5-string" class="headerlink" title="5.string"></a>5.string</h3><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h3><h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h3><h3 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h3><h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h3><h3 id="Symbol类型（es6新加）"><a href="#Symbol类型（es6新加）" class="headerlink" title="Symbol类型（es6新加）"></a>Symbol类型（es6新加）</h3><h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><blockquote>
<p>ECMAScript提供了3种特殊的引用类型 Boolean，Number，String.也就是是它们三个实际上都是function的实例罢辽</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">String</span>(<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a)) <span class="comment">// -&gt; "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(b)) <span class="comment">// -&gt; "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(c)) <span class="comment">// -&gt; "object"</span></span><br></pre></td></tr></table></figure>
<h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><h2 id="1-NaN的类型"><a href="#1-NaN的类型" class="headerlink" title="1.NaN的类型"></a>1.NaN的类型</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">NaN</span>))</span><br><span class="line"><span class="comment">// -&gt; 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Undefined和Null"><a href="#2-Undefined和Null" class="headerlink" title="2.Undefined和Null"></a>2.Undefined和Null</h3><blockquote>
<p>null表示此处不该有值，undefined表示此处应该有值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>
<h3 id="3-和-的区别"><a href="#3-和-的区别" class="headerlink" title="3.== 和 === 的区别"></a>3.== 和 === 的区别</h3><blockquote>
<p>Show code</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span> == <span class="string">"100"</span> <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">100</span> === <span class="string">"100"</span> <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-1-判断规则"><a href="#3-1-判断规则" class="headerlink" title="3.1 === 判断规则"></a>3.1 === 判断规则</h4><p>首先要等号两边类型相同，然后才是值相同</p>
<h4 id="3-2-判断规则"><a href="#3-2-判断规则" class="headerlink" title="3.2 == 判断规则"></a>3.2 == 判断规则</h4><ul>
<li>如果两边存在boolean，string，number任意两者进行比较，优先转化为数字</li>
<li>null == undefined</li>
</ul>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>npm使用指南</title>
    <url>/2018/09/27/npm%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>只要你做前端，就必定躲不开npm这个工具。这篇文章总结了npm的入门和对应的指令<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="npm是什么？"><a href="#npm是什么？" class="headerlink" title="npm是什么？"></a>npm是什么？</h2><p>要说npm是什么，首先要说<a href="http://nodejs.cn/" target="_blank" rel="noopener">node</a>是什么。</p>
<blockquote>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>
</blockquote>
<p>处于安全性等方面的考虑，原本只能存在于浏览器环境的js存在诸多限制比如IO操作，或者是读取本地文件，nodejs的存在，让js可以在系统环境下运行，这大大提升了js的发挥空间</p>
<p>npm（node package manager）顾名思义即node的包管理工具</p>
<blockquote>
<p>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。<br>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>
</blockquote>
<h1 id="npm-指令"><a href="#npm-指令" class="headerlink" title="npm 指令"></a>npm 指令</h1><p>注：</p>
<blockquote>
<p>在npm中，包（package）、模块（module）、依赖（dependency）说的都是一回事儿。</p>
</blockquote>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li><code>npm init</code> 初始化项目，其实就是创建一个package.json文件。</li>
<li><code>npm install</code> 安装所有项目依赖。</li>
<li><code>npm help xxx</code> 查看xxx命令的帮助信息。</li>
</ul>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><ul>
<li><code>npm -g install npm</code></li>
</ul>
<h2 id="设置npm配置"><a href="#设置npm配置" class="headerlink" title="设置npm配置"></a>设置npm配置</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> &lt;key&gt; &lt;value&gt; [–global]</span><br></pre></td></tr></table></figure>
<h3 id="查看npm配置"><a href="#查看npm配置" class="headerlink" title="查看npm配置"></a>查看npm配置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm config ls</span><br></pre></td></tr></table></figure>
<h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> proxy=http://xx.xx.xx.xx:8080</span><br></pre></td></tr></table></figure>
<h3 id="设置npm的镜像源"><a href="#设置npm的镜像源" class="headerlink" title="设置npm的镜像源"></a>设置npm的镜像源</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h2 id="发布项目到npm"><a href="#发布项目到npm" class="headerlink" title="发布项目到npm"></a>发布项目到npm</h2><p>1.在官网注册npm账号</p>
<p>2.用户验证，命令行执行</p>
<blockquote>
<p>npm adduser</p>
</blockquote>
<p>3.发布模块，在模块的根文件夹执行</p>
<blockquote>
<p>npm publish</p>
</blockquote>
<p>4.更新版本</p>
<blockquote>
<p>如果是git库时，会为新版本号创建一条提交信息，package版本号会自动递增。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm version <span class="number">0.0</span><span class="number">.4</span></span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure>
<h2 id="npm-search-搜索（快捷方式：find-s）"><a href="#npm-search-搜索（快捷方式：find-s）" class="headerlink" title="npm search 搜索（快捷方式：find, s）"></a>npm search 搜索（快捷方式：find, s）</h2><ul>
<li><code>xxx</code> 搜索xxx 如：npm search jquery。</li>
</ul>
<h2 id="npm-install-安装-（快捷方式：i）"><a href="#npm-install-安装-（快捷方式：i）" class="headerlink" title="npm install 安装 （快捷方式：i）"></a>npm install 安装 （快捷方式：i）</h2><ul>
<li>xxx 搜索并安装xxx（局部）。安装多个依赖可用空格分割，如npm i jquery bootstrap。</li>
<li>xxx -g 搜索并安装xxx（全局）。安装多个同上。</li>
<li>xxx -D 安装并将依赖信息写在package.json中的devDependencies中。</li>
<li>快捷方式 i均可，如npm i jquery。</li>
<li>xxx@版本号 指定需要安装的版本号，若不指定将安装最新的稳定版本。</li>
</ul>
<h2 id="npm-uninstall-卸载（快捷方式：rm-r）"><a href="#npm-uninstall-卸载（快捷方式：rm-r）" class="headerlink" title="npm uninstall 卸载（快捷方式：rm, r）"></a>npm uninstall 卸载（快捷方式：rm, r）</h2><ul>
<li>xxx 卸载xxx。多个依赖可用空格分割。</li>
<li>xxx -D 卸载xxx，并将依赖信息从package.json中的devDependencies中清除。</li>
</ul>
<h2 id="npm-list-列出已安装依赖（快捷方式：ls）"><a href="#npm-list-列出已安装依赖（快捷方式：ls）" class="headerlink" title="npm list 列出已安装依赖（快捷方式：ls）"></a>npm list 列出已安装依赖（快捷方式：ls）</h2><ul>
<li>默认列出局部依赖。</li>
<li>npm list -g 列出已安装的全局依赖。</li>
</ul>
<h2 id="npm-outdated-检查过期依赖"><a href="#npm-outdated-检查过期依赖" class="headerlink" title="npm outdated 检查过期依赖"></a>npm outdated 检查过期依赖</h2><h2 id="npm-update-更新依赖（快捷方式：up）"><a href="#npm-update-更新依赖（快捷方式：up）" class="headerlink" title="npm update 更新依赖（快捷方式：up）"></a>npm update 更新依赖（快捷方式：up）</h2><ul>
<li>xxx 局部更新xxx。</li>
<li>xxx -g 全局更新xxx。</li>
</ul>
<h2 id="npm-root-查看依赖安装路径（也就是node-modules的路径）"><a href="#npm-root-查看依赖安装路径（也就是node-modules的路径）" class="headerlink" title="npm root 查看依赖安装路径（也就是node_modules的路径）"></a>npm root 查看依赖安装路径（也就是node_modules的路径）</h2><ul>
<li>默认查看局部安装路径。</li>
<li>-g 查看全局安装路径。</li>
</ul>
<h2 id="npm-view-查看模块的注册信息"><a href="#npm-view-查看模块的注册信息" class="headerlink" title="npm view 查看模块的注册信息"></a>npm view 查看模块的注册信息</h2><ul>
<li>xxx versions 列出xxx的所有版本， 如：npm view jquery versions。</li>
<li>xxx dependencies 列出xxx的所有依赖， 如：npm view gulp dependencies。</li>
</ul>
<h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><blockquote>
<p>npm run ***</p>
</blockquote>
<h1 id="nvm-指令"><a href="#nvm-指令" class="headerlink" title="nvm 指令"></a>nvm 指令</h1><h2 id="nvm是什么"><a href="#nvm是什么" class="headerlink" title="nvm是什么"></a>nvm是什么</h2><blockquote>
<p>在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。</p>
</blockquote>
<p>nvm 应运而生，nvm 是 Mac 下的 node 管理工具，有点类似管理 Ruby 的 rvm，如果需要管理 Windows 下的 node，官方推荐使用 nvmw 或 nvm-windows。不过，nvm-windows 并不是 nvm 的简单移植，他们也没有任何关系。但下面介绍的所有命令，都可以在 nvm-windows 中运行。</p>
<h2 id="安装多版本的node-npm"><a href="#安装多版本的node-npm" class="headerlink" title="安装多版本的node/npm"></a>安装多版本的node/npm</h2><p>例如，我们要安装4.2.2版本，可以用如下命令：</p>
<blockquote>
<p>nvm install 4.2.2</p>
</blockquote>
<p>nvm 遵守语义化版本命名规则。例如，你想安装最新的 4.2 系列的最新的一个版本的话，可以运行：</p>
<blockquote>
<p>nvm install 4.2</p>
</blockquote>
<p>nvm 会寻找 4.2.x 中最高的版本来安装。</p>
<p>你可以通过以下命令来列出远程服务器上所有的可用版本：</p>
<blockquote>
<p>nvm ls-remote</p>
</blockquote>
<h2 id="在多个版本中个切换"><a href="#在多个版本中个切换" class="headerlink" title="在多个版本中个切换"></a>在多个版本中个切换</h2><p>每当我们安装了一个新版本 Node 后，全局环境会自动把这个新版本设置为默认。</p>
<p>nvm 提供了 nvm use 命令。这个命令的使用方法和 install 命令类似。</p>
<p>例如，切换到 4.2.2：</p>
<blockquote>
<p>nvm use 4.2.2</p>
</blockquote>
<h2 id="列出已安装实例"><a href="#列出已安装实例" class="headerlink" title="列出已安装实例"></a>列出已安装实例</h2><blockquote>
<p>nvm ls</p>
</blockquote>
<h2 id="在项目中使用不同版本的-Node"><a href="#在项目中使用不同版本的-Node" class="headerlink" title="在项目中使用不同版本的 Node"></a>在项目中使用不同版本的 Node</h2><p>我们可以通过创建项目目录中的 .nvmrc 文件来指定要使用的 Node 版本。之后在项目目录中执行 nvm use 即可。.nvmrc 文件内容只需要遵守上文提到的语义化版本规则即可。另外还有个工具叫做 avn，可以自动化这个过程。</p>
<h2 id="在多环境中，npm该如何使用呢？"><a href="#在多环境中，npm该如何使用呢？" class="headerlink" title="在多环境中，npm该如何使用呢？"></a>在多环境中，npm该如何使用呢？</h2><p>每个版本的 Node 都会自带一个不同版本的 npm，可以用 npm -v 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 <code>~/.nvm/versions/node/&lt;version&gt;/lib/node_modules&lt;/version&gt;</code> 这样的目录。这刚好也省去我们在 Linux 中使用 sudo 的功夫了。因为这是用户的主文件夹，并不会引起权限问题。</p>
<p>但问题来了，我们安装过的 npm 包，都要重新再装一次？幸运的是，我们有个办法来解决我们的问题，运行下面这个命令，可以从特定版本导入到我们将要安装的新版本 Node：</p>
<blockquote>
<p>nvm install v5.0.0 –reinstall-packages-from=4.2</p>
</blockquote>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>python处理编码问题</title>
    <url>/2018/05/23/python%E5%A4%84%E7%90%86%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>最近参加一个可视化的比赛，在用python处理csv数据时，编码的问题真的是让人头大。干脆写一篇博客把编码的问题梳理一遍</p>
</blockquote>
<a id="more"></a>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="https://blog.csdn.net/woshimalingyi/article/details/49201319" target="_blank" rel="noopener">字符编码和字符集</a></p>
<p><a href="https://blog.csdn.net/ggggiqnypgjg/article/details/53271541" target="_blank" rel="noopener">python中文乱码问题</a></p>
<h1 id="常见的编码体系"><a href="#常见的编码体系" class="headerlink" title="常见的编码体系"></a>常见的编码体系</h1><h2 id="编码的定义"><a href="#编码的定义" class="headerlink" title="编码的定义"></a>编码的定义</h2><blockquote>
<p>编码是信息从一种形式或格式转换为另一种形式的过程也称为计算机编程语言的代码简称编码。用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。编码在电子计算机、电视、遥控和通讯等方面广泛使用。编码是信息从一种形式或格式转换为另一种形式的过程。解码，是编码的逆过程。</p>
</blockquote>
<p>正常情况下我们无论是做网页还是处理数据的时候都会遇到编码问题的，所以有必要对编码的方式做一个详尽的理解</p>
<h2 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h2><p>这个本科学c语言的时候应该就接触过了</p>
<blockquote>
<p>这是美国在19世纪60年代的时候为了建立英文字符和二进制的关系时制定的编码规范，它能表示128个字符，其中包括英文字符、阿拉伯数字、西文字符以及32个控制字符。它用一个字节来表示具体的字符，但它只用后7位来表示字符（2^7=128），最前面的一位统一规定为0。</p>
</blockquote>
<h2 id="拓展的ASCII码"><a href="#拓展的ASCII码" class="headerlink" title="拓展的ASCII码"></a>拓展的ASCII码</h2><blockquote>
<p>原本的ASCII码对于英文语言的国家是够用了，但是欧洲国家的一些语言会有拼音，这时7个字节就不够用了。因此一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使 用的编码体系，可以表示最多256个符号。但这时问题也出现了：不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码 中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。这个问题就直接促使了Unicode编码的产生。</p>
</blockquote>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><blockquote>
<p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。而Unicode就是这样一种编码：它包含了世界上所有的符号，并且每一个符号都是独一无二的。比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表 。很多人都说Unicode编码，但<strong>其实Unicode是一个符号集（世界上所有符号的符号集），而不是一种新的编码方式。</strong></p>
<p>但是正因为Unicode包含了所有的字符，而有些国家的字符用一个字节便可以表示，而有些国家的字符要用多个字节才能表示出来。即产生了两个问题：第一，如果有两个字节的数据，那计算机怎么知道这两个字节是表示一个汉字呢？还是表示两个英文字母呢？第二，因为不同字符需要的存储长度不一样，那么如果Unicode规定用2个字节存储字符，那么英文字符存储时前面1个字节都是0，这就大大浪费了存储空间。</p>
</blockquote>
<blockquote>
<p>上面两个问题造成的结果是：1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。2）unicode在很长一段时间内无法推广，直到互联网的出现。</p>
</blockquote>
<h2 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h2><blockquote>
<p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍，这里的关系是，<strong>UTF-8是Unicode的实现方式之一</strong>。</p>
<p>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8的编码规则很简单，只有两条：</p>
<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</p>
<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
</blockquote>
<h2 id="GBK-GB2312-GB18030"><a href="#GBK-GB2312-GB18030" class="headerlink" title="GBK/GB2312/GB18030"></a>GBK/GB2312/GB18030</h2><blockquote>
<p>GBK和GB2312都是针对简体字的编码，只是GB2312只支持六千多个汉字的编码，而GBK支持1万多个汉字编码。而GB18030是用于繁体字的编码。汉字存储时都使用两个字节来储存。</p>
</blockquote>
<h2 id="不同编码方式之间的联系"><a href="#不同编码方式之间的联系" class="headerlink" title="不同编码方式之间的联系"></a>不同编码方式之间的联系</h2><p>比如：在欧美，<strong>一般直接使用ASCII码</strong>就能够满足他们的要求，因为他们只有26个字母和一些其他的字符。而且编码表示的长度只占一个字节。但是，如果他们的程序要到我们国家来使用，那么我们如果不懂英语就完全不能够使用了。我们国家汉字近10万</p>
<p>使用Unicode字符集（<strong>该字符集和编码几乎囊括所有国家的常用字符</strong>）。而在国内，因为还可能显示其他不常见的汉字，因此就不能采用Unicode。为此，我们国家便发明了自己的字符集和编码—-GBXXX系列，供国内使用。因此，字符集和字符编码的多样性是由于不同区域的需求多样性导致的。但是在国际上，还是使用Unicode字符集和UTF-X编码方式</p>
<p>有一些编码存在包含关系，比如UTF-8的第一个字节的编码规则跟ASCII码完全一样。因此，<strong>对于ASCII码的编码内容使用UTF-8也能够正确解码</strong>。字符集也是一样的。因此，ASCII码编码的内容使用UTF-8解码后，使用Unicode字符集规则来解释得到的字符串跟使用ASCII字符集解释得到的完全一样。</p>
<p>比如：对于同一个编码<br> “\u33a1”. GBK的可能解释为”你“； ISO-8859-1的解释是乱码 “?”; Unicode的解释为”你“。</p>
<p>原因就是因为<strong>Unicode跟GBK有部分编码解码解码规则是一样的</strong>。而ISO-8859-1是外文编码，不能识别中文<br> ，因此无法解析。</p>
<h1 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h1><h2 id="乱码的定义"><a href="#乱码的定义" class="headerlink" title="乱码的定义"></a>乱码的定义</h2><blockquote>
<p>乱码，指的是由于本地计算机在用文本编辑器打开源文件时，使用了不相应字符集而造成部分或所有字符无法被阅读的一系列字符。造成其结果的原因是多种多样的。</p>
</blockquote>
<h2 id="乱码出现的原因"><a href="#乱码出现的原因" class="headerlink" title="乱码出现的原因"></a>乱码出现的原因</h2><h1 id="python处理编码"><a href="#python处理编码" class="headerlink" title="python处理编码"></a>python处理编码</h1><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><h2 id="python中的unicode对象"><a href="#python中的unicode对象" class="headerlink" title="python中的unicode对象"></a>python中的unicode对象</h2><p>python代码中，a=u’中国’, 或者a=’中国’.decode()的结果。</p>
<h2 id="python中的编码转换原则"><a href="#python中的编码转换原则" class="headerlink" title="python中的编码转换原则"></a>python中的编码转换原则</h2><p>unicode是”中介”，<strong>任何编码之间转换都需要先decode()到unicode</strong>。</p>
<h2 id="python文件开头注释作用"><a href="#python文件开头注释作用" class="headerlink" title="python文件开头注释作用"></a>python文件开头注释作用</h2><p>“#coding:utf-8” 告诉python用什么编码去读取这个.py文件。</p>
<h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>python2.7读csv中文文件乱码</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>python读文件里的中文成功解决了（通过手动修改所有csv的编码为utf-8）</p>
<h4 id="方法2（未验证）"><a href="#方法2（未验证）" class="headerlink" title="方法2（未验证）"></a>方法2（未验证）</h4><p><code>import codecs
 codecs.open(file_path, &#39;r&#39;, encoding=&quot;utf-8&quot;)</code><br> 这个方法没尝试，估计也可以，另外这里用的codecs的open函数，因为python2.7不支持打开文件时选择编码</p>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>python2.7写入csv文件乱码</p>
<h3 id="问题解决-1"><a href="#问题解决-1" class="headerlink" title="问题解决"></a>问题解决</h3><p><code>with codecs.open(file_path, &#39;w&#39;, &#39;utf_8_sig&#39;)</code><br>注意这里一定要是<strong>utf-8_sig</strong>而不是<strong>utf-8</strong>,然后你需要写进去的数据文件保持utf-8格式就可以了，它这个方法打开的文件会自动显示成</p>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>excel打开csv文件，可以识别编码“GB2312”，但是不能识别“utf-8”,所以csv文件里的中文还是需要转成中文的编码格式</p>
]]></content>
      <categories>
        <category>技术细节</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>《30岁前的每一天》读书笔记</title>
    <url>/2017/11/07/%E3%80%8A30%E5%B2%81%E5%89%8D%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>这本书启发了我的自我管理意识（虽然我的自觉性还是没有得到本质的提高XD），总的来说是本不错的书。不过说实话，现在再看有点鸡汤+民科的嫌疑，但是相对于<code>人性的缺点</code>之类的书，还算比较良心+有指导意义了</p>
<p>评分：2.5分</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>诚然，现在再看这本书，只是觉得平淡无奇，但是要因此否定这本书的价值，我是不认同的。一来，这本书意义重大，让我觉醒了自我管理的意识。二来，这本书本身的内容倒在其次，里面提及的一些作者看过的书确实是给了我许多帮助。最后一个原因也很简单，再平庸的一本书，只要你有心，总有一些触动到你的点。这些点不一定是作者在书中强调的，有可能是你之前的积累在这本书上找到了突破口，这样的境遇我也碰到了不少，所以，要认真对待自己手头的每一本书。</p>
<h1 id="梦想改变生活"><a href="#梦想改变生活" class="headerlink" title="梦想改变生活"></a>梦想改变生活</h1><h2 id="月薪50W的美妙生活"><a href="#月薪50W的美妙生活" class="headerlink" title="月薪50W的美妙生活"></a>月薪50W的美妙生活</h2><p>假设你现在月薪有50w（实际上就是手头充分宽裕）并且有足够的空余时间，你现在想干什么？</p>
<p>实际上，我们只是想通过这样一个小游戏，来让你开放时间和金钱的束缚，畅想一下你真正的梦想是什么？</p>
<p>你相信什么，你就看见什么</p>
<h2 id="梦想摘星的人才可能登上月球"><a href="#梦想摘星的人才可能登上月球" class="headerlink" title="梦想摘星的人才可能登上月球"></a>梦想摘星的人才可能登上月球</h2><p>取法乎上，的其中也，取法乎下，仅得其下</p>
<h1 id="聚集正能量的人生"><a href="#聚集正能量的人生" class="headerlink" title="聚集正能量的人生"></a>聚集正能量的人生</h1><p>就看书而言，看远比看哪一本更重要。书当然是有好有坏，有很多不值得花费时间的书。但是那是读过很多书之后才有的经验</p>
<p>根本没有那条“更好的路”，只有一条路。就是你选择的哪条路，关键是，你要勇敢地走上去，而且要坚持走下去</p>
<h1 id="职业，学习，和爱情的规划"><a href="#职业，学习，和爱情的规划" class="headerlink" title="职业，学习，和爱情的规划"></a>职业，学习，和爱情的规划</h1><h2 id="1-职业"><a href="#1-职业" class="headerlink" title="1.职业"></a>1.职业</h2><h3 id="如何做好职业规划"><a href="#如何做好职业规划" class="headerlink" title="如何做好职业规划"></a>如何做好职业规划</h3><ul>
<li>知道我能做什么</li>
<li>知道这个职业的路径是什么</li>
<li>我还能再做什么</li>
</ul>
<h3 id="充分的准备工作"><a href="#充分的准备工作" class="headerlink" title="充分的准备工作"></a>充分的准备工作</h3><p>如果你真的很想进一家公司的话，疯狂准备面试（近乎狂热的程度）也不失为一个好办法</p>
<h2 id="2-读书"><a href="#2-读书" class="headerlink" title="2.读书"></a>2.读书</h2><h3 id="读书重在行还是知？"><a href="#读书重在行还是知？" class="headerlink" title="读书重在行还是知？"></a>读书重在行还是知？</h3><h3 id="读书要读旧书"><a href="#读书要读旧书" class="headerlink" title="读书要读旧书"></a>读书要读旧书</h3><ul>
<li>省事</li>
<li>省时</li>
<li>温故知新</li>
</ul>
<p><strong>读书有时读不懂，十有八九是自身资质还未到此，如果实在啃不下，可以考虑曲线救国，先从别的简单的书籍入手，慢慢积累经验和自己的思考，然后再入门这本书，也许会有不一样的收获</strong></p>
<h2 id="3-爱情"><a href="#3-爱情" class="headerlink" title="3.爱情"></a>3.爱情</h2><p>略</p>
<h1 id="财富规划-财富自由之路"><a href="#财富规划-财富自由之路" class="headerlink" title="财富规划-财富自由之路"></a>财富规划-财富自由之路</h1><h2 id="我对财富自由的理解"><a href="#我对财富自由的理解" class="headerlink" title="我对财富自由的理解"></a>我对财富自由的理解</h2><p>财富自由这个词实在是熟悉不过了，我最开始接触的就是通过<code>穷爸爸富爸爸系列</code>。大一的时候我通过买或者图书馆借把全系列都看完了，当时心里就对财富自由产生了无穷的向往。现如今，通过罗胖等人的极力鼓吹，财富自由这个词已经烂大街了。只要市面上提到什么教你通往财富自由之路，不用想，都是骗你的（讽刺的是，得到专栏上，最火的就是这个）。对我们这种缺乏冒险精神的底层人民来说，想要赚钱，唯一靠谱的途径就是选择一项行业（比如互联网），然后慢慢积累行业经验，努力做到业内顶尖水平。想要靠投资发家，不存在的。</p>
<p>当然这边并不是说投资没有用，当然有用，但是如果你指望靠这个不劳而获坐享其成，那你找错了对象。我的理解是当你手头的资产到了一定的程度，有闲钱但不知道怎么画，那么你可以考虑通过一系列投资手段来使现金流能抵上你每个月的支出从而实现财富自由。呵呵，但麻烦看清楚形式。在一线城市，就算你夫妻双方年薪加起来大几十w，摆在你们面前的是什么？房子。更不用提到了那个收入水平的生活开支了，想要做到存钱去购买资产？</p>
<p>这段书中主要讲了一些基础的金融知识和财富管理的重要性，没有什么好提的</p>
<h1 id="打败挡在梦想路上的小怪兽"><a href="#打败挡在梦想路上的小怪兽" class="headerlink" title="打败挡在梦想路上的小怪兽"></a>打败挡在梦想路上的小怪兽</h1><h2 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h2><ul>
<li>立即行动，不要思考</li>
<li>挑选最有成就感的事来完成<h1 id="记事本改变生活"><a href="#记事本改变生活" class="headerlink" title="记事本改变生活"></a>记事本改变生活</h1>提倡使用记事本+经验库来管理自己</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>个人成长</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>zIndex为什么会无效</title>
    <url>/2019/05/31/zIndex%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%97%A0%E6%95%88/</url>
    <content><![CDATA[<p>在做项目的过程中遇到了这样的问题，即z-index为什么会有时候没有效果？</p>
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们首先来看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index" target="_blank" rel="noopener">MDN</a>里，z-index是怎么描述的</p>
<blockquote>
<p>z-index 属性指定了一个具有定位属性的元素及其子代元素的 z-order。 当元素之间重叠的时候，z-order 决定哪一个元素覆盖在其余元素的上方显示。 通常来说 z-index 较大的元素会覆盖较小的一个。</p>
<p>对于一个已经定位的元素（即position属性值不是static的元素），z-index 属性指定：</p>
</blockquote>
<blockquote>
<p>元素在当前堆叠上下文中的堆叠层级。<br>元素是否创建一个新的本地堆叠上下文</p>
</blockquote>
<p>z-index 可以取值<code>auto</code>或者数字（auto会互相层叠，但是只要指定正的z-index，就会比auto高）</p>
<p>需要注意的是z-index需要是对有<code>position</code>不为<code>static</code>属性的元素才做效的</p>
<h1 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h1><ul>
<li>该标签无<code>position</code>属性</li>
<li>该标签父元素是relative（IE6）</li>
<li>该标签为浮动元素（IE6）</li>
</ul>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>添加position标签</p>
]]></content>
  </entry>
  <entry>
    <title>《SICP》攻略计划</title>
    <url>/2018/06/25/%E3%80%8ASICP%E3%80%8B%E6%94%BB%E7%95%A5%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<blockquote>
<p>上一次看这本书的时候还是大三，但是因为考研（懒）等原因只寥寥看了两周的时间就放下了。但正是这短短的两周，让我彻底感受到了SICP和Lisp语言的魅力。说实话，最近前端做的非常迷茫，决定回归本源，来认真研读SICP这本好书</p>
</blockquote>
<a id="more"></a>
<p><strong>本文只是个引子，具体的读书笔记我之后会单独列文章出来的</strong></p>
<h1 id="Why-SICP"><a href="#Why-SICP" class="headerlink" title="Why SICP"></a>Why SICP</h1><blockquote>
<p>我现在正处于本科和研究生阶段交接的地步，我最近一直在做的前端最近感觉到了迷茫，因为感觉前端的东西都很浅（不管是我现在用到的东西，还是框架，我总感觉不是很踏实）。虽然研究生阶段师兄们找的工作都是算法岗（也就是研究生阶段做的事）但是我还是想挑战一下算法岗。原本我的计划是先做把前端做到一定的程度（即差不多找工作，另外百度前端学院也自称，完成它几个月的任务就能达到国内一线大公司实习的标准），再去看一下纯粹的编程。现在看来这个计划似乎有点本末倒置的嫌疑，应该是先研读优秀的纯编程方面的知识，有了一定的底气，再去看js前端方面的内容，可能就会有种“一览众山小”的感觉，先这样计划着吧</p>
</blockquote>
<blockquote>
<p>这本书的很多内容、习题需要仔细揣摩才能领略其精髓，所以看这本书一定不要心急。 其次，在阅读时，请务必关闭手机上一些社交工具，并预留出至少 1 个小时的完整时间来看，否则我不认为你真的能有所收获。</p>
<p>学习是件很苦的事，大多数人都是三分钟热度，所以如果你觉得看这本书让你很烦躁，不妨出去运动一下，或听一会音乐🎵，第二天接着来。坚持下来，不要放弃，更不要失去对探索编程真谛的好奇心。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://liujiacai.net/blog/2016/04/23/sicp-chapter4-summary/" target="_blank" rel="noopener">一个记录SICP习题的博客</a></li>
<li><a href="https://sicp.liujiacai.net/chap3/exercise.html" target="_blank" rel="noopener">上一个人的SICP习题总结</a></li>
<li><a href="http://www.nowamagic.net/librarys/veda/detail/1905" target="_blank" rel="noopener">向热爱计算机的你推荐SICP</a></li>
<li><a href="http://yinwang0.lofter.com/post/183ec2_47bea8" target="_blank" rel="noopener">如何掌握程序语言</a></li>
</ol>
<h1 id="开发环境环境配置"><a href="#开发环境环境配置" class="headerlink" title="开发环境环境配置"></a>开发环境环境配置</h1><p>我之前是使用的<a href="https://racket-lang.org/" target="_blank" rel="noopener">DrRacket</a>，是一个GUI版本，而且自带简便的调试功能。但这次我觉得它的代码补全和高亮什么的不太好，而且SICP应该不需要太强的调试功能，我决定自己在atom上搞，下载一个<code>language-scheme</code>的插件，然后在终端下运行对应的scheme程序。我使用的scheme解释器是<a href="http://ftp.gnu.org/gnu/mit-scheme/stable.pkg/9.2/mit-scheme-9.2-x86-64.dmg" target="_blank" rel="noopener">mit-scheme</a>。</p>
<p>下载完上面的scheme解释器之后，将其加入在系统的全局路径里，在终端里输入scheme就可以直接交互运行了，但这样的话<code>会无法使用方向键</code>。下载rlwrap就可以了<code>brew install rlwrap</code>，下载完运行<code>rlwrap scheme</code>即可。</p>
<h1 id="SICP计划"><a href="#SICP计划" class="headerlink" title="SICP计划"></a>SICP计划</h1><ol>
<li>我计划1年内读完，即研一的阶段做完</li>
<li>重点放在前3章（假设做不完的话）</li>
<li>之前刷的时候，重点放在做题上。这次在做的时候，<strong>要开始利用好git了</strong>，每个题单独成一个scm文件</li>
<li>每一章单独做一个总结，<a href="https://liujiacai.net/blog/2015/07/18/sicp-chapter1-summary/" target="_blank" rel="noopener">参考</a>，每一个题单独做一份文件，并且push到github上</li>
</ol>
<h1 id="辅助资料链接"><a href="#辅助资料链接" class="headerlink" title="辅助资料链接"></a>辅助资料链接</h1><ol>
<li><a href="http://www.math.pku.edu.cn/teachers/qiuzy/progtech/" target="_blank" rel="noopener">北大SICP教学主页</a></li>
<li><a href="https://www.comp.nus.edu.sg/~cs1101s/sicp/" target="_blank" rel="noopener">SICP in javascript</a></li>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/" target="_blank" rel="noopener">MIT 教学视频</a><h1 id="SICP笔记链接"><a href="#SICP笔记链接" class="headerlink" title="SICP笔记链接"></a>SICP笔记链接</h1></li>
</ol>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>《暗时间》读书笔记</title>
    <url>/2017/10/25/%E3%80%8A%E6%9A%97%E6%97%B6%E9%97%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>刘伟鹏的博客可以堪称国内程序员的典范了吧，我也是两年前就看了这本书，现在重新翻了出来，作为自己博客上读书笔记的开端吧</p>
<p>评分：4分</p>
</blockquote>
<a id="more"></a>
<h1 id="读书笔记之前的杂谈"><a href="#读书笔记之前的杂谈" class="headerlink" title="读书笔记之前的杂谈"></a>读书笔记之前的杂谈</h1><h2 id="一些唏嘘"><a href="#一些唏嘘" class="headerlink" title="一些唏嘘"></a>一些唏嘘</h2><p>在看了这么多书之后，我发现一个简单但深刻的道理：对于一本书，如果你读完之后觉得有价值。一定要写（或者说最好要写，因为有的书写不出来什么）读书笔记，尤其是对我这种记性差的人来说。我大一大二看的书很多，基本上空闲的时间六成都放在了看书上。可是我读过的这些书，一部分是确实没什么价值，剩余有价值的书，部分没做笔记，部分做了笔记但是放在了OneNote上。不可否认onenote是一个非常好的知识管理工具，事实上我到现在一些私人的信息都在用它来管理，但是把它来当做一个知识输出的平台那还是不够的。一个是输出的方式不够多样化，对于现在熟悉了markdown之后的我来说，一个不支持markdown功能的平台简直是不可原谅的。另外一个也是最重要的原因：在onenote上你所有记录的东西都是给自己看的，而发布在blog或者是知乎/简书等平台能起到一个公众督导的效果。这一点很重要，哪怕我的博客没有人看，但是我只要一想到这是一个公众的平台，就会尽力用心对待之，努力地收集资料以及认真记录文字。</p>
<h2 id="关于kindle"><a href="#关于kindle" class="headerlink" title="关于kindle"></a>关于kindle</h2><p>想要大量看书的话，还是买一个kindle更划算。我大二时也买过一个kpw2.但是怎么说呢，对于我个人而言，我还是更偏向于纸质书一些，我一般只用kindle来看一些散文和小说。它的阅读感还是不如纸质书来得流畅。也许是我没有掌握正确的看书技巧吧，但不管怎么说，纸质书的价格和携带型始终是爱书之人心中的一个巨大的创伤…希望以后能捡起来这个工具吧</p>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>最开始接触作者刘未鹏是想订一些<code>rss</code>看，知乎里有些人提到了他。<a href="http://mindhacks.cn/" target="_blank" rel="noopener">他的博客</a>里有他个人完整的介绍的信息。当我视图给自己的博客做出精准的定位时，我发现，刘未鹏的博客就是我心中理想的博客。换句话说，刘未鹏的生活轨迹，实际上就是我梦想的轨迹，倒不是说多么高薪。高薪只是一个层面，毕竟做技术做到这个层面都差不到哪去，最关键的是，我非常佩服他在搞好自己本职工作的同时，能够阅读这么多的书，并且自己有着非常深刻的体会和感悟，这一点从他的文字里能够很好地看出来。我自己最希望的就是两件事情，一是不断提高自己的编程能力，养家糊口的同时能够源源不断地获取成就感，二是看很多的书，丰富精神世界的同时也深刻自己的思想。刘未鹏很好地做到了这两点的结合。这本书就是他将自己多年来写的博客精选一部分然后集结成册，最后出版。希望我能从再一次拜读这份作品的同时，有意识地学习点什么。</p>
<h1 id="序言：为什么人人都该学点心理学"><a href="#序言：为什么人人都该学点心理学" class="headerlink" title="序言：为什么人人都该学点心理学"></a>序言：为什么人人都该学点心理学</h1><p>心理学早就从弗洛伊德那一套中走出来，并结合现代科学技术手段和研究方法，跨学科研究人脑思维的特点以及和现实生活的关系。心理学与日常生活息息相关的另一方面就是日常判断与决策.</p>
<p>人的大脑和思维是目前已知最为复杂的系统，对这个系统的研究是一件极其迷人的事情，即便对于像我们这样的芸芸众生来说，纵使不去做研究，学习一些这方面的科普知识，对于学会正确的思考也有极大的益处。</p>
<p>大脑是我们最重要的工具，要正确利用这个工具，唯一的途径就是去了解他，尤其是了解他的弱点。人们的思维充满了各种各样的结晶，每一条捷径都是一把双刃剑，一方面，它降低了大脑的认知复杂度，有助于做出绝大多数时刻都正确的判断，但另一方面，它也常常导致人们把大部分情况下成立的法则当场了放之四海皆准的。</p>
<p>以上构成了人类思维中的种种谬误，而学会思考，就是学会认识到这些谬误。</p>
<h1 id="第一篇：暗时间"><a href="#第一篇：暗时间" class="headerlink" title="第一篇：暗时间"></a>第一篇：暗时间</h1><h2 id="暗时间"><a href="#暗时间" class="headerlink" title="暗时间"></a>暗时间</h2><ul>
<li><code>实际投入</code>是时间和效率的乘积</li>
<li>专注做一件事，就不会有效率的损失。因为大脑在开始一件任务时必须要要有一定的时间来热身</li>
<li>倾向于创造大块的时间来阅读重要的东西</li>
<li>能够迅速进入专注状态，以及能够长期保持专注，是高效学习的两个最重要的习惯</li>
<li>可以考虑在嘈杂的环境里训练自己的抗干扰能力</li>
</ul>
<h2 id="设计你自己的进度条"><a href="#设计你自己的进度条" class="headerlink" title="设计你自己的进度条"></a>设计你自己的进度条</h2><ul>
<li><strong>在尝试新领域时，不要过早退出循环</strong>（我心头的一记重击…）<br>过早退出的原因往往在于对未来的不确定性，对于投资时间最终无法收到回报的恐惧。</li>
<li>没有勇气去问别人问题，一般原因是1）被批评了怎么办2）认为问了也没有什么特别的信息。但事实可能是1）被批评了算不上什么实质性的损失2）你认为问不出什么，不代表真的问不出什么。<strong>别把不知道当做没有！</strong></li>
<li>靠专业技能的成功是最具可复制性的（在一个领域选择一个靠谱的方向，然后专心致志地钻研下去，最后必定成为高手）</li>
<li>饿死在干草堆之间的驴子（一个寓意）</li>
<li>一生的知识积累，自学起码占90%，程序员是最适合自学的行业</li>
</ul>
<h2 id="如何有效地记忆和学习"><a href="#如何有效地记忆和学习" class="headerlink" title="如何有效地记忆和学习"></a>如何有效地记忆和学习</h2><blockquote>
<p>你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来</p>
</blockquote>
<ul>
<li>记忆技巧：空间记忆法</li>
<li>在记忆知识时，加上自己的理解</li>
<li>尽量多和别人讲知识</li>
<li>整理笔记（这个比较可行）</li>
<li>书写</li>
</ul>
<h2 id="学习密度和专注度"><a href="#学习密度和专注度" class="headerlink" title="学习密度和专注度"></a>学习密度和专注度</h2><ul>
<li>在大学期间，最不缺的就是业余时间，最缺的就是专注精神</li>
<li>真正的动力还不是自制力，应该是追求</li>
</ul>
<h2 id="一直以来伴随我的一些学习习惯"><a href="#一直以来伴随我的一些学习习惯" class="headerlink" title="一直以来伴随我的一些学习习惯"></a>一直以来伴随我的一些学习习惯</h2><ul>
<li>google&amp;wiki(中文维基被墙了，访问英文的把)</li>
<li>看书只看经典</li>
<li>做好读书笔记（思考记录下来+记录书上的片段）</li>
<li>利用生活的片段思考（这个我觉得有点难）</li>
<li>多看思维和心理学的书（元知识）</li>
<li>学习一项知识，必须问自己三个重要的问题 1）它的本质是什么 2）它的第一原则是什么 3）它的知识结构是什么 （这个做到我觉得有点困难，但还是放在dahsoboard里提醒自己吧）</li>
<li>学习和思考中，问自己：1）你的问题是什么2）我到底有什么收获3）设想自己在给别人讲4）将给一个不懂得人5）养成反驳自己的习惯（实在有些强人所难，不过还是尝试一下吧，不过学习完一个知识/看完一本书，真的需要做一下总结）</li>
<li>趁着对一件事有热情的时候，一股脑把万事开头的最难的阶段熬过去</li>
<li>时不时反省一下，自己现在做的事，到底是什么？它们重要吗？你需要在这个时候学习这个吗？</li>
<li>有时间吗？总结最近得到的新知识把！</li>
<li>有时间吗？看本书把！</li>
<li><strong>学习一个新东西之前，首先在大脑中积累充分的疑惑感</strong>（这个说到了点子上）</li>
</ul>
<blockquote>
<p>的确，也许真的有更好的路，但事前真的很难判断哪条路是最有的，我能做到的，是把一条路走透了，走深了，只要不是一条太不靠谱的路，深入的过程中总会有很多的收获，只要不是太顽固，善于反省，总有一天也会意识到越来越靠谱的路</p>
</blockquote>
<h1 id="第二篇：思维改变生活"><a href="#第二篇：思维改变生活" class="headerlink" title="第二篇：思维改变生活"></a>第二篇：思维改变生活</h1><h2 id="逃出你的肖恩克"><a href="#逃出你的肖恩克" class="headerlink" title="逃出你的肖恩克"></a>逃出你的肖恩克</h2><h2 id="书写是为了更好地思考"><a href="#书写是为了更好地思考" class="headerlink" title="书写是为了更好地思考"></a>书写是为了更好地思考</h2><p>书写有几点好处</p>
<ul>
<li>书写是对思维的备忘（方便罗列框架以及及时回溯）</li>
<li>书写是对思维的缓存（笔纸构成一个作家）</li>
<li>书写是和自己的对话（这个我深有感触，每次写随想时都能深刻体会到这一点）</li>
<li>书写是和别人的交流（这点我还没做到，希望以后能做到）</li>
<li>有时候，语言自己也会思考</li>
</ul>
<blockquote>
<p>如果你逼着自己将一些不成熟的想法写下来，看着自己写的内容，试着进一步扩展它们，就有可能在理性的道路上走得很远</p>
</blockquote>
<h2 id="为什么你从现在就应该开始写博客"><a href="#为什么你从现在就应该开始写博客" class="headerlink" title="为什么你从现在就应该开始写博客"></a>为什么你从现在就应该开始写博客</h2><blockquote>
<p>写博客有很多好处，却没有任何明显的坏处</p>
</blockquote>
<ul>
<li>能交到很多志同道合的朋友（当我看完了一个写了好几年的博客，仿佛和这个人交流了很久）</li>
<li>书写是为了更好地思考</li>
<li>“教”是最好的“学”（这个也是我比较推崇的一点，从建立这个新博客之后，我尽量每学习一个新知识，就在理解了之后写一篇博客来记录下来）</li>
<li>讨论是绝佳的反思</li>
<li>激励你去持续学习和思考（为了让你的博客有价值，你必须不断总结自己学习的结果，你必须不断思考，给出比别人深刻，独到的见解。这看起来有些本末倒置，但很快本和末就会纠正过来）</li>
<li>学会持之以恒地做一件事（这一点我有较深的体会，忙了很久之后终于把自己的博客调得很炫酷了，以后每次打开博客都很有成就感，写博客的积极性就会很高）</li>
<li>一份长期的博客是一份很好的简历（主要是说作为别人了解你的窗口）</li>
</ul>
<h2 id="我不想和我不能"><a href="#我不想和我不能" class="headerlink" title="我不想和我不能"></a>我不想和我不能</h2><ul>
<li><code>自利归因</code>就是把一件事发生的的原因归于对自己有利的那种情况。</li>
</ul>
<h2 id="遇到问题为什么应该自己动手"><a href="#遇到问题为什么应该自己动手" class="headerlink" title="遇到问题为什么应该自己动手"></a>遇到问题为什么应该自己动手</h2><ul>
<li>现代很多新知识都是知识密集型的，我们很多情况对困难会高估</li>
<li>只要智商上没有根本的差别，别人的大脑能够掌握的知识，你也能。你所感受的困难，不过是因为<code>unknown unknown</code>带来的</li>
<li>解决问题的过程可能艰辛，但是你收获的绝不仅是结果本身</li>
<li>解决问题越多，你解决问题也会越发熟练：知道可能是哪方面出了问题，知道应该在哪里寻找答案</li>
</ul>
<blockquote>
<p>原来的我也总是遇到困难再三尝试无果之后就会选择放弃，现在随着知识网的扩大，部分问题也能慢慢尝试自己解决了，这对我来说很重要。困难的路越走越简单，简单的路越走越难</p>
</blockquote>
<h2 id="什么才是你的不可替代性和核心竞争力"><a href="#什么才是你的不可替代性和核心竞争力" class="headerlink" title="什么才是你的不可替代性和核心竞争力"></a>什么才是你的不可替代性和核心竞争力</h2><ul>
<li>技术路线的选择重要但不具有决定性</li>
<li>专业领域技能</li>
<li>跨领域的技能（解决问题的能力，创新思维，判断与决策能力，批判性思维，表达沟通能力）</li>
<li>学习能力</li>
<li>性格要素</li>
</ul>
<h1 id="第三篇：跟波西亚学解题"><a href="#第三篇：跟波西亚学解题" class="headerlink" title="第三篇：跟波西亚学解题"></a>第三篇：跟波西亚学解题</h1><h2 id="跟波利亚学解题"><a href="#跟波利亚学解题" class="headerlink" title="跟波利亚学解题"></a>跟波利亚学解题</h2><h2 id="锤子和钉子"><a href="#锤子和钉子" class="headerlink" title="锤子和钉子"></a>锤子和钉子</h2><h2 id="鱼是最后一个看到水的"><a href="#鱼是最后一个看到水的" class="headerlink" title="鱼是最后一个看到水的"></a>鱼是最后一个看到水的</h2><h2 id="知其所以然"><a href="#知其所以然" class="headerlink" title="知其所以然"></a>知其所以然</h2><h2 id="为什么有必要知其所以然"><a href="#为什么有必要知其所以然" class="headerlink" title="为什么有必要知其所以然"></a>为什么有必要知其所以然</h2><h2 id="康托尔，哥德尔，图灵——永恒的金色对角线"><a href="#康托尔，哥德尔，图灵——永恒的金色对角线" class="headerlink" title="康托尔，哥德尔，图灵——永恒的金色对角线"></a>康托尔，哥德尔，图灵——永恒的金色对角线</h2><h2 id="快排为什么那么快"><a href="#快排为什么那么快" class="headerlink" title="快排为什么那么快"></a>快排为什么那么快</h2><h2 id="贝叶斯方法"><a href="#贝叶斯方法" class="headerlink" title="贝叶斯方法"></a>贝叶斯方法</h2><h1 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h1><ul>
<li>nudge</li>
<li>paradox-why more is less</li>
<li>made to stick</li>
<li>the social animal</li>
<li>searching for memory</li>
<li>outliers</li>
<li>the tipping point</li>
<li>psychology of judgement and decision making</li>
<li>别做正常的傻瓜</li>
<li>怪诞行为学</li>
<li>mistakes were made, but not by me</li>
<li>askIng the right question</li>
<li>影响力</li>
<li>how we decide</li>
<li>我是一只IT小小鸟</li>
<li>像外行一样思考，像专家一样实践</li>
<li>高效能人士的七个习惯</li>
<li>奇特的一生</li>
<li>合作的金华</li>
<li>mean genes</li>
<li>sway</li>
<li>随机致富的傻瓜</li>
<li>黑天鹅</li>
<li>20世纪最伟大的心理学实验</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>个人成长</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>《穷爸爸，富爸爸》读书笔记</title>
    <url>/2017/11/14/%E3%80%8A%E7%A9%B7%E7%88%B8%E7%88%B8%EF%BC%8C%E5%AF%8C%E7%88%B8%E7%88%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>这个系列是我大一的时候接触的，算是理财知识的入门书籍吧。当时看的时候惊为天人，觉得里面很多的观念颇为新奇有趣乃至惊为天人，当然现在再读，其实会发觉里面教的财富观念还是不错的，但是理财手段不太适合目前国情，权且当个经济入门读物来看吧</p>
<p>评分：3分</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个系列有很多本，我在大一的时候，基本每一本都或买或借着看了一遍，理所当然地现在都已经忘记了。重拾这个系列，再慢慢塑造自己的财富观念 :)</p>
<h1 id="穷爸爸，富爸爸"><a href="#穷爸爸，富爸爸" class="headerlink" title="穷爸爸，富爸爸"></a>穷爸爸，富爸爸</h1><p>作者有两个爸爸，一个爸爸（生父）受过良好的教育，聪明绝顶，拥有博士头衔，在著名大学深造，却终其一生都在个人财务问题上挣扎。一个爸爸（教父）连八年级都没能念完，却成为了夏威夷最富有的人</p>
<p>一个爸爸会说“贪财乃万恶之源”，另一个“贫穷才是万恶之源”</p>
<p>富人之所以越来越富，穷人之所以越来越穷，（马太效应），一个重要的原因是因为他们对金钱的认识不是来自于学校，而是来自于家庭</p>
<p>“我可付不起”vs“我要怎样才能付得起”</p>
<p>“破产是暂时的，贫穷是永久的”</p>
<p>“不能，你只能告诉我是接受还是拒绝。如果你不能下定决心，就永远也学不会如何赚钱。机会总是转瞬即逝。知道什么时候要迅速做出决定是一项非常重要的技能”</p>
<h2 id="资产与负债"><a href="#资产与负债" class="headerlink" title="资产与负债"></a>资产与负债</h2><p><code>资产</code>就是能把钱放进你口袋里的东西<br><code>负债</code>是把钱从你的口袋里拿出来的东西</p>
<p>举例说，如果你有房贷，房子对你来说就是负债，而不是资产。如果你完全拥有一个房子的产权，并且将其出租，那么这个时候房子就是你的资产，它每个月能给你带来一定的现金流。</p>
<p>美国人买房子也需要付出很大的代价：动辄几十年的房贷+房产税</p>
<p>“当我要换一所大一些的房子时，我会先买入一些资产，让它们的创造能够支付这所房子的现金流”</p>
<p>中产阶级发现自己总是在财务问题上挣扎，他们主要的收入就是工资，二挡工资增加时，税收也就增加了，更重要的是他们的支持也同步增加。这种把房子当资产的想法和那些认为钱越多就能买更大的房子或者更多东西的理财者需就是今天这个债台高筑的社会的基础</p>
<p>最重要的一点是弄清楚资产和负债的区别，一旦你明白了这种区别，你就会竭尽全力只买入能带来收入的资产，这是你走上致富之路的最好方法，你的资产在不断增加的同时要注意减少负债和支出</p>
<p>通过资产带来的收入继续投资资产，最终产生够多的现金流</p>
<p>富人买入资产，穷人只有支出，中产购买自以为是资产的负债</p>
<h1 id="关注自己的事业"><a href="#关注自己的事业" class="headerlink" title="关注自己的事业"></a>关注自己的事业</h1><p>搞清楚<code>职业</code>和<code>事业</code>的区别</p>
<p>真正的资产可以分为下面几类</p>
<ul>
<li>不需要我到场就可以正产运作的业务</li>
<li>股票</li>
<li>债券</li>
<li>共同基金</li>
<li>能够产生收入的房地产</li>
<li>票据</li>
<li>版税</li>
<li>其他任何有价值，可产生收入并有很好地销路的东西</li>
</ul>
<p>上班+关注自己的事业</p>
<p>我说投资，指的是建立牢固的资产。你应该这么先修改那个，一旦1美元进入了你的资产项，它就成为了你的雇员，24小时不间断地为你工作</p>
<p><strong>富人和穷人一个重要的区别就是“富人最后才买奢侈品，真正的奢侈品是对投资和积累真正资产的奖励</strong></p>
<h1 id="税收的历史和公司的力量"><a href="#税收的历史和公司的力量" class="headerlink" title="税收的历史和公司的力量"></a>税收的历史和公司的力量</h1><p>当你研究税收史时，你会发现一个有趣的现象，税之所以被接受是因为大众相信罗宾汉式的劫富济贫，问题是政府对钱的胃口越来越大，以致中产阶级也要被征税，并且税收的范围不断向穷人扩散</p>
<p>事实上，无论“劫富”的呼声有多高，富人总有办法从中脱身，税收最终还是要落在中产阶级头上</p>
<p>比如，“公司”可以拿来避税。它不一定必须是一个实体。一方面企业所得税率低于个人水乳所得税，另一方面，公司的某些支出可以用来睡前收入支付</p>
<p>财商是由四个方面构成的</p>
<ul>
<li>会计</li>
<li>投资</li>
<li>了解市场</li>
<li>法律</li>
</ul>
<h1 id="富人的投资"><a href="#富人的投资" class="headerlink" title="富人的投资"></a>富人的投资</h1><p>在现实生活中，人们往往是依靠勇气而不是智慧去取得领先的地位的</p>
<p>大部分贫穷的主要原因就在于他们太过于担心失去，胜利者不害怕失败，但失败者害怕</p>
<p>聪明的人往往会雇佣比他们更聪明的人，或者与他们一起工作</p>
<h1 id="学会不为钱工作"><a href="#学会不为钱工作" class="headerlink" title="学会不为钱工作"></a>学会不为钱工作</h1><p>精华就在标题上，实际上还是强调不断增加自己的资产以达到财务自由的状态</p>
<h1 id="克服苦难"><a href="#克服苦难" class="headerlink" title="克服苦难"></a>克服苦难</h1><p>掌握了财务知识的人有时候还是不能积累丰厚的资产项，主要原因有五个</p>
<h2 id="对可能亏钱的恐惧心理"><a href="#对可能亏钱的恐惧心理" class="headerlink" title="对可能亏钱的恐惧心理"></a>对可能亏钱的恐惧心理</h2><p>我从未见过喜欢亏钱的人，但同样我也没见过从没亏过钱的富人，但我确实见过很多从未亏一点钱的穷人（投资）</p>
<p>很多人因为太害怕失败，所以才会失败。胜利意味着不害怕失败</p>
<p>德州的人并不掩饰失败，他们接受失败的事实并将失败转化为动力。</p>
<h2 id="愤世嫉俗的心理"><a href="#愤世嫉俗的心理" class="headerlink" title="愤世嫉俗的心理"></a>愤世嫉俗的心理</h2><p>我们会对自己产生怀疑，怀疑常常使我们寸步难行，害怕的感觉在心中蔓延，有时我们甚至因此夜不能寐，我们无法前进，我们只能守着那些安稳的东西，看着机会从我们身边流走。事实上，抱怨蒙蔽人们的头脑，而分析诗人心明眼亮。通过分析能使成功者看到那些愤世者无法看到的东西。</p>
<h2 id="懒惰"><a href="#懒惰" class="headerlink" title="懒惰"></a>懒惰</h2><h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>习惯可以通过主动给自己找压力来完成。比如每个月账单到了之后首先支付自己（迫使自己去找其他的途径来致富）</p>
<h2 id="傲慢"><a href="#傲慢" class="headerlink" title="傲慢"></a>傲慢</h2><h1 id="开始行动"><a href="#开始行动" class="headerlink" title="开始行动"></a>开始行动</h1><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>这本书里的观念本身不错，强调资产而不是负债。可是一旦放在当今国情下，就不太行了。书里提倡的是不断地置购房产来增加现金流，可是我们都知道，目前国内想买一套刚需用房都困难无比，何谈有更多的房子，然后来换成现金流，而且政策风向是“房子是用来住的，而不是用来炒的”，这很明显有抑制炒房的趋势，如果贸然进入房市，很有可能是惹得一身骚，什么都没获得。对于中产阶级来说，最稳定的赚钱途径还是稳扎稳打地提升自己的专业技能，在一个好公司觅得一份好工作。当然，炒股也许是一个不错的选择，但是1）建议买美股，不建议持有国内的股票，主要原因是涨跌没有什么规律可寻，散客极容易被宰。2）除非你有极高的天分或者充足的时间，否则还是不建议涉足此业，水太深</p>
<p>不过这依然不可否认这本书的价值，里面还是有很多的观念到现在依旧很深刻，值得学习</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next主题配置</title>
    <url>/2017/10/10/hexo-next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>解决了博客的最基本的发文章和上传至同步之后，面临的问题自然是为自己的网站添加更多功能，当然可以选择DIY，但是想到自己能力有限，就算做出来想必也是优化和性能上有很大问题，就还是按部就班地来吧</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说实话，网上的教程很多，但是我仔细观察，发现基本上都是抄来抄去，也就是说错误类型一致，我配置站点的过程中参考了n篇教程，列一篇最有效的以供参考<a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">Moorez</a>。本文大部分配置都是参考之，非常感谢大大。如果大家想要手把手从头开始配置建议参考他的文章，因为我的文章没有附图，很难看到效果，但是本文的坑全是我自己踩出来的，是得到了实践证明的。</p>
<h1 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h1><h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h2><h3 id="在站点根目录下执行以下命令"><a href="#在站点根目录下执行以下命令" class="headerlink" title="在站点根目录下执行以下命令"></a>在站点根目录下执行以下命令</h3><p><code>$ npm install hexo-generator-searchdb --save</code></p>
<h3 id="在站点文件里任意位置加上"><a href="#在站点文件里任意位置加上" class="headerlink" title="在站点文件里任意位置加上"></a>在站点文件里任意位置加上</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">	path: search.xml</span><br><span class="line">	field: post</span><br></pre></td></tr></table></figure>
<h3 id="在主题配置文件里更改（默认为false）"><a href="#在主题配置文件里更改（默认为false）" class="headerlink" title="在主题配置文件里更改（默认为false）"></a>在主题配置文件里更改（默认为false）</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">	<span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>顺便多说一句，网上的大部分教程都只说了前两步，而没有提到第三步，最后的结果应该是这样的<br><img src="http://img.hb.aicdn.com/bccc1873543ce6864c59fdbb24e1f0d6e2aff05d4140-y62wsw_fw192" alt="search"></p>
<h2 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h2><h3 id="首先登录百度统计"><a href="#首先登录百度统计" class="headerlink" title="首先登录百度统计"></a>首先登录<a href="http://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a></h3><p>注意这个账号不是你的百度账号（搞不懂为什么明明是一家人不用一组账号…），之后跳出来的页面中，只需要复制<code>hm.js?</code>后面的id即可</p>
<h3 id="编辑主题配置文件"><a href="#编辑主题配置文件" class="headerlink" title="编辑主题配置文件"></a>编辑主题配置文件</h3><p>修改<code>baidu_analytics</code>的值为你之前复制的id即可</p>
<h3 id="最后成果"><a href="#最后成果" class="headerlink" title="最后成果"></a>最后成果</h3><p>当我兴高采烈地弄完上面的步骤后发现还是不对，始终没有刷新出来，后来才恍然大悟，原来我还是在用本地的seerver看，而百度的服务是针对你的网站本身的，所以在上传之后应该是可以成功显示百度统计的功能的</p>
<h2 id="评论区"><a href="#评论区" class="headerlink" title="评论区"></a>评论区</h2><blockquote>
<p>在参考了网上的多篇文章之后，最终还是决定使用<a href="https://livere.com/" target="_blank" rel="noopener">来必力</a></p>
</blockquote>
<p>原因有几点</p>
<ol>
<li>界面好看</li>
<li>没有奇怪的标语</li>
<li>UI美观</li>
</ol>
<h3 id="登录来必力，获取id"><a href="#登录来必力，获取id" class="headerlink" title="登录来必力，获取id"></a>登录<a href="https://livere.com/" target="_blank" rel="noopener">来必力</a>，获取id</h3><blockquote>
<p>注册时可能需要梯子</p>
</blockquote>
<p>来必力的官网有点奇怪，明明都是正常的中文，但是在登录时会莫名其妙地切换成汉语，原本是打算在chromedev里更改html的head里的<code>lang</code>为<code>ko</code>然后让Chrome自动翻译，但是这个方法行不通，它需要页面一开始加载时<code>lang</code>值更改才会出现需要翻译的提示。当然我们也可以选择百度翻译，这才知道原来是向我的邮箱里发送了验证码，一番折腾之后终于得到了id</p>
<h3 id="编辑主题配置文件-1"><a href="#编辑主题配置文件-1" class="headerlink" title="编辑主题配置文件"></a>编辑主题配置文件</h3><p>编辑<code>livere_uid</code>字段如下</p>
<p><code>livere_uid: #your livere_uid</code>    </p>
<h2 id="文章内链接颜色修改"><a href="#文章内链接颜色修改" class="headerlink" title="文章内链接颜色修改"></a>文章内链接颜色修改</h2><p>实际上就是修改css的事，只要知道了css的位置就能很容易地修改（但是说实话这个项目不愧是大工程，我还没讲过分类这么细的css，以后接触的项目越多应该就会习以为常吧）<br>进入文件</p>
<p><code>themes\next\source\css\_common\components\post\post.styl</code></p>
<p>在末尾加上</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文章内链接文本样式</span></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中选择<code>.post-body</code>是为了不影响标题，选择<code>p</code>是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。</p>
<h2 id="修改代码块自定义样式"><a href="#修改代码块自定义样式" class="headerlink" title="修改代码块自定义样式"></a>修改代码块自定义样式</h2><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>修改为</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Custom styles.</span></span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ff7600</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fbf7f8</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--<span class="comment">// 大代码块的自定义样式</span></span><br><span class="line"><span class="selector-class">.highlight</span>, <span class="selector-tag">pre</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span>, <span class="selector-tag">code</span>, <span class="selector-tag">pre</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d6d6d6</span>;</span><br><span class="line">&#125;--&gt;</span><br></pre></td></tr></table></figure>
<h2 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h2><p>同上，在<code>custom</code>里添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">主页文章添加阴影效果</span></span><br><span class="line"> <span class="string">.post</span> <span class="string">&#123;</span></span><br><span class="line">   <span class="attr">margin-top:</span> <span class="string">60px;</span></span><br><span class="line">   <span class="attr">margin-bottom:</span> <span class="string">60px;</span></span><br><span class="line">   <span class="attr">padding:</span> <span class="string">25px;</span></span><br><span class="line">   <span class="string">-webkit-box-shadow:</span> <span class="number">0</span> <span class="number">0</span> <span class="string">5px</span> <span class="string">rgba(202,</span> <span class="number">203</span><span class="string">,</span> <span class="number">203</span><span class="string">,</span> <span class="number">.5</span><span class="string">);</span></span><br><span class="line">   <span class="string">-moz-box-shadow:</span> <span class="number">0</span> <span class="number">0</span> <span class="string">5px</span> <span class="string">rgba(202,</span> <span class="number">203</span><span class="string">,</span> <span class="number">204</span><span class="string">,</span> <span class="number">.5</span><span class="string">);</span></span><br><span class="line">  <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="显示每篇文章的字数和大概阅读时间"><a href="#显示每篇文章的字数和大概阅读时间" class="headerlink" title="显示每篇文章的字数和大概阅读时间"></a>显示每篇文章的字数和大概阅读时间</h2><h3 id="在根目录下安装hexo-wordcount"><a href="#在根目录下安装hexo-wordcount" class="headerlink" title="在根目录下安装hexo-wordcount"></a>在根目录下安装<code>hexo-wordcount</code></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-wordcount <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<h3 id="在主题的配置文件中，修改如下"><a href="#在主题的配置文件中，修改如下" class="headerlink" title="在主题的配置文件中，修改如下"></a>在主题的配置文件中，修改如下</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>但是，如果光是这样设置，我们会发现没有单位显示。这时候打开<code>Blog\themes\next\layout\_macro\post.swig</code><br>找到</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; __('post.wordcount') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span><span class="template-variable">&#123;&#123; wordcount(post.content) &#125;&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>修改成</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; __('post.wordcount') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span><span class="template-variable">&#123;&#123; wordcount(post.content) &#125;&#125;</span><span class="xml"> 字</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>后面一个修改时间的同理，找到</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; __('post.min2read') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">   </span><span class="template-variable">&#123;&#123; min2read(post.content) &#125;&#125;</span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; __('post.min2read') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">   </span><span class="template-variable">&#123;&#123; min2read(post.content) &#125;&#125;</span><span class="xml"> 分钟</span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>事实就是修改span的内容，说起来很简单的东西，但是我发现修改了之后死活没有变化，按理来说这里的原理并不复杂应该不会有什么变数才对，后来我发现需要重新配置环境，直接刷新是不行的，关闭终端，重新<code>hexo serve</code>就ok了</p>
<h2 id="添加顶部加载条"><a href="#添加顶部加载条" class="headerlink" title="添加顶部加载条"></a>添加顶部加载条</h2><p>因为我参考的文章作者的pull request被merge了，所以现在只需要在<strong>站点配置文件</strong>中修改<code>pace</code>为<code>true</code>即可.<strong>站点配置文件</strong>里还有各种loading的主题可以选择,我把里面的主题都尝试了一遍，最终还是决定采用<code>pace-theme-minimal</code>主题。</p>
<h2 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h2><p>如果<code>hexo</code>是最新版本的话，只需要在<strong>主题配置文件</strong>里找到<code>canvas-nest</code>，将其属性改为<code>true</code>。当然，事实上文档里有很多主题，我选用的是另外一个<code>canvas-lines</code></p>
<blockquote>
<p>但是，我发现添加了动态背景之后主页文章透明度太低了，有点奇怪的感觉。那还是打开刚才的<code>costom.styl</code>,添加如下的代码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt;</span> <span class="attr">backgroung-color:</span> <span class="string">rgba(255,</span> <span class="number">255</span><span class="string">,</span> <span class="number">255</span><span class="string">,</span> <span class="number">.5</span><span class="string">);</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>我之前还奇怪为什么hexo的库里会有three，现在终于明白了，是用来当背景使用的</p>
<h2 id="推荐网站"><a href="#推荐网站" class="headerlink" title="推荐网站"></a>推荐网站</h2><p>也就是在文章的右侧可以设置推荐网站，其实很简单，打开<code>主题配置文件</code>，找到<code>links</code>,将代码更改为</p>
<h3 id="设置推荐网站"><a href="#设置推荐网站" class="headerlink" title="设置推荐网站"></a>设置推荐网站</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Blog rolls</span></span><br><span class="line"><span class="symbol">links_icon:</span> link</span><br><span class="line"><span class="symbol">links_title:</span> 不妨看看</span><br><span class="line"><span class="meta">#links_layout: block</span></span><br><span class="line"><span class="symbol">links_layout:</span> inline</span><br><span class="line"><span class="symbol">links:</span></span><br><span class="line">  小土刀: http:<span class="comment">//wdxtub.com/1997/09/11/booklist-page/</span></span><br><span class="line">  羡辙: http:<span class="comment">//zhangwenli.com/</span></span><br></pre></td></tr></table></figure>
<h2 id="修改推荐网站icon"><a href="#修改推荐网站icon" class="headerlink" title="修改推荐网站icon"></a>修改推荐网站icon</h2><p>实际上就是修改<code>不妨看看</code>前面的icon样式，默认是一个链接，在<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">font-awesome</a>中找到你喜欢的样式之后把代码拷贝，打开<code>/theme/next/layout/_macro/sidebar.swig</code>中，找到<code>blogroll</code>（这个名字是通过chrome开发者工具找到的），将部分代码修改如下</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#123;# Blogroll #&#125;</span></span><br><span class="line"><span class="xml">          </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.links %&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"links-of-blogroll motion-element </span></span></span><span class="template-variable">&#123;&#123; "links-of-blogroll-" + theme.links_layout | default('inline') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"links-of-blogroll-title"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-yourfavicon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">                </span><span class="template-variable">&#123;&#123; theme.links_title &#125;&#125;</span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"links-of-blogroll-list"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                </span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> name, link <span class="keyword">in</span> theme.links %&#125;</span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"links-of-blogroll-item"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; link &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">title</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">                </span><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里代码里的<code>fa-yourfavicon</code>就是之前说过的代码名称，改完之后重新部署即可</p>
<h2 id="更改网站icon"><a href="#更改网站icon" class="headerlink" title="更改网站icon"></a>更改网站icon</h2><p>这个折腾了我好久…</p>
<h3 id="下载图标"><a href="#下载图标" class="headerlink" title="下载图标"></a>下载图标</h3><p>在<a href="http://www.easyicon.net/" target="_blank" rel="noopener">easyicon</a>中下载一个32x32的文件，并存为<br><code>favicon.ico</code></p>
<h3 id="存入本地"><a href="#存入本地" class="headerlink" title="存入本地"></a>存入本地</h3><p>图标的存储位置一定要搞清楚，<strong>主题配置文件</strong>里的默认路径都是站点下的source里的，而且它在代码里特意注明了source里的文件夹不能取名为<code>images</code>，因为和next里的<code>images</code>冲突了，于是我在source下的文件夹取名为<code>image</code>，然后把<code>favicon.ico</code>存入这个目录下，</p>
<h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改<strong>主题配置文件</strong></h3><p>将favicon部分改为</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">favicon:</span> </span><br><span class="line">  <span class="meta">#small: /images/favicon-16x16-next.png</span></span><br><span class="line"><span class="symbol">  medium:</span> <span class="meta-keyword">/image/</span>favicon.ico</span><br><span class="line">  <span class="meta">#apple_touch_icon: /images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="meta">#safari_pinned_tab: /images/logo.svg</span></span><br><span class="line">  <span class="meta">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="meta">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>
<p>反正我是这么改的，很多人说直接写成这样的形式</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">favicon:</span> <span class="meta-keyword">/image/</span>favicon.ico</span><br></pre></td></tr></table></figure>
<p>但是我亲身尝试好像出了点问题，后台返回说路径有问题，我估计这个favicon是一个像类的东西（也有可能是改版了）,所以还是像我这样写比较稳妥</p>
<h2 id="修改Tag样式"><a href="#修改Tag样式" class="headerlink" title="修改Tag样式"></a>修改Tag样式</h2><p>修改<code>/themes/next/layout/_macro/post.swig</code>文件，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<blockquote>
<p>注意：应重启环境才能看到效果应用</p>
</blockquote>
<h2 id="每篇文章末尾统一添加本文"><a href="#每篇文章末尾统一添加本文" class="headerlink" title="每篇文章末尾统一添加本文"></a>每篇文章末尾统一添加本文</h2><p>在<code>\themes\next\layout\_macro</code>中新建<code>passage-end-tag.swig</code>文件，其中添加如下代码</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> not is_index %&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;</span>-------------本文结束,感谢您的阅读-------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-footer</code>之前添加如下代码</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> not is_index %&#125;</span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> 'passage-end-tag.swig' %&#125;</span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>最后在主题配置文件最后加入如下代码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage-endtag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>原文这里代码还打错了，我直到看了后台返回的log才知道名字拼错了。做完了以上三个步骤应该就可以实现每篇文章末尾都有指定的格式了，当然第一段html可以自拟。</p>
<h2 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> <span class="comment">--save hexo-generator-feed</span></span><br></pre></td></tr></table></figure>
<h3 id="打开站点配置文件"><a href="#打开站点配置文件" class="headerlink" title="打开站点配置文件"></a>打开站点配置文件</h3><p>找到<code>plugin</code>，修改如下</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http:<span class="comment">//hexo.io/plugins/</span></span><br><span class="line">plugins: hexo-<span class="keyword">generate</span>-feed</span><br></pre></td></tr></table></figure>
<h3 id="打开主题配置文件"><a href="#打开主题配置文件" class="headerlink" title="打开主题配置文件"></a>打开主题配置文件</h3><p>修改如下</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">Set</span> rss <span class="keyword">to</span> <span class="literal">false</span> <span class="keyword">to</span> disable feed link.</span><br><span class="line"># Leave rss as <span class="literal">empty</span> <span class="keyword">to</span> use site<span class="comment">'s feed link.</span></span><br><span class="line"># <span class="keyword">Set</span> rss <span class="keyword">to</span> specific value <span class="keyword">if</span> you have burned your feed already.</span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure>
<p>修改完之后<code>hexo g</code>，然后重新配置环境，应该就有rss的效果了</p>
<blockquote>
<p>直接点击RSS图标是没用的，应该复制链接然后在RSS软件中订阅</p>
</blockquote>
<h2 id="文章写作方式"><a href="#文章写作方式" class="headerlink" title="文章写作方式"></a>文章写作方式</h2><p>这个严格意义上来说不算是配置，而是一种写作习惯，但是我觉得作者这样的方式非常优雅，于是我也决定采用，就是每篇文章<code>more</code>之前的部分，用<strong>blockquote</strong>来表示</p>
<h2 id="更改默认的markdown渲染css"><a href="#更改默认的markdown渲染css" class="headerlink" title="更改默认的markdown渲染css"></a>更改默认的markdown渲染css</h2><p>最开始有这个想法的初衷是觉得<code>next</code>的<code>blockquote</code>太丑了，颜色不够好看。改起来其实很简单，重要的是找到css文件的位置，我自己并没有找到…因为那些文件名都太具有迷惑性了，但是我百度了<strong>hexo next的blockquote</strong>成功地找到了管理markdown文件的css路径</p>
<p><code>\themes\next\source\css\_common\scaffolding\base.styl</code></p>
<p>找到了就好办，打开文件，搜索关键词<code>blockquote</code>，修改<code>border-left</code>属性为<code>border-left: 4px solid rgb(134,206,236);</code></p>
<h2 id="修改默认的代码高亮"><a href="#修改默认的代码高亮" class="headerlink" title="修改默认的代码高亮"></a>修改默认的代码高亮</h2><p>原版的代码高亮配色不太美观，虽然有多种主题可以换，但是都不太如人意。这里我在一个hexo的主题<a href="https://molunerfinn.com/hexo-theme-melody-doc/#/" target="_blank" rel="noopener">melody</a>里扒了一个highlight配色下来，代码如下</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="variable">$highlight</span>-<span class="attribute">background</span> = <span class="number">#F6F8FA</span></span><br><span class="line"> <span class="variable">$highlight</span>-current-line = <span class="number">#00346e</span></span><br><span class="line"> <span class="variable">$highlight</span>-selection = <span class="number">#80CBC4</span>40</span><br><span class="line"> <span class="variable">$highlight</span>-foreground = <span class="number">#90A4AE</span></span><br><span class="line"> <span class="variable">$highlight</span>-comment = <span class="number">#90A4AE</span>90</span><br><span class="line"> <span class="variable">$highlight</span>-red = <span class="number">#E53935</span></span><br><span class="line"> <span class="variable">$highlight</span>-orange = <span class="number">#F76D47</span></span><br><span class="line"> <span class="variable">$highlight</span>-yellow = <span class="number">#FFB62C</span></span><br><span class="line"> <span class="variable">$highlight</span>-green = <span class="number">#91B859</span></span><br><span class="line"> <span class="variable">$highlight</span>-aqua = <span class="number">#39ADB5</span></span><br><span class="line"> <span class="variable">$highlight</span>-blue = <span class="number">#6182B8</span></span><br><span class="line"> <span class="variable">$highlight</span>-purple = <span class="number">#7C4DFF</span></span><br><span class="line"> <span class="variable">$highlight</span>-gutter = &#123;</span><br><span class="line">   <span class="attribute">color</span>: <span class="number">#CFD8DC</span>,</span><br><span class="line">   bg-<span class="attribute">color</span>: <span class="variable">$highlight</span>-background</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>找到存储highlight的文件<code>hexo-site/themes/next/source/css/_common/components/highlight/theme.styl</code>里，将<code>normal</code>里的代码替换成上述代码即可</p>
<h2 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h2><p>我主要参考的教程里的鼠标点击特效太水了，本来也淡了做这个特效的心思的，但是在偶然间预览到<a href="https://molunerfinn.com/" target="_blank" rel="noopener">melody</a>这个hexo主题时，迅速被里面的鼠标点击特效震撼到了，太炫酷了，妈妈我要学这个。点进了文档里没有看到这个技术的细节，只是提到了<a href="http://animejs.com/" target="_blank" rel="noopener">anime.js</a>,遂顺藤摸瓜找到了<code>anime</code>的官网，发现这是一个提供做js动画的库，并不是我想要的特效，就在我迷茫时，突然发现<code>anime</code>的<a href="http://animejs.com/" target="_blank" rel="noopener">官网</a>上用的就是这个特效，点开<code>chrome-dev</code>，大概看了一下，引用了两个js文件，<code>anime.js</code>和<code>fireworks.js</code>,后者就是我想要的效果！马上写了个html测试一下，很遗憾，不行，点开控制台，发现是没有canvas元素，在html中按官网的样子加入了一个canvas。这下特效有了，但是控制台还是会报错，原因是<code>ga</code>函数找不到，再一看ga函数源于一个叫<code>analytics</code>的js文件，可是开发者工具的sources栏里好像没看到有这个js，无奈只能点进去，发现是动态引用的，但是无所谓了，没有这个函数特效一样能够工作。于是就把官网上的<code>fireworks.js</code>下载了下来，并且把使用到ga函数的部分给注释掉。最后，在新建的html上调试成功。可是噩梦才刚刚开始，后面省略无数个字，摸索了一整天才把这个搞好，现在开始。</p>
<h3 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h3><p>在<a href="http://animejs.com/" target="_blank" rel="noopener">anime的官网</a>页面上，打开<code>chrome开发者工具</code>，在sources里把一下两个文件找到，并且下载到本地</p>
<ul>
<li><code>fireworks.js</code></li>
<li><code>anime.js</code></li>
</ul>
<p>存入本地的路径为<code>hexo-site/themes/next/source/js/src/</code></p>
<h3 id="编辑-layout文件"><a href="#编辑-layout文件" class="headerlink" title="编辑_layout文件"></a>编辑_layout文件</h3><p>之前已经在自己原来写过的静态网站上测试过了，想要实现鼠标点击的烟花特效，做完以下几步即可</p>
<h4 id="html中新建canvas-属性如下"><a href="#html中新建canvas-属性如下" class="headerlink" title="html中新建canvas,属性如下"></a>html中新建<code>canvas</code>,属性如下</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;canvas</span> <span class="string">class="fireworks"</span> <span class="string">style="width:</span> <span class="string">1226px;</span> <span class="attr">height:</span> <span class="string">680px;position:</span> <span class="string">fixed;left:</span> <span class="number">0</span><span class="string">;top:</span> <span class="number">0</span><span class="string">;</span> <span class="attr">z-index:</span> <span class="number">1</span><span class="string">;</span> <span class="attr">pointer-events:</span> <span class="string">none"</span> <span class="string">&gt;&lt;/canvas&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里面有几个属性要特别注意，一个是class名为<code>fireworks</code>，一个是position设为<code>fixed</code>，最重要的是设置<code>pointer-event</code>属性，这个属性能让你的鼠标点击穿透这个canvas直到下层，这个非常关键，不然的话你把canvas放在上面，下面的链接全都点不了了</p>
<h4 id="在body末尾先后引入anime-js-fireworks-js"><a href="#在body末尾先后引入anime-js-fireworks-js" class="headerlink" title="在body末尾先后引入anime.js,fireworks.js"></a>在<code>body</code>末尾先后引入<code>anime.js</code>,<code>fireworks.js</code></h4><p>一定要注意顺序，anime要先引入不然会出错，而且要放在dom后，不然会出现引用错误。这两步做完就可以实现功能了</p>
<h4 id="在-layout文件中作出上述修改"><a href="#在-layout文件中作出上述修改" class="headerlink" title="在_layout文件中作出上述修改"></a>在<code>_layout</code>文件中作出上述修改</h4><p>其实做个小测试很简单，但是如何将这个功能引入我们的网站就比较麻烦了，因为如果要在网站上实现效果，就必须修改所有的html。我想到这既然是一个框架，那么html应该有个模板，事实上这个模板就是<code>_layout.swig</code>,这个文件位于<code>hexo-site/themes/next/layout/</code>下。花了大概十分钟把这个文件看明白，然后在文件的最后引入这两个js,并且在开头（<code>body</code>元素后面）引入我们之前提到过的canvas应该就可以了.</p>
<h4 id="使canvas的尺寸自适应"><a href="#使canvas的尺寸自适应" class="headerlink" title="使canvas的尺寸自适应"></a>使canvas的尺寸自适应</h4><p>我之前提到过的canvas的大小是写死的，这样不仅不优雅，而且不能实现响应式布局，还是在<code>_layout.swig</code>文件里，在所有的dom元素后面添加一段</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">　　<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">　　　　<span class="comment">//resize canvas</span></span></span><br><span class="line"><span class="javascript">　　　　$(<span class="built_in">window</span>).resize(resizeCanvas);  </span></span><br><span class="line">   </span><br><span class="line"><span class="actionscript"> <span class="function"><span class="keyword">function</span> <span class="title">resizeCanvas</span><span class="params">()</span> </span>&#123;  </span></span><br><span class="line"><span class="javascript"> 		  <span class="keyword">var</span> canvas= $(<span class="string">'.fireworks'</span>)[<span class="number">0</span>];</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">        canvas.height = <span class="built_in">window</span>.innerHeight;  </span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">        canvas.width = <span class="built_in">window</span>.innerWidth; </span></span><br><span class="line">        </span><br><span class="line"><span class="actionscript">        <span class="comment">//console.log(canvas.width,canvas.height);</span></span></span><br><span class="line"> &#125;;  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就能实现canvas自适应布局了</p>
<h2 id="修改footer栏"><a href="#修改footer栏" class="headerlink" title="修改footer栏"></a>修改footer栏</h2><p>原版的footer栏太丑了，决定好好修饰一下</p>
<h3 id="删除hexo和next信息"><a href="#删除hexo和next信息" class="headerlink" title="删除hexo和next信息"></a>删除hexo和next信息</h3><p>找到<code>themes/next/layout/_partials/footer.swig</code>,打开编辑，删除class为<code>powered-by</code>和<code>theme-info</code>的相关dom（怎么总有种过河拆桥的感觉…）</p>
<h3 id="文字居中"><a href="#文字居中" class="headerlink" title="文字居中"></a>文字居中</h3><p>在<code>footer.swig</code>里直接添加样式竟然没有效果，点开开发者工具才知道原来<code>footer-inner</code>这个类已经继承了<code>text-align:left</code>的属性（很好奇为什么我直接改写覆盖不了）,好嘛，干脆换个地方修改好了。打开<code>\themes\next\source\css\_custom\custom.styl</code>，添加如下代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.footer-inner</span> &#123;</span><br><span class="line">   <span class="attribute">text-align</span>: center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改用户名图标"><a href="#修改用户名图标" class="headerlink" title="修改用户名图标"></a>修改用户名图标</h3><p>这里引用的技术是<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">font-awesome</a>，说实话我还是第一次接触这个，据说是为<code>bootstrap</code>设计的框架，但是我被它的简介和强大性震撼到了，不需要配置路径，下载文件什么的，只需要首先在<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">官网</a>上选择你喜欢的icon，在html中引用js之后，随便新建一个元素（官网建议最好是<code>i</code>，因为比较简介），然后设置<code>class</code>格式为<code>fa icon-name</code>，这里的<code>icon-name</code>是官网上选定元素之后会告诉你的名字，icon就出现了，<strong>简洁且强大</strong>。回到本文，按下面几个步骤进行：</p>
<ul>
<li>上<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">官网</a>选择你喜欢的icon，把名字记下来</li>
<li>打开<code>主题配置文件</code>，搜索<code>footer</code>下的<code>icon</code>，将其值修改为你刚才找到的icon名</li>
<li>大功告成</li>
</ul>
<h2 id="修改文章的阅读全文"><a href="#修改文章的阅读全文" class="headerlink" title="修改文章的阅读全文"></a>修改文章的阅读全文</h2><p>这个特效我是看别人的博客里有的，觉得很炫酷，但是网上好像没有相应的教程，学习了这么多配置，干脆自己也来个DIY好了</p>
<h3 id="首先找到相应的css文件"><a href="#首先找到相应的css文件" class="headerlink" title="首先找到相应的css文件"></a>首先找到相应的css文件</h3><p>当然，在这之前先确定好元素的名称，好在css里找对应，使用<code>chrome开发者工具</code>，发现这个阅读全文的按钮class为<code>post-button</code>，在<code>css</code>文件夹下找，最终在路径为<code>themes/next/source/css/_schemes/Mist/_posts-expanded.styl</code>（我的主题是Mist）</p>
<h3 id="修改css代码"><a href="#修改css代码" class="headerlink" title="修改css代码"></a>修改css代码</h3><p>然后修改其中<code>.post-button</code>的代码如下</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-button</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$font-size-base</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">2s</span> ease</span><br><span class="line"></span><br><span class="line">    +mobile() &#123; font-size: <span class="variable">$font-size-small</span>; &#125;</span><br><span class="line">    +desktop-large() &#123; <span class="attribute">font-size</span>: <span class="variable">$font-size-large</span>; &#125;</span><br><span class="line"></span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;<span class="attribute">background-color</span>: <span class="number">#000</span>;<span class="attribute">color</span>: <span class="number">#fff</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的效果如图</p>
<p><img src="http://img.hb.aicdn.com/52e7277a5b2faf747534f8d2bda62a6ca8d5bd683ffed-DuL5ZB_sq180" alt></p>
<h2 id="将自己写的html托管在hexo下"><a href="#将自己写的html托管在hexo下" class="headerlink" title="将自己写的html托管在hexo下"></a>将自己写的html托管在hexo下</h2><h3 id="hexo文件运作"><a href="#hexo文件运作" class="headerlink" title="hexo文件运作"></a>hexo文件运作</h3><p>首先应该把hexo的文件规律搞清楚。总共有两套文件体系，一个是本地的，另外一个是上传至github上的。后者实际上就是本地的<code>public</code>部分，也就是每次<code>hexo g</code>之后生成的文件夹。</p>
<p>每次<code>hexo g</code>之后，它就是会把所有<code>hexo-site/source</code>下的文件全部渲染一遍变成<code>public</code>里的文件，也就是说，想要托管自己的html，就需要把html放在这个文件夹下。</p>
<h3 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h3><p>在<code>hexo-site/source</code>下新建文件夹，像我就是建立了一个<code>demo</code>,路径为<code>hexo-site/source/demo</code>,新建的html放在里面就可以了，比如我把我这个学期写的地图放了进去<code>gdMap.html</code></p>
<h3 id="在站点配置文件中取消对这个文件夹的渲染"><a href="#在站点配置文件中取消对这个文件夹的渲染" class="headerlink" title="在站点配置文件中取消对这个文件夹的渲染"></a>在站点配置文件中取消对这个文件夹的渲染</h3><p>光是把路径确定好了还不够，因为<code>hexo</code>默认是会对所有的<code>html</code>按它的格式来渲染的，我们需要在<code>站点配置文件</code>中找到<code>skip-render</code>,修改代码如下</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">skip_render:</span> demo<span class="comment">/*</span></span><br></pre></td></tr></table></figure>
<p>表示对demo下所有的文件都不渲染，当然这里也可以根据自己的需求来改写，比如<code>skip_render: demo/*.html</code>(只是取消对<code>html</code>文件的渲染)</p>
<h3 id="在md文件中引用html"><a href="#在md文件中引用html" class="headerlink" title="在md文件中引用html"></a>在<code>md</code>文件中引用html</h3><p>像这样的格式引用即可<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接</span>](<span class="link">/demo/gdMap.html</span>)`</span><br></pre></td></tr></table></figure></p>
<h2 id="DIY规律"><a href="#DIY规律" class="headerlink" title="DIY规律"></a>DIY规律</h2><p>做了这么多配置基本上对整体的流程也很清楚了，自己DIY了几个选项效果也很好，基本上DIY配置的话规律如下</p>
<h3 id="修改CSS"><a href="#修改CSS" class="headerlink" title="修改CSS"></a>修改CSS</h3><p>进入<code>/theme/next/sources/css</code>下，找到对应的<code>styl</code>文件进行修改，实在不行可以在这个目录下的<code>_custom</code>下修改，这个css文件应该具有覆盖的最高权限。</p>
<h3 id="修改DOM（比如修改图标）"><a href="#修改DOM（比如修改图标）" class="headerlink" title="修改DOM（比如修改图标）"></a>修改DOM（比如修改图标）</h3><blockquote>
<p>注：修改css之后直接刷新页面就可以看到效果，因为css是即时渲染的，但是修改dom不可以，必须重新<code>hexo server</code> </p>
</blockquote>
<p>有两种方法，不过我自己想了想，如果两种方法都能实现的情况下还是推荐使用第二种，更标准，符合软件工程规范</p>
<h3 id="修改-swig文件"><a href="#修改-swig文件" class="headerlink" title="修改.swig文件"></a>修改<code>.swig</code>文件</h3><p>虽然我之前没接触过此类文件，但是在修改过几个配置之后发现这实际上就一个dom预编译软件（我自己根据sass之类的猜测的），这个文件里是最直接的dom模板，但缺点是除非是新建元素，否则不建议直接修改这里的元素，把东西写死了很难看，而且和系统的文件风格不一致</p>
<h3 id="修改主题配置文件-1"><a href="#修改主题配置文件-1" class="headerlink" title="修改主题配置文件"></a>修改<code>主题配置文件</code></h3><p><code>next</code>主题的作者就很小心我之前说的问题，它把可配置的选项都写进了<code>主题配置文件</code>，如果想修改直接在主题配置文件里修改即可，简单且耦合性弱，不容易出错。可惜的是我之前有些地方就没这么做，现在再修改也比较麻烦，只能以后注意了</p>
<blockquote>
<p>在修改<code>.swig</code>时注意，如果欲修改的配置选项是以<code>宏引用</code>的形式调用的话，放弃修改<code>.swig</code>文件，直接在<code>主题配置文件</code>里修改你想要的配置</p>
</blockquote>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>花了很大的功夫配置了这么些，七成是跟着教程做的，三成是自己摸索的。全部过了一遍之后，一方面是增进了自己的信心，另一方面就是了解了大概的框架，以后想要自己diy一些部分也很容易。目前来说这些功能应该是够用了，以后有需要的话再添加吧.</p>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>《图解HTTP》读后总结</title>
    <url>/2018/05/13/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>6月份开始的一个比赛需要网络方面的知识，但是限于专业和自己的懒惰，自己一直对计算机网络的知识处于一个一知半解的程度，正好掏出买了半年但一直没看的书，从头到尾梳理一遍。顺便下次组会展示的时候科普一下网络的知识。</p>
</blockquote>
<a id="more"></a>
<h1 id="1-了解Web和网络技术基础"><a href="#1-了解Web和网络技术基础" class="headerlink" title="1.了解Web和网络技术基础"></a>1.了解Web和网络技术基础</h1><p>为了了解HTTP，我们有必要事先理解一下TCP/IP协议族。</p>
<h2 id="1-1-网络基础TCP-IP"><a href="#1-1-网络基础TCP-IP" class="headerlink" title="1.1 网络基础TCP/IP"></a>1.1 网络基础TCP/IP</h2><p>通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的，而HTTP是它内部的一个集。</p>
<p>计算机和网络设备之间要互相通信，双方就必须基于相同的方法，比如如何探测通信目标，由哪一边先发起通信，使用哪种语言进行通信，都需要事先制定。不同的硬件，操作系统之间的通信，所有的这一切都需要一种规则，我们就讲这些规则称之为<strong>协议</strong></p>
<blockquote>
<p>将所有与互联网相关联的协议集合起来，总称为TCP/IP</p>
</blockquote>
<h3 id="1-1-1-TCP-IP的分层管理"><a href="#1-1-1-TCP-IP的分层管理" class="headerlink" title="1.1.1 TCP/IP的分层管理"></a>1.1.1 TCP/IP的分层管理</h3><p><strong>分层的好处</strong>：相当于是模块化管理，方便改进和修改</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><blockquote>
<p>应用层决定了向用户提供应用服务时通信的活动</p>
</blockquote>
<p>顾名思义，实际上就是应用的层面，属于抽象等级最高的一阶。比如<a href="https://baike.baidu.com/item/FPT/4424643?fr=aladdin" target="_blank" rel="noopener">FTP</a>，<a href="https://baike.baidu.com/item/dns/427444" target="_blank" rel="noopener">DNS</a>，<a href="https://baike.baidu.com/item/SMTP/175887" target="_blank" rel="noopener">SMTP</a>，HTTP等常见的服务。</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><blockquote>
<p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输</p>
</blockquote>
<p>说起来很抽象，实际上就是TCP和UDP，就是制定了在传输数据时，每个计算机应该使用什么样的协议</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><blockquote>
<p>网络层处理在网络上流动的数据包。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。</p>
</blockquote>
<h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><blockquote>
<p>用来处理网络的硬件部分</p>
</blockquote>
<p>这个就相对easy了，可以简单理解为计算机网络在物理的层面。</p>
<p>此外，我个人还对<strong>网络层</strong>和<strong>传输层</strong>之间的区别不是很清楚，但是看了下面一个例子之后，瞬间明白了</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526261983229.png" alt></p>
<blockquote>
<p>说白了，网络层是负责不同计算机之间的信息传递，而传输层则是细到了进程级别</p>
</blockquote>
<h3 id="1-1-2-TCP-IP通信传输流"><a href="#1-1-2-TCP-IP通信传输流" class="headerlink" title="1.1.2 TCP/IP通信传输流"></a>1.1.2 TCP/IP通信传输流</h3><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526194008306.png" alt><br>发送端在层与层之间传输数据时，都会加上一个本层所属的首部信息。反之，接收端在层与层之间传输数据时，就会消去</p>
<h2 id="1-2-与HTTP关系密切的协议"><a href="#1-2-与HTTP关系密切的协议" class="headerlink" title="1.2 与HTTP关系密切的协议"></a>1.2 与HTTP关系密切的协议</h2><h3 id="1-2-1-IP协议"><a href="#1-2-1-IP协议" class="headerlink" title="1.2.1 IP协议"></a>1.2.1 IP协议</h3><blockquote>
<p>注意！这里的IP指协议，我们平时说的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80/150859" target="_blank" rel="noopener">IP</a>是IP地址。</p>
</blockquote>
<p>此处IP全称为网络协议，几乎所有使用网络的系统都会用到IP协议。其作用就是把各种数据发给对方。此时，如果想要保证确保数据包能到对方那里，需要满足各种条件，其中最重要的两个是<strong>IP地址</strong>和<strong>MAC</strong>地址。</p>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><blockquote>
<p>IP地址是指互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。目前还有些ip代理软件，但大部分都收费。</p>
</blockquote>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><blockquote>
<p>MAC（Media Access Control或者Medium Access Control）地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。 [1]<br>MAC地址是网卡决定的，是固定的。</p>
</blockquote>
<p>举一个例子，我们可以把计算机之间的信息传输理解为快递的流程，买方想通过物流将商品交到顾客的手上，这个时候，Ip地址可以理解为顾客的地址，Mac地址可以理解为顾客的身份证号（或者可以理解为任何可以唯一表示顾客的特征，比如外貌+姓名）</p>
<p>为什么在传输过程中我们需要ip和mac两种地址？</p>
<p>￼<img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526198406978.png" alt></p>
<h3 id="1-2-2-TCP协议"><a href="#1-2-2-TCP协议" class="headerlink" title="1.2.2 TCP协议"></a>1.2.2 TCP协议</h3><p>tcp处于传输层中，提供可靠的字节流服务。其中<strong>可靠</strong>是指，能够将数据准确可靠地传给对方，所以相应地，与tcp对应的是udp，它的特点就是不管对方是否能接收到数据，都一股脑地都把数据传过去再说。<strong>字节流服务</strong>是指，为了方便传输而将大块数据分割成以报文段为单位的数据包进行管理。</p>
<h4 id="tcp的三次握手"><a href="#tcp的三次握手" class="headerlink" title="tcp的三次握手"></a>tcp的三次握手</h4><p>tcp协议为什么能够准确无误地将数据传送到目标处？就在于它采用了<strong>三次握手</strong>的策略</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526198697091.png" alt></p>
<p>开始之前，首先声明，TCP的两种标志SYN（同步）和ACK（理解）</p>
<ol>
<li>发送端发送一个标记syn（记为j）的数据包给对方</li>
<li>接收端接到以后，再反向发一个syn（j+1）和ack（记为k）标志的数据包给对方</li>
<li>发送端收到以后，再向接收端发一个ACK（k+1）的数据包给接收端。至此完成3次握手</li>
</ol>
<blockquote>
<p>若是在握手过程中莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p>
</blockquote>
<h3 id="1-2-3-DNS服务"><a href="#1-2-3-DNS服务" class="headerlink" title="1.2.3 DNS服务"></a>1.2.3 DNS服务</h3><p>这个相对来说是个老朋友了，它和HTTP一样都是出于四层结构中的应用层，主要功能是<strong>提供域名到IP地址之间的转化服务</strong>。</p>
<p>一般来说，我们在web中想要获取某项资源，都是以域名的形式来访问，这主要是因为相对于IP地址，用字母配合数字的表达形式来指定计算机名更加符合人类的记忆习惯</p>
<p>比如我们想要访问百度，我们在浏览器中输入<a href="http://www.baidu.com，这个请求实际上首先是前往了DNS服务器，解析成了对应的IP地址，然后再进入正常的网络通信流程" target="_blank" rel="noopener">http://www.baidu.com，这个请求实际上首先是前往了DNS服务器，解析成了对应的IP地址，然后再进入正常的网络通信流程</a></p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526199225187.png" alt></p>
<h4 id="DNS污染和DNS劫持"><a href="#DNS污染和DNS劫持" class="headerlink" title="DNS污染和DNS劫持"></a>DNS污染和DNS劫持</h4><p><strong>DNS污染</strong>指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。范例，访问Youtube、Facebook之类网站等出现的状况。</p>
<p><strong>DNS劫持</strong>就是指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。范例，网通、电信、铁通的某些用户有时候会发现自己打算访问一个地址，却被转向了各种推送广告等网站，这就是DNS劫持。</p>
<h2 id="1-3各种协议与HTTP协议的关系"><a href="#1-3各种协议与HTTP协议的关系" class="headerlink" title="1.3各种协议与HTTP协议的关系"></a>1.3各种协议与HTTP协议的关系</h2><blockquote>
<p>本章最重要的一张图</p>
</blockquote>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526199438621.png" alt></p>
<h2 id="1-4-URL和URI"><a href="#1-4-URL和URI" class="headerlink" title="1.4 URL和URI"></a>1.4 URL和URI</h2><h3 id="1-4-1-两者的区别"><a href="#1-4-1-两者的区别" class="headerlink" title="1.4.1 两者的区别"></a>1.4.1 两者的区别</h3><p>uri（统一资源标识符），url（统一资源定位符）。url更为我们所熟知，其正是使用web浏览器来访问页面时需要输入的网页地址。</p>
<p>后者是前者的子集，前者的特点是可以唯一表示一种资源，但其表现形式不局限于后面哪一种，有的时候用前者表示的资源可能在某一命名空间中，但其不代表网络地址</p>
<blockquote>
<p>urn:issn:1535-3611</p>
</blockquote>
<h3 id="1-4-2-url的结构"><a href="#1-4-2-url的结构" class="headerlink" title="1.4.2 url的结构"></a>1.4.2 url的结构</h3><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526200119436.png" alt></p>
<h1 id="2-简单的HTTP协议"><a href="#2-简单的HTTP协议" class="headerlink" title="2. 简单的HTTP协议"></a>2. 简单的HTTP协议</h1><h2 id="2-1-HTTP协议用于客户端与服务器之间的通信"><a href="#2-1-HTTP协议用于客户端与服务器之间的通信" class="headerlink" title="2.1 HTTP协议用于客户端与服务器之间的通信"></a>2.1 HTTP协议用于客户端与服务器之间的通信</h2><blockquote>
<p>请求访问文本或者图像等资源的一端称之为客户端</p>
</blockquote>
<blockquote>
<p>提供资源相应的一端称之为服务器端</p>
</blockquote>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526262272192.png" alt></p>
<h2 id="2-2-HTTP是不保存状态的协议"><a href="#2-2-HTTP是不保存状态的协议" class="headerlink" title="2.2 HTTP是不保存状态的协议"></a>2.2 HTTP是不保存状态的协议</h2><p>HTTP是一种<strong>无状态协议</strong>，也就是说HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526262386148.png" alt></p>
<p>这样做有好处即能够快速处理大量事物，确保协议的可伸缩性。但是坏处就是无法保存登录状态（这个用cookie实现了）</p>
<h2 id="2-3-HTTP方法"><a href="#2-3-HTTP方法" class="headerlink" title="2.3 HTTP方法"></a>2.3 HTTP方法</h2><ol>
<li>GET</li>
<li>POST<br>（知道上述两者即可，剩下的几乎用不到，需要用到的时候再查）</li>
</ol>
<h2 id="2-4-持久连接"><a href="#2-4-持久连接" class="headerlink" title="2.4 持久连接"></a>2.4 持久连接</h2><h3 id="2-4-1-持久连接的提出"><a href="#2-4-1-持久连接的提出" class="headerlink" title="2.4.1 持久连接的提出"></a>2.4.1 持久连接的提出</h3><p>HTTP协议的初始版本中，每进行一次通信就需要断开一次TCP连接</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526262602095.png" alt></p>
<p>这样做的后果就是，小容量的文本传输倒也没什么，但是随着HTTP的普及，文档中包含大量图片的情况多了起来，这个时候每次请求都会造成无谓的TCP断开和重连，<strong>增加通信量的开销</strong></p>
<p>为了解决上述问题，持久连接的方法被踢了出来，它的特点是</p>
<blockquote>
<p>只要任意一段没有明确提出断开连接，则保持TCP连接状态</p>
</blockquote>
<p>这么做的好处是减少了TCP链接的重复建立和断开的开销，减轻了服务器端的负载。</p>
<h3 id="2-4-2-管线化"><a href="#2-4-2-管线化" class="headerlink" title="2.4.2 管线化"></a>2.4.2 管线化</h3><p>持久连接使得多数请求能够以管线化的方式发送成为可能，跟多线程类似，我们不需要一个接一个地等待响应就可以直接发送下一个请求，又一次提高了http通信的效率</p>
<h2 id="2-5-使用cookie的状态管理"><a href="#2-5-使用cookie的状态管理" class="headerlink" title="2.5 使用cookie的状态管理"></a>2.5 使用cookie的状态管理</h2><p>http本身是<strong>无记忆</strong>的，这个时候在处理一些需要登录验证的页面就无法应对，此时我们引入了cookie技术。cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。</p>
<p>服务器端会发送一个set-cookie的首部字段信息，通知客户端保存cookie，等下次客户端再向服务器端发送请求时，其会自动在请求报文中加入cookie值。</p>
<p>这时服务器发现cookie之后，会去检查到底是哪一个客户端发来的请求，然后对比服务器上的记录，最后得到该客户端的登录状态信息。</p>
<h1 id="3-HTTP报文内的HTTP信息"><a href="#3-HTTP报文内的HTTP信息" class="headerlink" title="3. HTTP报文内的HTTP信息"></a>3. HTTP报文内的HTTP信息</h1><h2 id="3-1-HTTP报文的结构"><a href="#3-1-HTTP报文的结构" class="headerlink" title="3.1 HTTP报文的结构"></a>3.1 HTTP报文的结构</h2><p>emm实际这个部分如果写过爬虫的话应该会很熟悉了</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526263911192.png" alt></p>
<h2 id="3-2-编码提升传输速率"><a href="#3-2-编码提升传输速率" class="headerlink" title="3.2 编码提升传输速率"></a>3.2 编码提升传输速率</h2><p>HTTP在传输数据时可以直接发送原数据，但是也可以在传输过程中通过编码来提升传输速率，但是同时编码的操作在本地完成，需要消耗一定程度的CPU</p>
<h3 id="3-2-1-报文和实体的区别"><a href="#3-2-1-报文和实体的区别" class="headerlink" title="3.2.1 报文和实体的区别"></a>3.2.1 报文和实体的区别</h3><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526264151128.png" alt></p>
<p>我个人的感觉是，实体就是原始数据，包括实体首部和实体主体，报文是实体编码之后，在信息传输途中的形式</p>
<h3 id="3-2-2-分割发送的分块传输编码"><a href="#3-2-2-分割发送的分块传输编码" class="headerlink" title="3.2.2 分割发送的分块传输编码"></a>3.2.2 分割发送的分块传输编码</h3><p>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。HTTP中存在一种称为传输编码的机制，专门应用于分块传输。</p>
<h2 id="3-3-获取部分内容的范围请求"><a href="#3-3-获取部分内容的范围请求" class="headerlink" title="3.3 获取部分内容的范围请求"></a>3.3 获取部分内容的范围请求</h2><p><span id="rangeRequest"></span><br>我们在平时肯定遇到过这样的情况：使用浏览器下载某项文件，中途中断了，此时再次下载从头开始显然非常可惜，一般情况下如果时间没有过的太久，浏览器会自动帮我们提供从中断处开始下载的功能。</p>
<p>要实现该功能需要指定下载的范围，我们称之为<strong>范围请求</strong>，我们只需要在head里加入如下<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526264594986.png" alt></p>
<p>范围的制定方式如下<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526264653159.png" alt></p>
<h2 id="3-4内容协商"><a href="#3-4内容协商" class="headerlink" title="3.4内容协商"></a>3.4内容协商</h2><p>当浏览器的默认语言为中文或者英文时，访问相同url的web网页则会显示对应的英文版或者中文版，这样的机制我们称之为<strong>内容协商</strong></p>
<blockquote>
<p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，其会以语言，字符集，编码方式等为基准来判断响应的资源。同样的我们可以通过修改一些报文的首部来作为请求协商的手段</p>
</blockquote>
<p>内容协商分为3类</p>
<ol>
<li>服务器驱动协商（即由服务器来决定，但并不一定是最佳选择）</li>
<li>客户端驱动协商（即由客户端来决定，比如切换成pc版或者移动端）</li>
<li>透明协商（双方共同协商）</li>
</ol>
<h1 id="4-返回结果的HTTP状态码"><a href="#4-返回结果的HTTP状态码" class="headerlink" title="4. 返回结果的HTTP状态码"></a>4. 返回结果的HTTP状态码</h1><blockquote>
<p>http服务器端返回的状态码的作用就是，通过它的描述，拥护可以知道服务器端对自己的请求处理的状态</p>
</blockquote>
<h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><p>这个系列的状态码都表示请求被正常处理了</p>
<h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p>表示客户端发来的请求被正常处理了，这种情况一般是最“好”的结果</p>
<h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p>表示服务器已成功处理请求，但是没有任何实体返回，页面不更新。一般用于客户端单方向向服务器发送信息</p>
<h3 id="206-Partical-Content"><a href="#206-Partical-Content" class="headerlink" title="206 Partical Content"></a>206 Partical Content</h3><p>表示客户端进行了<a href="#rangeRequest">范围请求</a>,而服务器成功执行了这个请求</p>
<h2 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h2><p>这个系列表示浏览器需要执行某些特殊的处理以正常处理请求</p>
<h3 id="301-Moved-Permantly"><a href="#301-Moved-Permantly" class="headerlink" title="301 Moved Permantly"></a>301 Moved Permantly</h3><p>永久性重定向，表示请求的资源已被分配了新的url，以后使用该资源时应该使用现在给的url（以报文首部的location字段里给出来了）</p>
<h3 id="302-Not-Found"><a href="#302-Not-Found" class="headerlink" title="302 Not Found"></a>302 Not Found</h3><p>临时性重定向，希望用户本次能够使用新的url访问</p>
<h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><p>基本功能和302一致。但是明确向用户表示需要用GET方法获得资源</p>
<blockquote>
<p>当301,302,303系列状态码发回时，几乎所有的浏览器都会把post改成GET，并且删除报文内的主体，之后请求会自动再次发送。当然这么做是有违标准的，但大家都会这么做</p>
</blockquote>
<h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><p>表示客户端发送了附带条件的请求，服务器端找到了资源但是并未符合相应的条件</p>
<h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h3><p>临时重定向，与302功能相似</p>
<h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h2><p>该系列错误表示客户端是错误发生所在</p>
<h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>表示请求报文中存在语法错误。当错误发生时，需要修改内容并再次发送请求。</p>
<h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><p>表示需要经过验证，若之前已经验证过了，则表示验证失败</p>
<h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p>表示请求资源的访问被拒接了，服务器可以不给出理由，如果有理由，则可以在实体的主体部分中看到</p>
<h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>服务器上没有请求的资源</p>
<h2 id="5xx服务器错误"><a href="#5xx服务器错误" class="headerlink" title="5xx服务器错误"></a>5xx服务器错误</h2><p>表示错误出在服务器上</p>
<h3 id="500-Internet-Server-Error"><a href="#500-Internet-Server-Error" class="headerlink" title="500 Internet Server Error"></a>500 Internet Server Error</h3><p>表示服务器在执行请求时发生了错误，也有可能时bug或者临时的故障</p>
<h3 id="503-Service-Unavilable"><a href="#503-Service-Unavilable" class="headerlink" title="503 Service Unavilable"></a>503 Service Unavilable</h3><p>表示服务器暂时超负载或者停机维护，无法处理请求</p>
<h1 id="5-与HTTP协作的Web服务器"><a href="#5-与HTTP协作的Web服务器" class="headerlink" title="5.与HTTP协作的Web服务器"></a>5.与HTTP协作的Web服务器</h1><h2 id="5-1-用单台虚拟主机实现多个域名"><a href="#5-1-用单台虚拟主机实现多个域名" class="headerlink" title="5.1 用单台虚拟主机实现多个域名"></a>5.1 用单台虚拟主机实现多个域名</h2><p>HTPP/1.1允许一台HTTP服务器搭建多个Web站点。比如提供Web托管服务的供应商，可以用一台服务器为多位用户服务</p>
<p>由于DNS的设置，当浏览器中输入不同于域名的时候，最终访问到服务器的可以是相同的ip</p>
<h2 id="5-2-通信数据转发程序：代理，网关，隧道"><a href="#5-2-通信数据转发程序：代理，网关，隧道" class="headerlink" title="5.2 通信数据转发程序：代理，网关，隧道"></a>5.2 通信数据转发程序：代理，网关，隧道</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>本质上是一种类似于中转站的方式，接受有客户端发送的请求并转发给服务器端，反之亦然。同时，每次经过一级代理的时候，就会追加Via首部</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526278757111.png" alt></p>
<blockquote>
<p>使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的</p>
</blockquote>
<h4 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h4><p>代理转发响应时，缓存代理会预先将资源的副本缓存保存在代理服务器上。当代理再次接收到相对资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回</p>
<h4 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h4><p>看代理服务器在转发请求或者响应时会不会对报文做加工，如果没有加工则是透明代理，反之为非透明代理</p>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526279046268.png" alt></p>
<p>网关的作用机制和代理相似，但是目的不一样</p>
<blockquote>
<p>网关的功能是使通信线路上的服务提供非HTTP协议服务。利用网关能提高通信的安全性，因为可以在客户端与网关之间的线路上加密以确保连接的安全。比如网关可以连接数据库等</p>
</blockquote>
<h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道不会解析HTTP请求，客户端可以不用在意它的存在，其作用是建立起一条安全的通信线路<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526279260810.png" alt></p>
<h2 id="5-3-保存资源的缓存"><a href="#5-3-保存资源的缓存" class="headerlink" title="5.3 保存资源的缓存"></a>5.3 保存资源的缓存</h2><blockquote>
<p>缓存是指代理服务器或者客户端本地磁盘内保存的资源副本。利用缓存能够减少对源服务器的访问，因此就节省了通信流量和通信时间。</p>
</blockquote>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526280001491.png" alt></p>
<h1 id="6-HTTP首部"><a href="#6-HTTP首部" class="headerlink" title="6 HTTP首部"></a>6 HTTP首部</h1><blockquote>
<p>HTTP首部字段传递重要信息</p>
</blockquote>
<h2 id="6-1-通用首部字段"><a href="#6-1-通用首部字段" class="headerlink" title="6.1 通用首部字段"></a>6.1 通用首部字段</h2><blockquote>
<p>通用首部字段是指请求报文和响应报文都会采用的首部</p>
</blockquote>
<h3 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h3><blockquote>
<p>控制缓存的工作机理，比如是否采用缓存，是否只针对特定用户才使用缓存等，缓存期限等</p>
</blockquote>
<h3 id="connection"><a href="#connection" class="headerlink" title="connection"></a>connection</h3><blockquote>
<p>作用1：控制不再转发给代理的首部字段（即里面是不再转发的首部字段名）</p>
<p>作用2：管理持久连接（指定connection为close，则断开持久连接）</p>
</blockquote>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><blockquote>
<p>表明HTTP报文创建的日期和时间</p>
</blockquote>
<h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><blockquote>
<p>作用是告知报文主体记录了哪些字段</p>
</blockquote>
<h3 id="via"><a href="#via" class="headerlink" title="via"></a>via</h3><blockquote>
<p>追踪客户端和服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会现在首部字段via中附加该服务器的信息，然后再进行转发</p>
</blockquote>
<h2 id="6-2-请求首部字段"><a href="#6-2-请求首部字段" class="headerlink" title="6.2 请求首部字段"></a>6.2 请求首部字段</h2><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><blockquote>
<p>告知服务器，用户代理能够处理的媒体类型以及媒体类型的相对优先级</p>
</blockquote>
<h3 id="accept-charset"><a href="#accept-charset" class="headerlink" title="accept-charset"></a>accept-charset</h3><h3 id="accept-encoding"><a href="#accept-encoding" class="headerlink" title="accept-encoding"></a>accept-encoding</h3><h3 id="accept-language"><a href="#accept-language" class="headerlink" title="accept-language"></a>accept-language</h3><h3 id="authorization"><a href="#authorization" class="headerlink" title="authorization"></a>authorization</h3><blockquote>
<p>告知服务器，用户代理的证书（认证信息）</p>
</blockquote>
<h3 id="except"><a href="#except" class="headerlink" title="except"></a>except</h3><blockquote>
<p>告诉服务器，期待出现的某种特定行为（状态码）</p>
</blockquote>
<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><blockquote>
<p>因为虚拟主机运行在同一个IP上，因此使用host来区分</p>
</blockquote>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526349521925.png" alt></p>
<h3 id="if-match"><a href="#if-match" class="headerlink" title="if-match"></a>if-match</h3><blockquote>
<p>称之为条件请求，它会告知服务器匹配资源所用的实体标记（ETag）</p>
</blockquote>
<h3 id="if-modified-since"><a href="#if-modified-since" class="headerlink" title="if-modified-since"></a>if-modified-since</h3><blockquote>
<p>条件请求，它希望从服务器那里获取指定日期之后更新的文件</p>
</blockquote>
<h3 id="if-none-match"><a href="#if-none-match" class="headerlink" title="if-none-match"></a>if-none-match</h3><blockquote>
<p>与if-match正好相反</p>
</blockquote>
<h3 id="if-range"><a href="#if-range" class="headerlink" title="if-range"></a>if-range</h3><h3 id="if-unmodified-since"><a href="#if-unmodified-since" class="headerlink" title="if-unmodified-since"></a>if-unmodified-since</h3><h3 id="max-forwards"><a href="#max-forwards" class="headerlink" title="max-forwards"></a>max-forwards</h3><blockquote>
<p>指定最多再妆发多少次，当次数为0，则不再转发而是直接给出响应</p>
</blockquote>
<h3 id="referer"><a href="#referer" class="headerlink" title="referer"></a>referer</h3><blockquote>
<p>告知服务器请求的原始资源的url</p>
</blockquote>
<h3 id="user-agent"><a href="#user-agent" class="headerlink" title="user-agent"></a>user-agent</h3><blockquote>
<p>表示浏览器的种类</p>
</blockquote>
<h2 id="6-3-响应首部字段"><a href="#6-3-响应首部字段" class="headerlink" title="6.3 响应首部字段"></a>6.3 响应首部字段</h2><h3 id="accept-ranges"><a href="#accept-ranges" class="headerlink" title="accept-ranges"></a>accept-ranges</h3><h3 id="etags"><a href="#etags" class="headerlink" title="etags"></a>etags</h3><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><blockquote>
<p>提供重定向的地址（浏览器一般都会尝试对这个地址的访问）</p>
</blockquote>
<h3 id="retry-after"><a href="#retry-after" class="headerlink" title="retry-after"></a>retry-after</h3><h2 id="6-4-实体首部字段"><a href="#6-4-实体首部字段" class="headerlink" title="6.4 实体首部字段"></a>6.4 实体首部字段</h2><h3 id="allow"><a href="#allow" class="headerlink" title="allow"></a>allow</h3><blockquote>
<p>即允许使用的http方法</p>
</blockquote>
<h3 id="content-encoding"><a href="#content-encoding" class="headerlink" title="content-encoding"></a>content-encoding</h3><h3 id="conten-type"><a href="#conten-type" class="headerlink" title="conten-type"></a>conten-type</h3><h1 id="7-确保web安全的HTTPS"><a href="#7-确保web安全的HTTPS" class="headerlink" title="7. 确保web安全的HTTPS"></a>7. 确保web安全的HTTPS</h1><h2 id="7-1-http的缺点"><a href="#7-1-http的缺点" class="headerlink" title="7.1 http的缺点"></a>7.1 http的缺点</h2><h3 id="7-1-1主要缺点"><a href="#7-1-1主要缺点" class="headerlink" title="7.1.1主要缺点"></a>7.1.1主要缺点</h3><ul>
<li>通信使用明文，内容可能被窃听</li>
<li>不验证通信双方的身份，因此有可能遭遇伪装</li>
<li>无法验证明文的完整性，所以有可能已遭篡改</li>
</ul>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526354175531.png" alt></p>
<h3 id="7-1-2-加密手段"><a href="#7-1-2-加密手段" class="headerlink" title="7.1.2 加密手段"></a>7.1.2 加密手段</h3><h4 id="通信的加密"><a href="#通信的加密" class="headerlink" title="通信的加密"></a>通信的加密</h4><p>http中没有对通信进行加密的机制，但是我们可以通过和SSL（安全套接层）组合使用，加密http的通信内容</p>
<p>与ssl组合的http称为<strong>https</strong></p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526354188927.png" alt></p>
<h4 id="内容的加密"><a href="#内容的加密" class="headerlink" title="内容的加密"></a>内容的加密</h4><p>即客户端对http报文进行加密处理再发送请求，但是这样保密性不如前者，仍然有泄密的风险</p>
<h3 id="7-1-3-不验证通信方的身份就可能遭遇伪装"><a href="#7-1-3-不验证通信方的身份就可能遭遇伪装" class="headerlink" title="7.1.3 不验证通信方的身份就可能遭遇伪装"></a>7.1.3 不验证通信方的身份就可能遭遇伪装</h3><ul>
<li>无法验证服务器的真伪</li>
<li>无法验证客户端的真伪</li>
<li>无法确定对方是否具有访问权限</li>
<li>无法判定请求来自何方</li>
<li>即使无意义的请求也会赵丹泉水，无法阻止海量请求下的Dos（拒绝服务攻击）</li>
</ul>
<h4 id="验证对手的证书"><a href="#验证对手的证书" class="headerlink" title="验证对手的证书"></a>验证对手的证书</h4><blockquote>
<p>ssl不仅提供加密处理，而且还提供了一种被称为证书的手段，可用于确定通信方。<br><strong>证书</strong>由值得信任的第三方机构颁发，用于证明服务器和客户端是实际存在的，另外伪造证书的技术难度是很大的</p>
</blockquote>
<h3 id="7-1-4-无法证明报文完整性，可能已遭篡改"><a href="#7-1-4-无法证明报文完整性，可能已遭篡改" class="headerlink" title="7.1.4 无法证明报文完整性，可能已遭篡改"></a>7.1.4 无法证明报文完整性，可能已遭篡改</h3><h4 id="接收到的内容可能有误"><a href="#接收到的内容可能有误" class="headerlink" title="接收到的内容可能有误"></a>接收到的内容可能有误</h4><p>由于http协议无法验证报文的完整性，因此没法确认内容有误或者遭篡改（比如MITM中间人攻击）</p>
<h4 id="如何防止篡改"><a href="#如何防止篡改" class="headerlink" title="如何防止篡改"></a>如何防止篡改</h4><blockquote>
<p>最常用的方法是MD5和SHA-1等散列值校验的方法，以及用数字签名</p>
</blockquote>
<p>可惜的是，用这些方法也依然无法保证安全性，因为其本身遭篡改的话，用户还是没法查觉，我们还是必须要用到https</p>
<h2 id="7-2-http-加密-认证-完整性保护-https"><a href="#7-2-http-加密-认证-完整性保护-https" class="headerlink" title="7.2 http+加密+认证+完整性保护 = https"></a>7.2 http+加密+认证+完整性保护 = https</h2><blockquote>
<p>https并非是应用层的一种新协议，只是http通信接口部分用ssl和tls协议代替。通常情况下，http直接与tcp通信，当使用ssl时，则变成先和ssl通信，再有ssl和tcp通信</p>
</blockquote>
<h2 id="7-3-https的一些弊病"><a href="#7-3-https的一些弊病" class="headerlink" title="7.3 https的一些弊病"></a>7.3 https的一些弊病</h2><p>https也存在一些问题，也就是它的处理速度会变慢。</p>
<p>慢分为两个层面，一个是通信慢，另一种是占用cpu，导致处理速度慢</p>
<p>和使用http相比，网络负载可能会变慢<strong>2到100倍</strong>。</p>
<p>针对速度变慢这个特点，并没有根本性的解决方法，我们会采用ssl加速器（专门针对服务器）这种硬件来改善</p>
<p>所以一般来说，网站里只需要对包含个人信息等敏感数据时采用https加密通信</p>
<p>特别是那些访问量较多的web网站在进行加密处理时，它们所承担的负载不容小觑，并非所有的内容都加密，仅在需要隐藏信息的内容时才进行加密，以节约资源</p>
<p>除此之外，想要节约购买证书的开销也是原因之一</p>
<h1 id="8-确认访问用户身份的验证"><a href="#8-确认访问用户身份的验证" class="headerlink" title="8.确认访问用户身份的验证"></a>8.确认访问用户身份的验证</h1><h2 id="8-1-BASIC认证"><a href="#8-1-BASIC认证" class="headerlink" title="8.1 BASIC认证"></a>8.1 BASIC认证</h2><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526608271186.png" alt></p>
<blockquote>
<p>BASIC认证虽然是采用了Base64编码方式，但这不是加密处理，<strong>不需要任何附加信息就可以解码，换而言之，就等于是明文发送密码和账户</strong>，如果被人窃听，被盗的几率很高</p>
</blockquote>
<h2 id="8-2-DIGEST认证"><a href="#8-2-DIGEST认证" class="headerlink" title="8.2 DIGEST认证"></a>8.2 DIGEST认证</h2><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526608448753.png" alt></p>
<blockquote>
<p>由于发送给对方的只是由质询码产生的计算结果，所以比起BASIC，其泄露的可能性降低了很多</p>
</blockquote>
<h2 id="8-3-SSL客户端认证"><a href="#8-3-SSL客户端认证" class="headerlink" title="8.3 SSL客户端认证"></a>8.3 SSL客户端认证</h2><p>一般的机制下，只要账户和密码正确，就可以认证是本人的行为，但如果用户的ID和密码被盗，就有很大的可能被冒充，利用ssl客户端则可以避免该情况的发生</p>
<p>一般来说，ssl客户端认证是<strong>证书+密码</strong>双重机制来保证安全</p>
<h2 id="8-4-基于表单的认证"><a href="#8-4-基于表单的认证" class="headerlink" title="8.4 基于表单的认证"></a>8.4 基于表单的认证</h2><blockquote>
<p>由于使用上的便利性以及安全性问题，BASIC和DIGEST认证几乎不怎么使用。另外SSL客户端认证虽然有较高的安全等级，但因为维持费用的问题，还尚未普及。目前web尚多半为各自实现的基于表单的认证方式</p>
</blockquote>
<h1 id="9-基于HTTP的功能追加协议"><a href="#9-基于HTTP的功能追加协议" class="headerlink" title="9. 基于HTTP的功能追加协议"></a>9. 基于HTTP的功能追加协议</h1><h2 id="9-1-消除HTTP瓶颈的SPDY"><a href="#9-1-消除HTTP瓶颈的SPDY" class="headerlink" title="9.1 消除HTTP瓶颈的SPDY"></a>9.1 消除HTTP瓶颈的SPDY</h2><h3 id="9-1-1-HTTP的瓶颈"><a href="#9-1-1-HTTP的瓶颈" class="headerlink" title="9.1.1 HTTP的瓶颈"></a>9.1.1 HTTP的瓶颈</h3><ul>
<li>一条连接上只可发送一个请求</li>
<li>请求只能从客户端开始，客户端不可以接受除响应之外的指令</li>
<li>请求/响应首部未经过压缩就发送，首部信息越多延迟越大</li>
<li>发送冗长的首部，每次互相发送相同的首部造成的浪费越大</li>
<li>可任意选择数据压缩格式，非强制压缩放送</li>
</ul>
<h3 id="9-1-2-SPDY的设计与功能"><a href="#9-1-2-SPDY的设计与功能" class="headerlink" title="9.1.2 SPDY的设计与功能"></a>9.1.2 SPDY的设计与功能</h3><p>它并没有完全改写HTTP协议，只是通过新加会话层的形式运作<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1526610952788.png" alt></p>
<ul>
<li>多路复用流。通过单一的tcp连接，可以无限制地处理多个HTTP请求</li>
<li>赋予请求优先级</li>
<li>压缩http首部</li>
<li>推送功能。支持服务器主动向客户端推送数据的功能</li>
<li>服务器提示功能</li>
</ul>
<h2 id="9-2-使用浏览器进行全双工通信的WebSocket"><a href="#9-2-使用浏览器进行全双工通信的WebSocket" class="headerlink" title="9.2 使用浏览器进行全双工通信的WebSocket"></a>9.2 使用浏览器进行全双工通信的WebSocket</h2><h3 id="9-2-1-功能"><a href="#9-2-1-功能" class="headerlink" title="9.2.1 功能"></a>9.2.1 功能</h3><ul>
<li>推送功能</li>
<li>减少通信量</li>
<li>由于是建立在http基础上的协议，因此连接的发起方仍然是客户端，而一旦建立起WebSocket通信连接，双方都可以直接向对方发送报文</li>
</ul>
<h1 id="10-Web的攻击技术"><a href="#10-Web的攻击技术" class="headerlink" title="10. Web的攻击技术"></a>10. Web的攻击技术</h1>]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6和ES7全面入门</title>
    <url>/2018/09/26/ES5%E5%92%8CES6%E5%85%A8%E9%9D%A2%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>ES2015（ES6）和ES2016(ES7)的知识总结<br><a id="more"></a></p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><p>本篇博客的大部分内容和案例均来源于互联网，因为自己也算不上权威就暂时没有这个必要</p>
<h2 id="1-2-参考资料"><a href="#1-2-参考资料" class="headerlink" title="1.2 参考资料"></a>1.2 参考资料</h2><ul>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰的es6入门</a></li>
<li><a href="https://www.jianshu.com/p/76dbe1cd5732" target="_blank" rel="noopener">一篇简书教程</a></li>
<li><a href="https://babeljs.io/docs/en/learn" target="_blank" rel="noopener">babel的教程</a></li>
<li><a href="https://gank.io/post/564151c1f1df1210001c9161" target="_blank" rel="noopener">一篇特别良心的es6入门到实战的教程</a></li>
</ul>
<h1 id="2-ES6"><a href="#2-ES6" class="headerlink" title="2.ES6"></a>2.ES6</h1><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<h2 id="ECMAScript-和-JavaScript-的关系"><a href="#ECMAScript-和-JavaScript-的关系" class="headerlink" title="ECMAScript 和 JavaScript 的关系"></a>ECMAScript 和 JavaScript 的关系</h2><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p>
<p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p>
<p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p>
<h2 id="let、const"><a href="#let、const" class="headerlink" title="let、const"></a>let、const</h2><p>在 ES2015 的新语法中，影响速度最为直接，范围最大的，恐怕得数 let 和 const 了，它们是继 var 之后，新的变量定义方法。与 let 相比，const 更容易被理解：const 也就是 constant 的缩写，跟 C/C++ 等经典语言一样，用于定义常量，即不可变量。</p>
<p>但由于在 ES6 之前的 ECMAScript 标准中，并没有原生的实现，所以在降级编译中，会马上进行引用检查，然后使用 var 代替。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">foo = <span class="string">'newvalue'</span></span><br></pre></td></tr></table></figure>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>在 ES6 诞生之前，我们在给 JavaScript 新手解答困惑时，经常会提到一个观点：</p>
<blockquote>
<p>JavaScript 没有块级作用域</p>
</blockquote>
<p>在 ES6 诞生之前的时代中，JavaScript 确实是没有块级作用域的。这个问题之所以为人所熟知，是因为它引发了诸如历遍监听事件需要使用闭包解决等问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;一&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button&gt;二&lt;/</span>button&gt;</span><br><span class="line">&lt;button&gt;三&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button&gt;四&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"output"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  var buttons = document.querySelectorAll('button')</span></span><br><span class="line"><span class="regexp">  var output = document.querySelector('#output')</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  for (var i = 0; i &lt; buttons.length; i++) &#123;</span></span><br><span class="line"><span class="regexp">    buttons[i].addEventListener('click', function() &#123;</span></span><br><span class="line"><span class="regexp">      output.innerText = buttons[i].innerText</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p>前端新手非常容易写出类似的代码，因为从直观的角度看这段代码并没有语义上的错误，但是当我们点击任意一个按钮时，就会报出这样的错误信息：</p>
<p><code>Uncaught TypeError: Cannot read property &#39;innerText&#39; of undefined</code></p>
<p>出现这个错误的原因是因为 buttons[i] 不存在，即为 undefined。</p>
<p>为什么会出现按钮不存在结果呢？通过排查，我们可以发现，每次我们点击按钮时，事件监听回调函数中得到的变量 i 都会等于 buttons.length，也就是这里的 4。而 buttons[4] 恰恰不存在，所以导致了错误的发生。</p>
<p>再而导致 i 得到的值都是 buttons.length 的原因就是因为 JavaScript 中没有块级作用域，而使对 i 的变量引用(Reference)一直保持在上一层作用域（循环语句所在层）上，而当循环结束时 i 则正好是 buttons.length。</p>
<p>而在 ES6 中，<strong>我们只需做出一个小小的改动</strong>，便可以解决该问题（假设所使用的浏览器已经支持所需要的特性）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="comment">/* var */</span> <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>通过把 for 语句中对计数器 i 的定义语句从 var 换成 let，即可。因为 let 语句会使该变量处于一个块级作用域中，从而让事件监听回调函数中的变量引用得到保持。我们不妨看看改进后的代码经过 babel 的编译会变成什么样子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> _loop = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  buttons[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    output.innerText = buttons[i].innerText</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</span><br><span class="line">  _loop(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>实现方法一目了然，通过传值的方法防止了 i 的值错误。</p>
<h2 id="箭头函数-Arrow-Function"><a href="#箭头函数-Arrow-Function" class="headerlink" title="箭头函数(Arrow Function)"></a>箭头函数(Arrow Function)</h2><p>继 let 和 const 之后，箭头函数就是使用率最高的新特性了。当然了，如果你了解过 Scala 或者曾经如日中天的 JavaScript 衍生语言 CoffeeScript，就会知道箭头函数并非 ES6 独创。</p>
<p>箭头函数，顾名思义便是使用箭头(=&gt;)进行定义的函数，属于匿名函数（Lambda）一类。当然了，也可以作为定义式函数使用，但我们并不推荐这样做，随后会详细解释。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>箭头函数有好几种使用语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo =&gt; foo + <span class="string">' world'</span> <span class="comment">// means return `foo + ' world'`</span></span><br><span class="line"></span><br><span class="line">(foo, bar) =&gt; foo + bar</span><br><span class="line"></span><br><span class="line">foo =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> foo + <span class="string">' world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(foo, bar) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> foo + bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上都是被支持的箭头函数表达方式，其最大的好处便是简洁明了，省略了 function 关键字，而使用 =&gt; 代替。</p>
<p>箭头函数语言简洁的特点使其特别适合用於单行回调函数的定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [ <span class="string">'Will'</span>, <span class="string">'Jack'</span>, <span class="string">'Peter'</span>, <span class="string">'Steve'</span>, <span class="string">'John'</span>, <span class="string">'Hugo'</span>, <span class="string">'Mike'</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newSet = names</span><br><span class="line">  .map(<span class="function">(<span class="params">name, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      id: index,</span><br><span class="line">      name: name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .filter(<span class="function"><span class="params">man</span> =&gt;</span> man.id % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">man</span> =&gt;</span> [man.name])</span><br><span class="line">  .reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.concat(b))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newSet) <span class="comment">//=&gt; [ 'Will', 'Peter', 'John', 'Mike' ]</span></span><br></pre></td></tr></table></figure>
<h3 id="箭头函数与上下文绑定"><a href="#箭头函数与上下文绑定" class="headerlink" title="箭头函数与上下文绑定"></a>箭头函数与上下文绑定</h3><p>事实上，箭头函数在 ES2015 标准中，并不只是作为一种新的语法出现。就如同它在 CoffeeScript 中的定义一般，是用于对函数内部的上下文 （this）绑定为定义函数所在的作用域的上下文。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  hello: <span class="string">'world'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">let</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.hello</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.hello = <span class="string">'ES6'</span></span><br><span class="line"><span class="built_in">window</span>.bar = obj.foo()</span><br><span class="line"><span class="built_in">window</span>.bar() <span class="comment">//=&gt; 'world'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的 obj.foo 等价于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">foo() &#123;</span><br><span class="line">  <span class="keyword">let</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hello</span><br><span class="line">  &#125;).bind(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>另外，要注意的是，箭头函数对上下文的绑定是强制性的，无法通过 apply 或 call 方法改变其上下文。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.dam</span><br><span class="line">  &#125;,</span><br><span class="line">  dam: <span class="string">'hei'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dam</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">  dam: <span class="string">'ha'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.init()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.foo()) <span class="comment">//=&gt; hei</span></span><br><span class="line"><span class="built_in">console</span>.log(a.foo.bind(b).call(a)) <span class="comment">//=&gt; ha</span></span><br><span class="line"><span class="built_in">console</span>.log(a.bar.call(b)) <span class="comment">//=&gt; hei</span></span><br></pre></td></tr></table></figure>
<p>另外，因为箭头函数会绑定上下文的特性，故不能随意在顶层作用域使用箭头函数，以防出错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设当前运行环境为浏览器，故顶层作上下文为 `window`</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  msg: <span class="string">'pong'</span>,</span><br><span class="line"></span><br><span class="line">  ping: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.msg <span class="comment">// Warning!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.ping() <span class="comment">//=&gt; undefined</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">'bang!'</span></span><br><span class="line">obj.ping() <span class="comment">//=&gt; bang!</span></span><br></pre></td></tr></table></figure>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串模板出现简直对 Node.js 应用的开发和 Node.js 自身的发展起到了相当大的推动作用！我的意思并不是说这个原生的模板字符串能代替现有的模板引擎，而是说它的出现可以让非常多的字符串使用变得尤为轻松。</p>
<p>模板字符串要求使用 ` 代替原本的单/双引号来包裹字符串内容。它有两大特点：</p>
<ol>
<li>支持变量注入</li>
<li>支持换行</li>
</ol>
<h3 id="支持变量注入-useful"><a href="#支持变量注入-useful" class="headerlink" title="支持变量注入(useful)"></a>支持变量注入(useful)</h3><p>模板字符串之所以称之为“模板”，就是因为它允许我们在字符串中引用外部变量，而不需要像以往需要不断地相加、相加、相加……</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Will Wen Gunn'</span></span><br><span class="line"><span class="keyword">let</span> title = <span class="string">'Founder'</span></span><br><span class="line"><span class="keyword">let</span> company = <span class="string">'LikMoon Creation'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greet = <span class="string">`Hi, I'm <span class="subst">$&#123;name&#125;</span>, I am the <span class="subst">$&#123;title&#125;</span> at <span class="subst">$&#123;company&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(greet) <span class="comment">//=&gt; Hi, I'm Will Wen Gunn, I am the Founder at LikMoon Creation</span></span><br></pre></td></tr></table></figure>
<h3 id="支持换行"><a href="#支持换行" class="headerlink" title="支持换行"></a>支持换行</h3><p>无论是上面的哪一种，都会让我们感到很不爽。但若使用模板字符串，仿佛打开了新世界的大门~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sql = <span class="string">`</span></span><br><span class="line"><span class="string">SELECT * FROM Users</span></span><br><span class="line"><span class="string">WHERE FirstName='Mike'</span></span><br><span class="line"><span class="string">LIMIT 5;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<h2 id="对象字面量扩展语法"><a href="#对象字面量扩展语法" class="headerlink" title="对象字面量扩展语法"></a>对象字面量扩展语法</h2><p>(本质上还是语法糖，但是挺爽的)</p>
<h3 id="方法属性省略-function-useful"><a href="#方法属性省略-function-useful" class="headerlink" title="方法属性省略 function (useful)"></a>方法属性省略 function (useful)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">// before</span></span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// after</span></span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'bar'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同名方法属性省略语法"><a href="#同名方法属性省略语法" class="headerlink" title="同名方法属性省略语法"></a>同名方法属性省略语法</h3><p>也是看上去有点鸡肋的新特性，不过在做 JavaScript 模块化工程的时候则有了用武之地。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  someMethod</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> Module <span class="keyword">from</span> <span class="string">'./module'</span></span><br><span class="line"></span><br><span class="line">Module.someMethod()</span><br></pre></td></tr></table></figure>
<h3 id="可以动态计算的属性名称"><a href="#可以动态计算的属性名称" class="headerlink" title="可以动态计算的属性名称"></a>可以动态计算的属性名称</h3><p>这个特性相当有意思，也是可以用在一些特殊的场景中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> outArr = arr.map(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [ n ]: n,</span><br><span class="line">    [ <span class="string">`<span class="subst">$&#123;n&#125;</span>^2`</span> ]: <span class="built_in">Math</span>.pow(n, <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.dir(outArr) <span class="comment">//=&gt;</span></span><br><span class="line">  [</span><br><span class="line">    &#123; <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'1^2'</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'2^2'</span>: <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'3^2'</span>: <span class="number">9</span> &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<h3 id="表达式解构-useful"><a href="#表达式解构-useful" class="headerlink" title="表达式解构(useful)"></a>表达式解构(useful)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Matching with object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">query</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 交换变量 */</span></span><br><span class="line">  [x, y] = [y, x];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从函数返回多个值 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 函数参数的定义 */</span></span><br><span class="line">  <span class="comment">// 参数是一组有次序的值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">  f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数是一组无次序的值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">  f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 提取json数据 */</span></span><br><span class="line">  <span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">    id: <span class="number">42</span>,</span><br><span class="line">    status: <span class="string">"OK"</span>,</span><br><span class="line">    data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 函数参数的默认 */</span></span><br><span class="line">  jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">    beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">    cache = <span class="literal">true</span>,</span><br><span class="line">    complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    crossDomain = <span class="literal">false</span>,</span><br><span class="line">    global = <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ... more config</span></span><br><span class="line">  &#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// ... do stuff</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 导入模块 */</span></span><br><span class="line">  <span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="函数参数表达、传参"><a href="#函数参数表达、传参" class="headerlink" title="函数参数表达、传参"></a>函数参数表达、传参</h2><p>这个特性有非常高的使用频率，一个简单的语法糖解决了从前需要一两行代码才能实现的功能。</p>
<h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>这个特性在类库开发中相当有用，比如实现一些可选参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> readline <span class="keyword">from</span> <span class="string">'readline'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLineInFile</span>(<span class="params">filename, callback = noop, complete = noop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rl = readline.createInterface(&#123;</span><br><span class="line">    input: fs.createReadStream(path.resolve(__dirname, filename))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  rl.on(<span class="string">'line'</span>, line =&gt; &#123;</span><br><span class="line">    <span class="comment">//... do something with the current line</span></span><br><span class="line">    callback(line)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  rl.on(<span class="string">'close'</span>, complete)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">readLineInFile(<span class="string">'big_file.txt'</span>, line =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="后续参数"><a href="#后续参数" class="headerlink" title="后续参数"></a>后续参数</h3><p>我们知道，函数的 call 和 apply 在使用上的最大差异便是一个在首参数后传入各个参数，一个是在首参数后传入一个包含所有参数的数组。如果我们在实现某些函数或方法时，也希望实现像 call 一样的使用方法，在 ES2015 之前，我们可能需要这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchSomethings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.apply(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeOthers</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.apply(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 ES2015 中，我们可以很简单的使用 … 语法糖来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchSomethings</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeOthers</span>(<span class="params">name, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是，…args 后不可再添加</p>
<p>虽然从语言角度看，arguments 和 …args 是可以同时使用 ，但有一个特殊情况则不可：arguments 在箭头函数中，会跟随上下文绑定到上层，所以在不确定上下文绑定结果的情况下，尽可能不要再箭头函数中再使用 arguments，而使用 …args。</p>
<p>虽然 ECMA 委员会和各类编译器都无强制性要求用 …args 代替 arguments，但从实践经验看来，…args 确实可以在绝大部份场景下可以代替 arguments 使用，除非你有很特殊的场景需要使用到 arguments.callee 和 arguments.caller。所以我推荐都使用 …args 而非 arguments。</p>
<p>PS：在严格模式（Strict Mode）中，arguments.callee 和 arguments.caller 是被禁止使用的。</p>
<h3 id="解构传参"><a href="#解构传参" class="headerlink" title="解构传参"></a>解构传参</h3><p>在 ES2015 中，… 语法还有另外一个功能：无上下文绑定的 apply。什么意思？看看代码你就知道了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.map(<span class="built_in">Number</span>)</span><br><span class="line">    .reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">//=&gt; 6</span></span><br></pre></td></tr></table></figure>
<p>有什么卵用？我也不知道(⊙o⊙)… Sorry…</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>默认参数值</code>和<code>后续参数</code>需要遵循顺序原则，否则会出错。<br><code>function(...args, last = 1) {
  // This will go wrong
}</code></p>
<h2 id="新的数据结构"><a href="#新的数据结构" class="headerlink" title="新的数据结构"></a>新的数据结构</h2><p>在介绍新的数据结构之前，我们先复习一下在 ES2015 之前，JavaScript 中有哪些基本的数据结构。</p>
<ul>
<li>String 字符串</li>
<li>Number 数字（包含整型和浮点型）</li>
<li>Boolean 布尔值</li>
<li>Object 对象</li>
<li>Array 数组</li>
</ul>
<p>其中又分为<code>值类型</code>和<code>引用类型</code>，Array 其实是 Object 的一种子类。</p>
<h3 id="Set-和-WeakSet"><a href="#Set-和-WeakSet" class="headerlink" title="Set 和 WeakSet"></a>Set 和 WeakSet</h3><p>我们再来复习下高中数学吧，集不能包含相同的元素，我们可以根据元素画出多个集的韦恩图…………</p>
<p>好了跑题了。是的，在 ES2015 中，ECMA 委员会为 ECMAScript 增添了集(Set)和“弱”集(WeakSet)。它们都具有元素唯一性，若添加了已存在的元素，会被自动忽略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">s.add(<span class="string">'hello'</span>).add(<span class="string">'world'</span>).add(<span class="string">'hello'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s.size) <span class="comment">//=&gt; 2</span></span><br><span class="line"><span class="built_in">console</span>.log(s.has(<span class="string">'hello'</span>)) <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure>
<p>在实际开发中，我们有很多需要用到集的场景，如搜索、索引建立等。</p>
<p>WeakSet 在 JavaScript 底层作出调整（在非降级兼容的情况下），检查元素的变量引用情况。如果元素的引用已被全部解除，则该元素就会被删除，以节省内存空间。这意味著无法直接加入数字或者字符串。另外 WeakSet 对元素有严格要求，必须是 Object，当然了，你也可以用 new String(‘…’) 等形式处理元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weaks = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line">weaks.add(<span class="string">"hello"</span>) <span class="comment">//=&gt; Error</span></span><br><span class="line">weaks.add(<span class="number">3.1415</span>) <span class="comment">//=&gt; Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="keyword">let</span> pi = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3.1415</span>)</span><br><span class="line">weaks.add(foo)</span><br><span class="line">weaks.add(pi)</span><br><span class="line">weaks.has(foo) <span class="comment">//=&gt; true</span></span><br><span class="line">foo = <span class="literal">null</span></span><br><span class="line">weaks.has(foo) <span class="comment">//=&gt; false</span></span><br></pre></td></tr></table></figure>
<h3 id="Map-和-WeakMap"><a href="#Map-和-WeakMap" class="headerlink" title="Map 和 WeakMap"></a>Map 和 WeakMap</h3><p>从数据结构的角度来说，映射（Map）跟原本的 Object 非常相似，都是 Key/Value 的键值对结构。但是 Object 有一个让人非常不爽的限制：key 必须是字符串或数字。在一般情况下，我们并不会遇上这一限制，但若我们需要建立一个对象映射表时，这一限制显得尤为棘手。</p>
<p>而 Map 则解决了这一问题，可以使用任何对象作为其 key，这可以实现从前不能实现或难以实现的功能，如在项目逻辑层实现数据索引等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> object = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">map.set(object, <span class="string">'hello'</span>)</span><br><span class="line">map.set(<span class="string">'hello'</span>, <span class="string">'world'</span>)</span><br><span class="line">map.has(object) <span class="comment">//=&gt; true</span></span><br><span class="line">map.get(object) <span class="comment">//=&gt; hello</span></span><br></pre></td></tr></table></figure>
<p>而 WeakMap 和 WeakSet 很类似，只不过 WeakMap 的键和值都会检查变量引用，只要其一的引用全被解除，该键值对就会被删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weakm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">let</span> keyObject = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> valObject = &#123; <span class="attr">score</span>: <span class="number">100</span> &#125;</span><br><span class="line"></span><br><span class="line">weakm.set(keyObject, valObject)</span><br><span class="line">weakm.get(keyObject) <span class="comment">//=&gt; &#123; score: 100 &#125;</span></span><br><span class="line">keyObject = <span class="literal">null</span></span><br><span class="line">weakm.has(keyObject) <span class="comment">//=&gt; false</span></span><br></pre></td></tr></table></figure>
<h2 id="类-Classes"><a href="#类-Classes" class="headerlink" title="类(Classes)"></a>类(Classes)</h2><p>类，作为自 JavaScript 诞生以来最大的痛点之一，终于在 ES2015 中得到了官方的妥协，“实现”了 ECMAScript 中的标准类机制。为什么是带有双引号的呢？因为我们不难发现这样一个现象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line">[<span class="built_in">Function</span>: Foo]</span><br></pre></td></tr></table></figure>
<p>回想一下在 ES2015 以前的时代中，我们是怎么在 JavaScript 中实现类的？<br><code>function Foo() {}
var foo = new Foo()</code></p>
<p>是的，ES6 中的类只是一种语法糖，用于定义原型(Prototype)的。当然，饿死的厨师三百斤，有总比没有强，我们还是很欣然地接受了这一设定。</p>
<h3 id="遗憾与期望"><a href="#遗憾与期望" class="headerlink" title="遗憾与期望"></a>遗憾与期望</h3><p>就目前来说，ES2015 的类机制依然很鸡肋：</p>
<ol>
<li>不支持私有属性（private）</li>
<li>不支持前置属性定义，但可用 get 语句和 set 语句实现</li>
<li>不支持多重继承</li>
</ol>
<p>没有类似于协议（Protocl）或接口（Interface）等的概念<br>中肯地说，ES2015 的类机制依然有待加强。但总的来说，是值得尝试和讨论的，我们可以像从前一样，不断尝试新的方法，促进 ECMAScript 标准的发展。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise，作为一个老生常谈的话题，早已被聪明的工程师们“玩坏”了。</p>
<p>光是 Promise 自身，目前就有多种标准，而目前最为流行的是 Promises/A+。而 ES2015 中的 Promise 便是基于 Promises/A+ 制定的。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Promise 是一种用于解决回调函数无限嵌套的工具（当然，这只是其中一种），其字面意义为“保证”。它的作用便是“免去”异步操作的回调函数，保证能通过后续监听而得到返回值，或对错误处理。它能使异步操作变得井然有序，也更好控制。我们以在浏览器中访问一个 API，解析返回的 JSON 数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'http://example.com/api/users/top'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    vm.data.topUsers = data</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// Handle the error crash in the chaining processes</span></span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure>
<p>Promise 在设计上具有原子性，即只有两种状态：未开始和结束（无论成功与否都算是结束），这让我们在调用支持 Promise 的异步方法时，逻辑将变得非常简单，这在大规模的软件工程开发中具有良好的健壮性。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="创建-Promise-对象"><a href="#创建-Promise-对象" class="headerlink" title="创建 Promise 对象"></a>创建 Promise 对象</h4><p>要为一个函数赋予 Promise 的能力，先要创建一个 Promise 对象，并将其作为函数值返回。Promise 构造函数要求传入一个函数，并带有 resolve 和 reject 参数。这是两个用于结束 Promise 等待的函数，对应的成功和失败。而我们的逻辑代码就在这个函数中进行。</p>
<p>此处，因为必须要让这个函数包裹逻辑代码，所以如果需要用到 this 时，则需要使用箭头函数或者在前面做一个 this 的别名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="进行异步操作"><a href="#进行异步操作" class="headerlink" title="进行异步操作"></a>进行异步操作</h4><p>事实上，在异步操作内，并不需要对 Promise 对象进行操作（除非有特殊需求）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    api.call(<span class="string">'fetch_data'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err)</span><br><span class="line"></span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在 Promise 定义的过程中，也会出现数层回调嵌套的情况，如果需要使用 this 的话，便显现出了箭头函数的优势了。</p>
<h4 id="使用-Promise"><a href="#使用-Promise" class="headerlink" title="使用 Promise"></a>使用 Promise</h4><p>让异步操作函数支持 Promise 后，我们就可以享受 Promise 带来的优雅和便捷了~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetchData()</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeInFileSystem(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> renderUIAnimated(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure>
<h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>虽说 Promise 确实很优雅，但是这是在所有需要用到的异步方法都支持 Promise 且遵循标准。而且链式 Promise 强制性要求逻辑必须是线性单向的，一旦出现如并行、回溯等情况，Promise 便显得十分累赘。</p>
<p>所以在目前的最佳实践中，Promise 会作为一种接口定义方法，而不是逻辑处理工具。后文将会详细阐述这种最佳实践。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol 是一种很有意思的概念，它跟 Swift 中的 Selector 有点相像，但也更特别。在 JavaScript 中，对象的属性名称可以是字符串或数字。而如今又多了一个 Symbol。那 Symbol 究竟有什么用？</p>
<p>首先，我们要了解的是，Symbol 对象是具有唯一性的，也就是说，每一个 Symbol 对象都是唯一的，即便我们看不到它的区别在哪里。这就意味著，我们可以用它来保证一些数据的安全性。<br><code>console.log(Symbol(&#39;key&#39;) == Symbol(&#39;key&#39;)) //=&gt; false</code></p>
<p>如果将一个 Symbol 隐藏于一个封闭的作用域内，并作为一个对象中某属性的键，则外层作用域中便无法取得该属性的值，有效保障了某些私有库的代码安全性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> privateDataStore = &#123;</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="built_in">Math</span>.random().toString(<span class="number">32</span>).substr(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">this</span>[key] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key = privateDateStore(<span class="string">'hello world'</span>)</span><br><span class="line">privateDataStore[key] <span class="comment">//=&gt; undefined</span></span><br><span class="line">privateDataStore.get(key) <span class="comment">//=&gt; hello world</span></span><br></pre></td></tr></table></figure>
<h2 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy(代理)"></a>Proxy(代理)</h2><p>Proxy 是 ECMAScript 中的一种新概念，它有很多好玩的用途，从基本的作用说就是：Proxy 可以在不入侵目标对象的情况下，对逻辑行为进行拦截和处理。</p>
<p>比如说我想记录下我代码中某些接口的使用情况，以供数据分析所用，但是因为目标代码中是严格控制的，所以不能对其进行修改，而另外写一个对象来对目标对象做代理也很麻烦。那么 Proxy 便可以提供一种比较简单的方法来实现这一需求。</p>
<blockquote>
<p>注意，要使得代理起作用，必须对proxy对象操作而不是原对象</p>
</blockquote>
<p>假设我要对 api 这一对象进行拦截并记录下代码行为，我就可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> apiProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;</span><br><span class="line">  <span class="keyword">get</span>(receiver, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      min.sadd(<span class="string">`log:<span class="subst">$&#123;name&#125;</span>`</span>, args)</span><br><span class="line">      <span class="keyword">return</span> receiver[name].apply(receiver, args)</span><br><span class="line">    &#125;).bind(receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">api.getComments(artical.id)</span><br><span class="line">  .then(<span class="function"><span class="params">comments</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h1 id="3-ES7"><a href="#3-ES7" class="headerlink" title="3.ES7"></a>3.ES7</h1><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>上文中我们提及到 co 是一个利用 Generator 模拟 ES7 中 async/await 特性的工具，那么，这个 async/await 究竟又是什么呢？它跟 co 又有什么区别呢？</p>
<p>我们知道，Generator Function 与普通的 Function 在执行方式上有著本质的区别，在某种意义上是无法共同使用的。但是，对于 ES7 的 Async Function 来说，这一点并不存在！它可以以普通函数的执行方式使用，并且有著 Generator Function 的异步优越性，它甚至可以作为事件响应函数使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(<span class="string">'/api/fetch/data'</span>)</span><br><span class="line">  <span class="keyword">let</span> reply = <span class="keyword">await</span> res.json()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reply = fetchData() <span class="comment">//=&gt; DATA...</span></span><br></pre></td></tr></table></figure>
<h2 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a>Decorators</h2><p>对于 JavaScript 开发者来说，Decorators 又是一种新的概念，不过它在 Python 等语言中早已被玩出各种花式。</p>
<p>Decorator 的定义如下：</p>
<ul>
<li>是一个表达式</li>
<li>Decorator 会调用一个对应的函数</li>
<li>调用的函数中可以包含 target（装饰的目标对象）、name（装饰目标的名称）和 descriptor（描述器）三个参数</li>
<li>调用的函数可以返回一个新的描述器以应用到装饰目标对象上</li>
</ul>
<p>PS：如果你不记得 descriptor 是什么的话，请回顾一下 Object.defineProperty() 方法。</p>
<h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>我们在实现一个类的时候，有的属性并不想被 for..in 或 Object.keys() 等方法检索到，那么在 ES5 时代，我们会用到 Object.defineProperty() 方法来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'bar'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.bar) <span class="comment">//=&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keys = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj)</span><br><span class="line">  keys.push(key)</span><br><span class="line"><span class="built_in">console</span>.log(keys) <span class="comment">//=&gt; [ 'foo' ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)) <span class="comment">//=&gt; [ 'foo' ]</span></span><br></pre></td></tr></table></figure>
<p>那么在 ES7 中，我们可以用 Decorator 来很简单地实现这个需求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @nonenumerable</span><br><span class="line">  <span class="keyword">get</span> bar() &#123; <span class="keyword">return</span> <span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonenumerable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.enumerable = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obj()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.foo) <span class="comment">//=&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.bar) <span class="comment">//=&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)) <span class="comment">//=&gt; [ 'foo' ]</span></span><br></pre></td></tr></table></figure>
<h2 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h2><blockquote>
<p>修饰器是一个对类进行处理的函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line">MyClass.isTestable <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h3><p>正如上面所说，Decorator 在编程中早已不是什么新东西，特别是在 Python 中早已被玩出各种花样。聪明的工程师们看到 ES7 的支持当然不会就此收手，就让我们看看我们还能用 Decorator 做点什么神奇的事情。</p>
<p>假如我们要实现一个类似于 Koa 和 PHP 中的 CI 的框架，且利用 Decorator 特性实现 URL 路由，我们可以这样做。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 框架内部</span></span><br><span class="line"><span class="comment">// 控制器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handlers = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">var</span> urls = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义控制器</span></span><br><span class="line">@route(<span class="string">'/'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.msg = <span class="string">'World'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> GET(ctx) &#123;</span><br><span class="line">    ctx.body = <span class="string">`Hello <span class="subst">$&#123;<span class="keyword">this</span>.msg&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Router Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">    target.url = url</span><br><span class="line">    <span class="keyword">let</span> urlObject = <span class="keyword">new</span> <span class="built_in">String</span>(url)</span><br><span class="line">    urls[url] = urlObject</span><br><span class="line"></span><br><span class="line">    handlers.set(urlObject, target)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由执行部份</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">router</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (urls[url]) &#123;</span><br><span class="line">    <span class="keyword">var</span> handlerClass = handlers.get(urls[url])</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> handlerClass()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handler = router(<span class="string">'/'</span>)</span><br><span class="line"><span class="keyword">if</span> (handler) &#123;</span><br><span class="line">  <span class="keyword">let</span> context = &#123;&#125;</span><br><span class="line">  handler.GET(context)</span><br><span class="line">  <span class="built_in">console</span>.log(context.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的是，同一个修饰对象是可以同时使用多个修饰器的，所以说我们还可以用修饰器实现很多很多有意思的功能。</p>
<h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><h2 id="let取代var"><a href="#let取代var" class="headerlink" title="let取代var"></a>let取代var</h2><blockquote>
<p>let和var作用相似，而且let没有副作用</p>
</blockquote>
<h2 id="全局常量和线程安全"><a href="#全局常量和线程安全" class="headerlink" title="全局常量和线程安全"></a>全局常量和线程安全</h2><blockquote>
<p>在let和const之间，建议优先选择const，尤其是在全局环境，不应该设置变量，只应该设置常量</p>
</blockquote>
<p>const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。</p>
<p>const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。<br>所有的函数都应该设置为常量。</p>
<p>长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>静态字符串一律使用单引号或者反引号，动态字符串使用双引号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">"foobar"</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="string">'foo'</span> + a + <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// acceptable</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="string">`foobar`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'foobar'</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="string">`foo<span class="subst">$&#123;a&#125;</span>bar`</span>;</span><br></pre></td></tr></table></figure>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>使用数组成员对变量赋值时，优先使用解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> second = arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [first, second] = arr;</span><br></pre></td></tr></table></figure>
<p>函数的参数如果是对象的成员，优先使用解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> firstName = user.firstName;</span><br><span class="line">  <span class="keyword">const</span> lastName = user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; firstName, lastName &#125; = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [left, right, top, bottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; left, right, top, bottom &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; left, right &#125; = processInput(input);</span><br></pre></td></tr></table></figure>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2, &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2 &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">a.x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if reshape unavoidable</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(a, &#123; <span class="attr">x</span>: <span class="number">3</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">a.x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ref = <span class="string">'some value'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> atom = &#123;</span><br><span class="line">  ref: ref,</span><br><span class="line"></span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  addValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> atom.value + value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> atom = &#123;</span><br><span class="line">  ref,</span><br><span class="line"></span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  addValue(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> atom.value + value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>使用扩展运算符（…）拷贝数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> len = items.length;</span><br><span class="line"><span class="keyword">const</span> itemsCopy = [];</span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> itemsCopy = [...items];</span><br></pre></td></tr></table></figure>
<p>使用 Array.from 方法，将类似数组的对象转为数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>);</span><br><span class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo);</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>立即执行函数可以写成箭头函数的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet.'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure>
<p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, option = false </span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, &#123; option = false &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用默认值语法设置函数参数的默认值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map结构"><a href="#map结构" class="headerlink" title="map结构"></a>map结构</h2><p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params">contents = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._queue = [...contents];</span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(contents = []) &#123;</span><br><span class="line">    <span class="keyword">this</span>._queue = [...contents];</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> inherits = <span class="built_in">require</span>(<span class="string">'inherits'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PeekableQueue</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">  Queue.apply(<span class="keyword">this</span>, contents);</span><br><span class="line">&#125;</span><br><span class="line">inherits(PeekableQueue, Queue);</span><br><span class="line">PeekableQueue.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekableQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'moduleA'</span>);</span><br><span class="line"><span class="keyword">const</span> func1 = moduleA.func1;</span><br><span class="line"><span class="keyword">const</span> func2 = moduleA.func2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> &#123; func1, func2 &#125; <span class="keyword">from</span> <span class="string">'moduleA'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用</p>
</blockquote>
<p>不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</span><br></pre></td></tr></table></figure>
<p>如果模块默认输出一个函数，函数名的首字母应该小写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeStyleGuide</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> makeStyleGuide;</span><br></pre></td></tr></table></figure>
<p>如果模块默认输出一个对象，对象名的首字母应该大写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> StyleGuide = &#123;</span><br><span class="line">  es6: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> StyleGuide;</span><br></pre></td></tr></table></figure>
<h3 id="ES6的模块和commonJs的不同"><a href="#ES6的模块和commonJs的不同" class="headerlink" title="ES6的模块和commonJs的不同"></a>ES6的模块和commonJs的不同</h3><ul>
<li>commonjs模块输出的是一个值的拷贝，es6输出的是值的引用</li>
<li>commonjs是运行时加载，es6是编译时输出接口</li>
</ul>
<p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">get</span> counter() &#123;</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">  &#125;,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化</p>
<blockquote>
<p>ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块<br>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">123</span>; <span class="comment">// OK</span></span><br><span class="line">obj = &#123;&#125;; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量</p>
</blockquote>
<p>最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sum += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sum);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br></pre></td></tr></table></figure>
<p>上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例</p>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
  </entry>
  <entry>
    <title>《黑客与画家》读书笔记</title>
    <url>/2017/10/29/%E3%80%8A%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>黑客与画家并不单单意味着编程是一门艺术，实际上这本书的作者 Paul Graham 本身也是一个程序员和画家的结合（他原本想成为一名画家，最后迫于生计不得不编程维生）。本书的译者为<a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a>，也是一名非常了不起的牛人。</p>
<p>评分：5分</p>
</blockquote>
<a id="more"></a>
<h1 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h1><h2 id="黑客的六条“伦理”"><a href="#黑客的六条“伦理”" class="headerlink" title="黑客的六条“伦理”"></a>黑客的六条“伦理”</h2><ul>
<li>使用计算机以及所有有助于了解这个世界本质的事物都不应该受到任何限制，任何事情都应该亲手尝试</li>
<li>所有信息都应该是自由的</li>
<li>不信任权威，提倡去中心化</li>
<li>判断一名黑客的水平应该看他的技术能力</li>
<li>你可以使用计算机创造美和艺术</li>
<li>计算机使生活更美好</li>
</ul>
<h2 id="全书大概分为三个部分"><a href="#全书大概分为三个部分" class="headerlink" title="全书大概分为三个部分"></a>全书大概分为三个部分</h2><ul>
<li>1-4章：介绍黑客是如何成长的，以及他们看待世界的一些观点</li>
<li>5-9章：解释了黑客如何做出自己的成果，这些成果如何对全世界产生影响</li>
<li>10-15章：黑客的工具（编程语言）和工作方法，这是黑客文化的基础和核心</li>
</ul>
<h1 id="为什么书呆子不受欢迎"><a href="#为什么书呆子不受欢迎" class="headerlink" title="为什么书呆子不受欢迎"></a>为什么书呆子不受欢迎</h1><p>书呆子不受欢迎的真正原因，是他们脑子里想着别的事情（smarter），他们有其他的兴趣，没有多余的经理来使自己更加受欢迎。同时，其他伙伴们也喜欢欺负书呆子，因为这与“受欢迎”的心理有关（这在美国校园环境中很重要），没有什么比一个共同的敌人更能使得人们团结起来了。而且通常情况下，喜欢捉弄书呆子的人都是“焦虑的中间层”</p>
<h1 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h1><p>优美的软件并不总是论文的合适题材，黑客真正想做的是设计优美的软件，考核这种工作是非常困难的，你本人需要有良好的设计感，才能去考核别人的设计是否良好。但是“你觉得你具有良好的设计感和你实际是否具有，不存在相关联系。</p>
<p>别人无法考核你的工作，甚至误解你的工作，都不是最糟糕的事，更大的危险是你自己也会误解自己的工作。我发现自己以为需要记住各种理论实际上是错误的，何可不需要搞懂太多的概念，黑客新想法的最佳来源是其他创作领域。</p>
<p>黑客如何才能做自己喜欢的事情？找一份养家糊口的“day job”，然后业余时间做自己喜欢的事情</p>
<p><strong>黑客也可以从绘画中学习一些经验</strong></p>
<ul>
<li>画家学习绘画的方法主要是动手去画，黑客学习编程的方法也应该如此（这一点我比较有感触，看书上讲了一堆设计模式，但实际上还是要结合实际才能有更深的体会，但这与那是本好书不矛盾）</li>
<li>我们不应该期待现有一个完美的规格设计，然后再动手编程设计。应该是动态设计的，也就是说一开始搭好框架，然后慢慢修改</li>
<li>优秀的软件应该要要求对美的狂热追求。如果你查看优秀软件的内容时，就会发现那些预料中没有人会看见的部分也是优美的</li>
<li>黑客就像画家，工作起来是有心理周期的，最开始有一个令人兴奋的新周期时，你愿意为之每天工作16个小时，等过完这一阵，你又会觉得无聊。你在工作时，必须把这种因素考虑在内，解决办法是<strong>你可以把解决bug放在最后（因为消灭bug对作者来说很简单）</strong></li>
<li>在多人合作时，最好是分工尽量分板块进行，不要太重合了</li>
<li>设计软件时，尽量人性化设计，为了吸引用户，你必须理解用户需要什么，举例来说，几乎所有伟大的绘画作品都是画人的，因为人类总是对自身感兴趣的</li>
<li>源代码应该能做到自己解释自己，SICP中有一句说道“程序是给人看的，附带能在机器上运行”。一种好的编程语言，应该比英语更容易理解软件，同时把代码写得便于阅读，并不意味着要塞进去很多注释。只有在那些不太成熟，容易出错的地方才需要加上注释</li>
</ul>
<h1 id="不能说的话"><a href="#不能说的话" class="headerlink" title="不能说的话"></a>不能说的话</h1><h2 id="不能说的话的特点"><a href="#不能说的话的特点" class="headerlink" title="不能说的话的特点"></a>不能说的话的特点</h2><ul>
<li>不能说出口</li>
<li>它们是正确的</li>
</ul>
<h2 id="如何寻找不能说的话"><a href="#如何寻找不能说的话" class="headerlink" title="如何寻找不能说的话"></a>如何寻找不能说的话</h2><p>一些给别人人贴诸如“失败主义者/制造分裂”的标签的行为是很可怕的</p>
<h3 id="异端邪说"><a href="#异端邪说" class="headerlink" title="异端邪说"></a>异端邪说</h3><h3 id="时空差异"><a href="#时空差异" class="headerlink" title="时空差异"></a>时空差异</h3><p>我们可以自以为是地相信，当代人比古代人更聪明，更高尚，但是，了解的历史越多，就能明白事实并非如此，古人适合我们一样的人，不管他们产生怎样的想法，都是正常人的想法。因此，时长回顾历史或者和当代的其他文化进行比较，如果一种行为只有在我们现在这个社会里当做禁忌，那么很有可能是我们出错了</p>
<h3 id="道貌岸然"><a href="#道貌岸然" class="headerlink" title="道貌岸然"></a>道貌岸然</h3><h3 id="流行产生的机制"><a href="#流行产生的机制" class="headerlink" title="流行产生的机制"></a>流行产生的机制</h3><p>道德禁忌的最大制造者是那些权力斗争中略占上风的一方，这一方有实力推行禁忌，但同时也需要积极保护自己的利益</p>
<p>大多数的斗争，不管它们实际上争的是什么，都会以思想斗争的形式表现出来。我并不是说斗争从来与思想无关，而是要强调，不管实际上是否有思想斗争，斗争总是会以思想斗争的形式表现出来</p>
<p>虽然流行的思想观点和流行的服饰产生方式不尽相同,但是它们的传播途径非常相似。第一批的接受者总是带有很强的胜负心，他们有自觉的精英意识，想把自己和普通人区别开来。当流行趋势确立以后，第二批接受者就加入进来了，恐惧心在驱使着他们（不是因为想要与众不同，而是因为害怕与众不同）</p>
<p>所以，如果你想要找到“不能说的话”，你可以考虑观察流行产生的方式</p>
<h2 id="为什么要找不能说的话"><a href="#为什么要找不能说的话" class="headerlink" title="为什么要找不能说的话"></a>为什么要找不能说的话</h2><ul>
<li>出于好奇心</li>
<li>我不希望我们自以为是正确的事将来被证明是荒谬可笑的。我希望我能提前知道这些事</li>
<li>这是很好的思维训练方式</li>
<li>优秀作品往往来自于其他人忽视的想法，而罪被忽视的想法就是那些被禁止的思想观点</li>
<li>科学家做事的方式，就是寻找传统观点无法自圆其说的地方，然后试着拆开那里，瞧瞧里面到底出了什么问题，新的理论就是这样产生的</li>
</ul>
<p>看来存在一个清晰的关联关系，智力越高的人，越愿意去思考那些惊世骇俗的漏洞，这不仅仅因为聪明人很积极地寻找传统的漏洞，还因为传统观念对他们的束缚很小，很容易摆脱。</p>
<h2 id="守口如瓶"><a href="#守口如瓶" class="headerlink" title="守口如瓶"></a>守口如瓶</h2><p>一旦发现了“不能说的话”，我的建议就是别说，至少也是挑选合适的场合再说，只打值得打的仗</p>
<p><strong>你应该要明白，自由思考比畅所欲言更重要</strong>如果你感到一定要跟那些人说个明白，绝不咽下这口气，结果很可能是你无法自由理性地思考了。我认为更好地方式是在思想和言论之间画一条明确的界限，在心里无所不想，但是不一定要说出来。“搏击俱乐部的第一条原则就是不要提到搏击俱乐部”</p>
<p>不过你最好还是找一些靠得住的朋友，只和他们畅所欲言，无所不谈</p>
<h2 id="防守的技巧"><a href="#防守的技巧" class="headerlink" title="防守的技巧"></a>防守的技巧</h2><p>如果你看不惯一些狂热分子，一个比较好的办法是把辩论提升到一个抽象的层次，可以</p>
<ul>
<li>攻击元标签，而不是原本的标签（这样别人就有机可乘）</li>
<li>隐喻</li>
</ul>
<h2 id="永远质疑"><a href="#永远质疑" class="headerlink" title="永远质疑"></a>永远质疑</h2><p><div id="question"><br>荷兰人认为自己思想开放，但是这种想法本身却什么也证明不了，有谁认为自己的思想不开放？美国郊区的中产阶级白人家庭普遍家教严格，限制孩子与外接多接触，可那里长大的孩子也认为自己思想开放呢！不管问谁，人们都会说同样的话“我们的心态很开放，愿意接受新思想”但实际上人们脑子里有一根界限，早就认准了什么是对的，什么是错的。<strong>在他们看来，所有观点都是可以讨论的，除了那些错误的观点</strong></div></p>
<p>如果你的数学不好，你自己会知道，因为考试的时候你得不出正确的答案。但是如果你思想很保守，你自己不会知道，而且很有可能会持有相反的想法。<strong>请记住，所谓流行，本质上就是自己看不见自己的样子，否则就不会有流行了</strong></p>
<p>想要摆脱你自己的时代的流行，需要一点自觉。你不要让自己成为人群的一份子，而要尽可能地远离人群，观察正在发生的事情，特别主要哪些<strong>被压制的思想观点</strong>。比如有些软件提供互联网过滤的功能，防止孩子和雇员看到色情的暴力的宣扬仇恨的网站，但是什么才叫色情和暴力？什么叫做宣扬仇恨？</p>
<p>如果一个命题不是错的，却被加上各种标签进行压制和批判，这就很有问题。当你听到有人在用这样的标签，就要问为什么</p>
<p>如果你想要清晰地思考，就必须远离人群，但走得越远，你的处境就会越艰难，受到的阻力也会越大</p>
<p>如果自己就是潮水的一部分，怎么能看见潮流的方向呢</p>
<h1 id="良好的坏习惯"><a href="#良好的坏习惯" class="headerlink" title="良好的坏习惯"></a>良好的坏习惯</h1><p>总体来看黑客是不服从管教的，但是不服从管教正是黑客之所以成为优秀程序员的原因之一</p>
<p><strong>公民的自由是一个国家富强的原因，而不是结果</strong></p>
<p>专制国家会变成腐败国家，腐败国家会变成贫穷国家，贫穷国家会变成弱小国家</p>
<p>哪些占居高位，本能地想要约束黑客，强迫黑客服从的人们，请小心你们的要求，因为你们真有可能成为千古罪人</p>
<h1 id="另一条路"><a href="#另一条路" class="headerlink" title="另一条路"></a>另一条路</h1><h2 id="B-S架构的优点："><a href="#B-S架构的优点：" class="headerlink" title="B/S架构的优点："></a>B/S架构的优点：</h2><ul>
<li>数据和软件本身都不必保存在终端设备上了，只需要一个浏览器你就能完成你想要的</li>
<li>bug会被发现地更快</li>
<li>适合团队开发</li>
<li>避免了发布新版本的噩梦（对于桌面软件来说，你必须积累很久的bug然后一起发布，接着就是新的bug，但对于web应用来说，大部分的变化都是细微和渐进的，引入bug的机会比较小）</li>
<li>因为用户的数据都在你的手上，你能很好地再现大部分的bug</li>
<li>解决新代码的bug要比解决历史遗留代码的bug容易，因为你更新的频率高，如果一个地方可能会出bug，你是会在脑子里有印象的</li>
<li>不容易形成复合式bug</li>
<li>客服和程序员之间交流的通道缩短了</li>
<li>一旦写完就能看到效果，这对开发人员来说是很大的激励</li>
</ul>
<h2 id="关于盗版"><a href="#关于盗版" class="headerlink" title="关于盗版"></a>关于盗版</h2><p>web软件很难有盗版，但是这也是一个问题。一定数量的盗版对软件公司是有好处的，不管你的软件定价是多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并不会有任何损失，事实上你反而赚到了，因为你的软件多了一个用户，市场影响力大了一分</p>
<p>只要有可能，商业性公司就会采取一种“价格歧视”的定价方法，这实际上就是针对不同的客户采取不同的报价，商业软件的定价非常适合这种方法，因为它的成本几乎等于0.盗版实际上也是一种价格歧视，</p>
<p><strong>通过ISP分销互联网软件，就好比让自动售货机出售寿司</strong></p>
<p>如果你想把钱藏在更安全的地方，你是选择放在家里的床垫下还是在银行里？</p>
<p>现在创业公司有更多的理由选择互联网软件创业，因为开发桌面软件越来越乏味了</p>
<p>“帕金森定律：因为你必须做到，所以你能做到”</p>
<p>互联网应用迫使程序员变成系统管理员</p>
<h2 id="如何做出用户喜欢的产品"><a href="#如何做出用户喜欢的产品" class="headerlink" title="如何做出用户喜欢的产品"></a>如何做出用户喜欢的产品</h2><ul>
<li>你自己愿意使用</li>
<li>迅速做出1.0版，并不断加以改进（听取用户的建议）</li>
<li>低端的用户希望简化操作和清晰易懂，高级用户希望增加新功能，<strong>做到这一点的方法是正确设置默认值，而不是限制用户的选择</strong></li>
</ul>
<h1 id="如何创造财富"><a href="#如何创造财富" class="headerlink" title="如何创造财富"></a>如何创造财富</h1><p>作者认为最好的办法就是自己创业，或者加入创业公司</p>
<p>通过创造有价值的东西致富，这种方法的优势不仅仅在于它是合法的，还在于他更简单，你只需要做出别人需要的东西就可以了</p>
<p>金钱不等于财富，财富是我们需要的东西。</p>
<p>金钱是专业化的副产品。交换媒介的优点是，它使交易可以进行下去。缺点是，它模糊了交易的实质，人们觉得做生意就是为了赚钱，不是，本质上人们还是为了更方便地获取自己想要的东西，</p>
<p>人们对财富总额总是有一种错误的固有观点，认为其总量是不变的。实际上，社会会的财富一直在增长和毁灭（总体为增长）</p>
<p>小团队=可量测性（大公司就不一样，很难评估你真正的工作效率）</p>
<p>回顾历史，大多数因为创造财富而发财的人都是通过开发新技术而实现的。</p>
<p>对于创业公司来说，很重要的一点就是如何跟大公司做周旋。假如你是一个身手敏捷的小男孩，身后一条身材壮硕的大狗在追你，你跑到楼梯口，这时应该上楼还是下楼，我觉得应该上楼，因为上楼的话，你会很累，但大狗会更累。在实际操作中，这就意味着我们应该总是选择比较难的功能，不是因为这个功能能带来更多的收入，而是因为它<code>比较难</code></p>
<p>对个人来说，付出和回报存在一个随机的放大因子</p>
<h1 id="关注贫富分化"><a href="#关注贫富分化" class="headerlink" title="关注贫富分化"></a>关注贫富分化</h1><p>有的时候你会想，任何人之间创造财富能力的差别真的有这么巨大吗？理解这一点的核心就在你是否愿意用一百个平庸的人交换那一个关键的人。也许CEO和运动员的技能和决心只比普通人高出10倍，但是人与人之间就是存在着重大区别</p>
<p>技术的发展是否加剧了贫富差距，首先，技术肯定加剧了有技术者和无技术者之间的生产效率差异，毕竟这就是技术进步的目的。这是不是一个社会问题？好像没有那么严重，技术在加大收入差距的同事，缩小了大部分的其他差异</p>
<p>无论在物质上，还是在社会地位上，技术好像都缩小了富人和穷人之间的差距</p>
<p>你经常可以听到有人批评某种政策会加剧贫富分化，隐藏的意思是，贫富分化的加剧一定是坏事。我不觉得这可以被看做为一个公理。</p>
<p>我想提出一种相反的观点，现代社会收入差距是一种健康的信号，技术使得生产率的差异加速扩大，如果这种扩大没有反应在收入上面，只要三种可能：1）技术革新停顿了2）那些创造大部分财富的的人停止工作了3）创造财富的人没有获得报酬。如果你想让社会保持繁荣，同时收入差距不哭到，那么只剩下3）这个选项。如果得不到报酬，人们是否还愿意创造财富，除非工作能提供乐趣。但即使是最先进的高科技公司，也会有至少90%的工作没有乐趣</p>
<p>从历史的角度看，只要你压制收入差距的扩大，最终结果一定是整体变得更加贫穷。你应该要避免绝对贫穷而不是相对贫穷 :）不妨去过一下9世纪的贵族生活</p>
<h1 id="防止垃圾邮件的一种方法"><a href="#防止垃圾邮件的一种方法" class="headerlink" title="防止垃圾邮件的一种方法"></a>防止垃圾邮件的一种方法</h1><p>略</p>
<h1 id="设计者的品味"><a href="#设计者的品味" class="headerlink" title="设计者的品味"></a>设计者的品味</h1><p>好设计是简单的设计</p>
<p>好设计是解决主要问题的设计</p>
<p>好设计是启发性的设计</p>
<p>好设计通常情况下是有点趣味性的设计</p>
<p>对称</p>
<p>模仿大自然</p>
<h1 id="编程语言解析"><a href="#编程语言解析" class="headerlink" title="编程语言解析"></a>编程语言解析</h1><p>高级语言的优点：</p>
<ul>
<li>程序更简短（相较于汇编）</li>
<li>程序具有可移植性</li>
</ul>
<p>开源的优点：</p>
<ul>
<li>修改bug</li>
<li>所有聪明人都可以参加</li>
</ul>
<p>“用什么语言都不重要，重要的是你对问题是否有正确的理解，代码以外的东西才是关键”。这当然是一派胡言，<code>fortran</code>和<code>perl</code>就是两种完全不一样的语言</p>
<p>事实是，语言之间确实存在差别，但是很难确定哪一种语言是最好的</p>
<p>并不是语言的抽象层次越高越好，也有可能完全走错了方向，另外使用低层次语言的原因就是效率问题</p>
<h1 id="一百年后的编程语言"><a href="#一百年后的编程语言" class="headerlink" title="一百年后的编程语言"></a>一百年后的编程语言</h1><p>我认为，编程语言就像生物物种一样，存在一个进化的脉络，许许多多分支都会成为进化的死胡同</p>
<p>效率地下的软件并不等于很烂的软件，一种让程序员做无用功的语言才能称得上真的烂。</p>
<h1 id="拒绝平庸"><a href="#拒绝平庸" class="headerlink" title="拒绝平庸"></a>拒绝平庸</h1><blockquote>
<p>Lisp真的很值得学习，你掌握它之后，会感到它给你带来的极大启发，这会大大提高你的编程水平，使你成为一个更好地程序员，尽管在实际工作中极少会用到Lisp</p>
</blockquote>
<p>作者认为，上述的说法不太靠谱，因为既然你觉得它很好用，那为什么不拿它来开发商业产品呢，而且作者确实这么做了。</p>
<h1 id="书呆子的复仇"><a href="#书呆子的复仇" class="headerlink" title="书呆子的复仇"></a>书呆子的复仇</h1><p>一些经历奇迹般地具备了两种很常见但很难结合在一起的特点：1）对技术一无所知2）对技术有强烈的个人观点</p>
<h2 id="Lisp语言的特点"><a href="#Lisp语言的特点" class="headerlink" title="Lisp语言的特点"></a>Lisp语言的特点</h2><ul>
<li>条件结构（if else then ）</li>
<li>函数可以作为变量</li>
<li>递归</li>
<li>变量的动态类型</li>
<li>垃圾回收机制</li>
<li>程序由表达式组成</li>
<li>符号类型</li>
<li>代码使用符号和常量组成的树形表示法</li>
<li>无论什么时候，代码都是可用的</li>
</ul>
<p>Lisp的最大优势就在竞争激烈的条件下开发哪些解决困难问题的复杂程序</p>
<h1 id="梦寐以求的编程语言"><a href="#梦寐以求的编程语言" class="headerlink" title="梦寐以求的编程语言"></a>梦寐以求的编程语言</h1><p>没人愿意在程序的头部加上一大堆的声明语句（java）</p>
<h1 id="设计与研究"><a href="#设计与研究" class="headerlink" title="设计与研究"></a>设计与研究</h1><p>优秀的建筑师不会先设计，然后强迫用户接受，而是先研究最终用户的需求，然后做出用户需要的设计</p>
<h1 id="读书感悟"><a href="#读书感悟" class="headerlink" title="读书感悟"></a>读书感悟</h1><p>重新读本书的时候，一边看一边将重要的段落摘抄下来，说来惭愧，二刷的时候竟然有一种一刷的感觉，之前看的时候实在过于鲁莽，囫囵吞枣。说实话，全篇读下来，真正关于编程的干货大概只有四成，剩下的全是作者对于生活细节的洞见和思考，思想深邃程度不逊于我原来所看的一些专业书籍，真是一个妙人儿，居然能在不止一个领域做到卓越，非常了不起。其中，作者有关<a href="#question">质疑</a>的部分也是极为有趣，非常值得回味。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Web语义化</title>
    <url>/2018/07/11/%E4%BB%80%E4%B9%88%E6%98%AFWeb%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>web语义元素的定义和我自己的理解</p>
</blockquote>
<a id="more"></a>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.zhihu.com/question/20455165" target="_blank" rel="noopener">知乎（如何理解Web语义化）</a></p>
<p><a href="http://justineo.github.io/slideshows/semantic-html/#/" target="_blank" rel="noopener">一个使用reveal.js写的挺炫酷的语义dom讲解</a></p>
<h1 id="权威解释"><a href="#权威解释" class="headerlink" title="权威解释"></a>权威解释</h1><blockquote>
<p>什么是语义化？其实简单说来就是让机器可以读懂内容。</p>
<p>先随便扯扯。对于当前的 Web 而言，HTML 是联系大多数 Web 资源的纽带，也是内容的载体。在 Web 被刚刚设计出来的时候，Tim Berners-Lee 可能不会想到它现在会达到的规模以及深入到我们生活的那么多方面。也许起初的想法很简单：用来发布 Web 内容和资源的索引，方便人们查看。</p>
<p>但是随着 Web 规模的不断扩大，信息量之大已经不在人肉处理的范围之内了。这个时候人们开始用机器来处理 Web 上发布的各种内容，搜索引擎就诞生了。再后来，人们又设计了各种智能程序来对索引好的内容作各种处理和挖掘。所以让机器能够更好地读懂 Web 上发布的各种内容就变得越来越重要。</p>
<p>其实 HTML 在刚开始设计出来的时候就是带有一定的「语义」的，包括段落、表格、图片、标题等等，但这些更多地只是方便浏览器等 UA 对它们作合适的处理。但逐渐地，机器也要借助 HTML 提供的语义以及自然语言处理的手段来「读懂」它们从网上获取的 HTML 文档，但它们无法读懂例如「红色的文字」或者是深度嵌套的表格布局中内容的含义，因为太多已有的内容都是专门为了可视化的浏览器设计的。面对这种情况，出现了两种观点：</p>
<p>1.我们可以让机器的理解能力越来越接近人类，人能看懂、听懂的东西，机器也能理解</p>
<p>2.我们应该在发布内容的时候，就用机器可读的、被广泛认可的语义信息来描述内容，来降低机器处理 Web 内容的难度（HTML 本身就已经是朝这个方向迈出的一小步了）。</p>
<p><img src="https://pic2.zhimg.com/01b4d93c152d2a9c2db734065be0f3f5_b.jpg" alt></p>
<p>我画的这个图，意思是说，内容的语义表达能力和 AI 的智能程度决定了机器分析处理 Web 内容能力的高低。上面观点 1 的方向是朝着人类水平的人工智能努力，而观点 2 的方向正是万维网创始人 Tim Berners-Lee 爵士提出的美好愿景：语义网。语义网我就不多说了，简单来说就是让一切内容和包括对关系的描述都成为 Web 上的资源，都可以由唯一的 URI 定义，语义明确、机器可读。显然，两条路都的终极目标都很遥远，第一条路技术上难以实现，而第二条路实施起来障碍太多。</p>
<p>我认为我们当前能够看得见摸得着的 Web 语义化，其实就是在往第二条路的方向上，迈出的一小步，即对已经有的被广泛认可的 HTML 标准做改进。我们刚开始意识到，我们必须回归内容本身，将内容本身的语义合理地表述出来，再为不同的用户代理设计不同的样式描述，也就是我们说的内容与样式分离。这样我们在提供内容的时候，首先要做的就是将内容本身进行合理的描述，暂时不用考虑它的最终呈现会是什么样子。</p>
<p>HTML 规范其实一直在往语义化的方向上努力，许多元素、属性在设计的时候，就已经考虑了如何让各种用户代理甚至网络爬虫更好地理解 HTML 文档。HTML5 更是在之前规范的基础上，将所有表现层（presentational）的语义描述都进行了修改或者删除，增加了不少可以表达更丰富语义的元素。为什么这样的语义元素是有意义的？因为它们被广泛认可。所谓语义本身就是对符号的一种共识，被认可的程度越高、范围越广，人们就越可以依赖它实现各种各样的功能。</p>
<p>HTML5 并非 Web 语义唯一倚仗的规范，除了 W3C 和 WHATWG 外，还有其它的组织在为扩展、标准化 Web 语义做着贡献。只要有浏览器厂商、搜索引擎原意支持，它们的规范一样可以成为通用的基础设施。例如 microformats 社区以及 <a href="http://Schema.org" target="_blank" rel="noopener">http://Schema.org</a> 上都有对 HTML 以及 Microdata（<a href="http://www.w3.org/TR/html5/microdata.html）" target="_blank" rel="noopener">http://www.w3.org/TR/html5/microdata.html）</a> 规范的扩展词汇表，Google、Bing、Yahoo! 等搜索引擎以及各个主流浏览器都不同程度地接纳了其中定义的语义扩展，并应用在了生产中。</p>
</blockquote>
<h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><p>首先要明确一点，这一次任务虽然非常简单，但是却是很重要的一节，我自己做项目的时候能够感觉得出来，div的语义化写得不明显就只能用class来凑，感觉很不规范。</p>
<p>我之前一直在想在网上找规范什么的，突然在IFE的笔记区里看到一个另我豁然开朗的答案————直接去大厂的html里看啊，看人家是怎么设定html的，直接对着写两个，自己马上就能明白</p>
<blockquote>
<p>发现自己还是too young，看了下淘宝和微博，发现它们都是用的div，根本没怎么在语义上下功夫</p>
</blockquote>
<p>记好这张图就好了<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1531313829236.png" alt></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于知识输出</title>
    <url>/2020/01/27/%E5%85%B3%E4%BA%8E%E7%9F%A5%E8%AF%86%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>一些关于知识输出的思考</p>
<a id="more"></a>
<p>近日，一件事情引发了我对知识输出平台的思考：我在公众号里关注的一位极其优秀的前端行业从业者在年终总结中透露出他是年初才开始入的前端坑，我当时就极其震撼，感觉自己本科期间学习的几年内容完全是白学了，这位作者自言也是今年开始在掘金上发布有质量的文章，同时开始写公众号，持续输出知识。看到这里，我开始认真思考起我的知识输出途径</p>
<p>目前，我的知识输出途径还比较有限且封闭，一个是github pages上搭建的自用博客，目前零零散散地写了一些文章，还有就是github上维护了两个基于docsify的项目，主要用于记录前端知识点，我自认为输出的质量不低，但是说实话这两种途径输出的效果比较封闭。我思考今年应该寻求怎么样的一个新形式来保证自己的输出质量和效果</p>
<p>但是老实说，我是比较反感技术人员用公众号的形式进行输出的，理由有很多很多。</p>
<p>第一公众号封闭，它没有办法用rss扒，只能在移动端取得比较好的阅读体验，哪怕在pc的原生客户端上，阅读起来也相当费劲，比如我要是在公众号上找到了一个有质量的发布者，我想阅读他的全部作品，是一件非常费劲的事。</p>
<p>第二，我认为公众号本身是一个对标报纸/新闻的产品，报纸的好处在于每天都有新鲜的看，但是一般阅读难度和深度都不大，属于娱乐型的阅读途径，很少有人会把去年一年的报纸拿过来整合看，这样做非常蠢也不符合报纸的定位。公众号在我这看来同样如此，它就像一个流，只适合浅层次阅读。当然我们如果想将公众号内容整合起来也可以做对应的开发工作，当然这在我看来属于得不偿失的工作，为什么要想尽办法给猫套上马鞍呢？</p>
<p>第三，公众号没有办法和pocket这样的延迟阅读的工具整合在一起，虽然有微信的收藏功能，但是这也丢失了pocket的全平台整合的优势了</p>
<p>第四，我个人在阅读学习类知识时，更偏向用电脑或者纯电子书，手机阅读是最次最次的选择，原因很简单，手机上诱惑更多更大，很多情况你就不知不觉跑去看微博去了。同时，电脑上有编辑器，有终端，有各种测试手段，比手机上的阅读体验要好很多。这也是我非常反感极客时间的打卡限定小程序平台上的原因，打卡总结知识在我看来用电脑要顺滑百倍，可惜的是只能在小程序端打卡。</p>
<p>第五，公众号抱团化，同质化问题严重，当然CSDN上的文章同质化问题也不小，但是当我集中刷公众号上的文章时，我发现这个问题的严峻性还是超乎了我的想象，我不知道是因为可以凑字数，使公众号看起来饱满还是单纯的公众号作者之间报团取暖，我关注了接近二十多个前端领域的公众号，其中绝大多数发布的文章同质化极其严重，一个问题你讲过来我讲过去，显得很没有水准和诚意。当然我们平时自己也有开发任务在身，不可能说一周全部的时间都用来写原创内容，但是我觉得可以以周报的形式来汇总自己觉得有价值的文章，自己可以做微评或者本周的原创工作基于周报上的内容进行展开，这在我看来是一个比较好，比较规范的知识输出途径</p>
<p>写到这里，我自己大概也有些思绪了。2020年开始，我的知识输出将以以下几个板块为主</p>
<h2 id="知识笔记"><a href="#知识笔记" class="headerlink" title="知识笔记"></a>知识笔记</h2><p>零零散散的博客一旦数量汇集起来会显得非常散乱，我需要一个规范的，有条理的archive来将我所学习的知识进行整合起来，这个部分我还是交给我在github上维护的<a href="https://github.com/luvsunlight/front-end-cookbook" target="_blank" rel="noopener">项目</a></p>
<h2 id="单独的博客"><a href="#单独的博客" class="headerlink" title="单独的博客"></a>单独的博客</h2><p>这个系列是精讲知识，比如单独拎出一个知识点，或者学习某一项新技术，这些东西放在知识笔记里不合适，以博客的形式记录最好。我选择githubpages搭的博客，以及掘金这两个平台进行发布，前者是为了获取更多的曝光量，让我开始和社区进行有效的互动，后者则是我作为程序员自己的私域</p>
<h2 id="维护一份前端周报"><a href="#维护一份前端周报" class="headerlink" title="维护一份前端周报"></a>维护一份前端周报</h2><p>我对前端始终怀有热爱和虔诚，我获取前端知识的渠道非常广，极客时间，掘金，InfoQ，segmentfault，书籍，公众号，微博…。每一个平台都有各自的特点和可取之处，我决定在2020年维护一份前端周报</p>
<p>我自己平时关注的周报的形式也有不同，简单的如腾讯新闻团队的github上建一个项目，复杂一点的如蚂蚁金服的在语雀上发布的项目。我更偏向于前者，一个是周报量不大，没有必要用一个很大的项目来维护。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>初识shell</title>
    <url>/2017/10/12/%E5%88%9D%E8%AF%86shell/</url>
    <content><![CDATA[<blockquote>
<p>事情的初衷是我在测试站点配置时需要不断重复一些步骤，比如<code>deploy三连</code>，<code>建站二连</code>，虽然使用终端操控已经很简便了，但是尝试多了之后也会厌烦。于是想到写一个shell脚本来帮助我完成以上的任务，这样的话我每次只要打开终端，按一个小小的<code>up</code>键调用历史命令就可以完成上述任务了。同时这也是我真正意义上第一次接触<code>shell脚本编程</code></p>
</blockquote>
<a id="more"></a>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>在开始写脚本之前还需要进行一些基础的环境配置</p>
<h2 id="新建shell文件夹"><a href="#新建shell文件夹" class="headerlink" title="新建shell文件夹"></a>新建shell文件夹</h2><p>这个主要是方便管理shell文件，因为以后肯定还要写的，干脆用一个统一的文件夹存起来好了，我的存储路径是<code>/Users/lizhiyuan/Documents/Shell</code></p>
<h2 id="将上述文件夹路径添加至环境变量"><a href="#将上述文件夹路径添加至环境变量" class="headerlink" title="将上述文件夹路径添加至环境变量"></a>将上述文件夹路径添加至环境变量</h2><p>主要是每次启动终端想要打开shell文件，都需要首先<code>cd</code>到上述路径里，太麻烦了，不如直接添加到环境变量里，这样的话每次只需要在终端里敲shell文件名就可以运行shell文件了</p>
<p>mac下自带的终端是<code>bash</code>，我之前换成了<code>zsh</code>，影响都不大。如果是<code>bash</code>，就打开<code>.bash_profile</code>文件，如果是<code>zsh</code>，就打开<code>.zshrc</code>，然后添加如下代码</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=/Users/lizhiyuan/Documents/Shell:$PATH</span><br></pre></td></tr></table></figure>
<p>大意就是将上述路径添加至环境变量，当然我为了懒，还在里面添加了</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alias</span> <span class="title">shfile</span>=<span class="string">"/Users/lizhiyuan/Documents/Shell"</span></span><br></pre></td></tr></table></figure>
<p>就是将上述路径命了一个别名叫<code>shfile</code>，这样我每次在终端里输入<code>shfile</code>就可以进入上述路径了</p>
<p>当然这里可以一次搞完，再添加一下博客的别名</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alias</span> <span class="title">blog</span>=<span class="string">"/Users/lizhiyuan/Documents/blog"</span></span><br></pre></td></tr></table></figure>
<h2 id="检验效果"><a href="#检验效果" class="headerlink" title="检验效果"></a>检验效果</h2><p>重启终端，直接键入之前的关键词，如<code>blog</code>，<code>shfile</code>，如果能直接显示进入路径则表示更改成功，当然也可以通过输入</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">PATH</span></span><br></pre></td></tr></table></figure>
<p>来查看当前环境变量</p>
<h1 id="deploy三连"><a href="#deploy三连" class="headerlink" title="deploy三连"></a>deploy三连</h1><p>哈哈这个名字是起着好玩的，实际上就是每次需要把本地hexo博客上传至github或者其他托管的网站上需要的三个步骤，现在我将其简化，只需要一个<code>deploy.sh</code>就可以完成步骤</p>
<h2 id="新建shell文件"><a href="#新建shell文件" class="headerlink" title="新建shell文件"></a>新建shell文件</h2><p>在之前的<code>shell</code>文件夹下，新建一个名为<code>deploy.sh</code>（或者其他你认为可以表示这样一个过程的名字）的文件</p>
<h2 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码"></a>添加代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/Documents/blog</span><br><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>其中第一行表示这个文件由<code>zsh</code>来解释,如果你的电脑是<code>bash</code>，就改成<code>#!/bin/bash</code></p>
<h2 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h2><p>如果直接在终端里运行上述文件，终端会提示你没有权限，这个时候我们需要<code>cd</code>到<code>shell</code>的根目录下，比如我的电脑就是<code>cd ~/Documents/shell</code>，然后输入<code>chmod +x  deploy.sh</code>,权限问题解决</p>
<h2 id="newSite二连"><a href="#newSite二连" class="headerlink" title="newSite二连"></a>newSite二连</h2><blockquote>
<p>这个问题说实话我还没有很好地解决，目前只是用了一个替代方法。</p>
</blockquote>
<p>首先说明这个文件的需要，背景是我每次调试网站时，有些变化需要重新部署环境才能看到的，也就是说我需要</p>
<ol>
<li>终止当前<code>hexo serve</code>服务</li>
<li>查看当前端口<code>4001</code>被什么进程占用了（我默认是用4001，因为4000被<code>node</code>占用了）</li>
<li>kill 上述进程</li>
<li>cd blog目录</li>
<li><code>hexo serve --port 4001</code></li>
</ol>
<p>前三步可以用关掉当前终端来解决，但是用多了之后还是会觉得麻烦，最好是用一个脚本解决上述所有问题，不需要关闭终端，脚本自动找到端口<code>4001</code>占用的进程，并且kill掉上述进程，之后启动<code>serve</code>服务。</p>
<p>问题就出在找到指定端口对应的进程，原来我是采用<code>$ lsof -i:4001</code>来查看，但是这个命令只能log当前进程，我不知道能不能返回当前进程，再加上我对shell的语法不是很熟悉，所以只能在网上寻求帮助，但是搜索一圈之后也无果。后来发现<code>netstat</code>命令也可以实现类似的功能，但是在自己尝试解析<code>netstat</code>时，发现终端似乎无能为力</p>
<p>我目前采取的解决方案是写一个脚本运行上述的<code>4，5</code>步骤，其他的用关闭终端来解决。脚本命名为<code>newSite.sh</code>，内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/Documents/blog</span><br><span class="line"></span><br><span class="line">hexo serve --port 4001</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以后彻底解决了这个问题再来补充</p>
</blockquote>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程师的ppt reveal.js</title>
    <url>/2018/09/05/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84ppt-reveal-js/</url>
    <content><![CDATA[<p>不管是学生还是社畜，ppt始终是一个难以绕过的坎。没有艺术细胞的人对此的苦恼自不必说，即使对艺术感兴趣，限于时间和精力有限，我们也很难</p>
<a id="more"></a>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><h2 id="1-1-reveal-js是什么？"><a href="#1-1-reveal-js是什么？" class="headerlink" title="1.1 reveal.js是什么？"></a>1.1 reveal.js是什么？</h2><p>最开始我接触这个技术的时候是上次学习顾秩灵的<a href="http://justineo.github.io/slideshows/semantic-html/#/" target="_blank" rel="noopener">web语义化</a>，当时看的时候就觉得惊为天人，炫酷不说，而且和专业相关能够表现出自己的专业性</p>
<p>说了再多不如直接去看演示</p>
<p><img src="https://cdn.sspai.com/2017/08/29/4b2715265f01b94d10037572bf7f2948.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="gif"></p>
<p>它最突出的功能都在其官网主页展示得很清楚了，你只需要像坐火车一样静心欣赏它的美景就可以了</p>
<p>当然它最吸引我的还是其对markdown语法的支持，对于我这样重度md爱好者来说就是最好的福音</p>
<h2 id="1-2-它的优势"><a href="#1-2-它的优势" class="headerlink" title="1.2 它的优势"></a>1.2 它的优势</h2><ul>
<li>炫酷</li>
<li>可配置型不错（比不过ppt大佬，但强于一般人）</li>
<li>表现形式强</li>
<li>相比ppt碎片化表现感更强（ppt的基本展现单元是页，而这个可以是段）</li>
<li>支持markdown语法</li>
</ul>
<h2 id="1-3-相似的技术"><a href="#1-3-相似的技术" class="headerlink" title="1.3 相似的技术"></a>1.3 相似的技术</h2><ul>
<li><a href="http://imakewebthings.com/deck.js/#intro" target="_blank" rel="noopener">deck.js</a></li>
<li><a href="http://www.dowebok.com/107.html" target="_blank" rel="noopener">Scrollify</a></li>
<li><a href="https://github.com/alvarotrigo/fullPage.js/tree/master/lang/chinese#fullpagejs" target="_blank" rel="noopener">fullPage.js</a> [这个也非常好]</li>
<li><a href="http://bartaz.github.io/impress.js" target="_blank" rel="noopener">impress.js</a></li>
</ul>
<h1 id="2-参考资料"><a href="#2-参考资料" class="headerlink" title="2. 参考资料"></a>2. 参考资料</h1><ul>
<li><a href="https://sspai.com/post/40657" target="_blank" rel="noopener">把你的markdown变成PPT</a></li>
<li><a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">reveal.js的github地址</a></li>
<li><a href="https://revealjs.com/#/" target="_blank" rel="noopener">reveal.js的官方演示</a></li>
<li><a href="http://htmlcheats.com/reveal-js/reveal-js-tutorial-reveal-js-for-beginners/" target="_blank" rel="noopener">reveal.js tutorial</a></li>
</ul>
<h1 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h1><h2 id="3-1-一些快捷操作"><a href="#3-1-一些快捷操作" class="headerlink" title="3.1 一些快捷操作"></a>3.1 一些快捷操作</h2><ul>
<li>息屏 [B]</li>
<li>演讲者模式 [S] <img src="http://oy2kvpd7z.bkt.clouddn.com/md/1536131461154.png" alt="png"></li>
<li>缩放模式 [ESC]</li>
<li>全屏模式 [F]</li>
</ul>
<h2 id="3-2学习步骤"><a href="#3-2学习步骤" class="headerlink" title="3.2学习步骤"></a>3.2学习步骤</h2><p>多说无益，直接去看我上面列出的参考资料即可，虽然官方给出的api配置繁多，但想要实现基本功能却是非常简单。</p>
<p>我的建议是首先上它的github上下载源文件之后，首先学习它的index.html，这个比较简单而且一开始上手的话利于理解它整体的结构。这段代码很少，应该很快就能理解。然后再慢慢啃demo.html，理解完demo.html应该就差不多了，剩余的一些api就没有必要学得太详细了，需要用的时候再查就可以了</p>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>reveal.js</tag>
      </tags>
  </entry>
  <entry>
    <title>初识markdown</title>
    <url>/2017/10/09/%E5%88%9D%E8%AF%95markdown/</url>
    <content><![CDATA[<blockquote>
<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>markdown其实很早就有所接触，但是原来的话一是没有机会来接触，平时全部都以onenote的形式输出。原来使用的是<a href="https://ulyssesapp.com/" target="_blank" rel="noopener">Ulysess</a>，这个工具页面设计非常优秀，UI非常舒服，我也在上面写过很多私人的文章，但是当我正式开始写博客之后，我突然发现ulysess还是不太方便（也有可能是我对ulysess的了解太少了）。在短暂尝试了<a href>macdown</a>之后，我发现原来这款软件才是我喜欢的风格<br><a id="more"></a></p>
</blockquote>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>代码高亮</li>
<li>样式美观</li>
<li>可以即时渲染</li>
</ol>
<h2 id="推荐markdown软件"><a href="#推荐markdown软件" class="headerlink" title="推荐markdown软件"></a>推荐markdown软件</h2><p>当然这里还有一些推荐的markdown（macOSx）可供选择</p>
<ul>
<li><a href="http://25.io/mou/" target="_blank" rel="noopener">mou</a>（mac升级到sierra之后官网上下的版本都不兼容了）</li>
<li><a href="http://macdown.uranusjr.com/" target="_blank" rel="noopener">macdown</a></li>
</ul>
<h1 id="快捷按键"><a href="#快捷按键" class="headerlink" title="快捷按键"></a>快捷按键</h1><p>想要入门一项技术，最好的方法就是找一些简单的事情来做，在动手实践中提升信息和这门技术的喜爱<br>其实，如果你采用专业的markdown软件的话你会发现其实大部分软件都把常用的功能都绑定了快捷键<br>这里以<a href="http://macdown.uranusjr.com/" target="_blank" rel="noopener">macdown</a>为例，记录一下一些常用的按键</p>
<h2 id="宏观操作"><a href="#宏观操作" class="headerlink" title="宏观操作"></a>宏观操作</h2><h3 id="关闭预览"><a href="#关闭预览" class="headerlink" title="关闭预览"></a>关闭预览</h3><p><code>command+shift+H</code></p>
<h2 id="细节操作"><a href="#细节操作" class="headerlink" title="细节操作"></a>细节操作</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><code>command+1/2/3／...</code></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p><code>command+K</code></p>
<h3 id="区域代码"><a href="#区域代码" class="headerlink" title="区域代码"></a>区域代码</h3><p>可以直接tab，或者六个‘’‘’‘’<br>建议是六个`，因为前者在next上显示会有问题</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>command+/</code></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><code>command+shift+K</code></p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><code>command+shift+I</code></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><code>command+shift+B</code></p>
<h3 id="顺序序列"><a href="#顺序序列" class="headerlink" title="顺序序列"></a>顺序序列</h3><p><code>command+shift+O</code></p>
<h3 id="非顺序序列"><a href="#非顺序序列" class="headerlink" title="非顺序序列"></a>非顺序序列</h3><p><code>command+shift+U</code></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="使用markdown中遇到的问题汇总"><a href="#使用markdown中遇到的问题汇总" class="headerlink" title="使用markdown中遇到的问题汇总"></a>使用markdown中遇到的问题汇总</h2><ol>
<li>’#‘章节标记后面应立即接空格，这个bug在markdown软件上没有问题，但是上传到网站上时就会出现错误</li>
<li>markdown默认是不换行的，直接换行认为是同一个段落。想要切换段落只能直接按<code>enter</code></li>
<li><a href="http://macdown.uranusjr.com/" target="_blank" rel="noopener">macdown</a>有很多快捷键本来可以使用，但用着用着就失效了，目前还没有找到原因，留着将来补充…</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>markdown其实语法很简单，但是只有持续不断地输出才能最好发挥它的价值</p>
</blockquote>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>土拨鼠之日观后感</title>
    <url>/2018/07/26/%E5%9C%9F%E6%8B%A8%E9%BC%A0%E4%B9%8B%E6%97%A5%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>假如生命只剩下1天，你会做什么？</p>
<a id="more"></a>
<p>高中的时候其实就听说了这部电影，但是直到本科毕业才有机会看。最近看了两遍，真的感触很深，还是写一份影评来记录一下感受和自己的看法</p>
<blockquote>
<p>剧透警告</p>
</blockquote>
<p>主角菲尔是一个记者，他们当地的小镇在每年开春2月2号都有一个习俗，那就是通过土拨鼠能否看到自己的影子来判断春天是否来临</p>
<p>这当然只是一个引子，有趣的是当主角在2号之后醒来发现自己竟然还是处于2号的状态，一开始他以为只是一个无趣的骗局，可是当他走出旅馆时他惊恐地发现身边所有的事都和昨天经历过的一模一样。他发现了，自己已经陷入了一日囚，他尝试向自己的新同事丽塔倾诉，可被视作一个crazy guy</p>
<p>他愤怒继而失望</p>
<p>之后他意识到不管你当天做什么，第二天都会恢复原样，道德和规则对他来说就不存在任何意义。他通过一次次询问的方式来获取姑娘们的信息，然后第二天的时候自如地说出这些信息以尽可能博得姑娘们的好感，他这样的策略是成功的。但是他发现自己始终还有一个人无法攻克，那就是他的同事丽塔</p>
<p>他通过很多天来彻底摸清楚关于丽塔的一切，以尽可能地完成一个近乎完美的一日约会，可每次他都会失败，丽塔总是能在最关键的时刻发现他的阴谋</p>
<blockquote>
<p>“你在干什么？你甚至都不了解我？你在向我的好友们打电话以试图了解我的习惯吗？你这是真正的爱吗”</p>
</blockquote>
<p>他在彻底失败了很多次之后，彻底绝望了，他开始丧失了对生活的兴趣</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532610526991.png" alt></p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532610546245.png" alt></p>
<p>（男主的演技真的是没话说）</p>
<p>这一段我真的看的特别有感触，男主的那种绝望的眼神，我能明白</p>
<p>于是，他开始自杀，各种方式，火烧，撞车，电击，吃毒，无论他尝试哪一种第二天早上6点他都会回到最初旅馆的那张床上</p>
<p>他又一次陷入了另一种绝望，他开始找女主倾诉他的经历和一切，他说他是神“神之所以全知全能，只是因为他在人间待得够久”他能叫出小镇里每一个人的名字和经历，甚至能准确预报出接下里一段时间内会发生哪些事情。他说他自己因为无聊花了很多时间来训练一些平时可能根本不会注意的技巧，女主迷上了他，他们相爱了，但是男主这个时候眼里还是充满了暗淡</p>
<blockquote>
<p>我想说的是，你是我一生中见过的最善良，最体贴，最美丽的人。我从没见过任何人比你待人更好。第一次见到你，在我身上发生了奇妙的事情，我从没告诉过你，我知道我想用尽全身力气紧紧地拥抱你，我配不上像你这样的，但如果可以，我发誓我会爱你，一生一世<br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532610944692.png" alt></p>
</blockquote>
<p>第二天起来，男主又回到了起点</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532611173610.png" alt></p>
<p>看看他这个眼神</p>
<p>男主之后开始改变了策略，他开始对生活中各式各样的东西感到新奇，并且每一项都花了大力气去学习，钢琴，冰雕，修车，急救术，他开始关心周围所有的人，他开始热爱身边所有的事物。当然他也碰到了当天必定会死救不回来的流浪汉</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1532611390913.png" alt></p>
<p>当他开始真正积极地面对生活的时候，女主（或者说任何一个人）都情不自禁地爱上了他。</p>
<hr>

<p>说说我的想法吧</p>
<p>有一些瑕疵，但不失为一个精彩的电影。对现实很有指导意义。我指的瑕疵主要是剧情安排有一些刻意，比如最后的桥段，菲尔的改变导致大家都喜欢他，这当然是很好的事，但是桥段显得很刻意和突兀，一定程度上降低了这部电影在我心中的观感</p>
<p>当然，他揭示的道理，作为商业片来讲，还是非常深刻和鞭辟入里的。</p>
<p>当然我对片子里的真实性还是有一点存疑，这里并非是说一日囚这种奇遇，而是男主的态度。他的情感态度实际上是跟电影的节奏保持一致的，这也让我们在看的时候觉得连贯，但如果仔细推敲的话，这其实和男主实际经历的时间不一样。我之前看过有人分析说男主在这一天里已经困了二三十年了，假设真的有这么久的话，我很好奇男主是否还能对女主把持这样的激情呢</p>
<p>爱情究竟是一种怎么样的东西呢？</p>
<p>一见钟情，两相情悦这些都是经典的爱情理论和人们对于爱情的固有印象。那么如果是一方单方面的追求，这样的一段关系，究竟在多大程度上能够和爱情划上等号呢？</p>
<p>一种解释可能是这样的：追求只是让对方注意到你的机会，你可以在这个过程中尽情地展示你的魅力和决心，让对方逐渐对你产生好感。毕竟恋爱或者说爱情产生的必要条件就是双方都对对方产生水准之上的好感，而追求这个过程就是加速你们之间的进程。（自己把自己说服了）</p>
<p>同样，在恋爱或者说交往的过程，其实也是一个双方互相认同和成长的过程，我们能收获认同感，也能收获责任感</p>
<p>感觉我自己目前是享受不了这些特权了，一方面我自己的能力还不够强，另一方面我对感情的认识还很浅薄和肤浅。电影里揭示的道理简洁而深刻，感情从来就不是靠追，而是双方互相吸引，彼此喜欢，仅此而已。我们要做的就是尽可能地投资自己，让自己变得尽可能的充实</p>
]]></content>
      <categories>
        <category>影评</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>应对DNS污染</title>
    <url>/2017/10/14/%E5%BA%94%E5%AF%B9DNS%E6%B1%A1%E6%9F%93/</url>
    <content><![CDATA[<blockquote>
<p>事情的起因是昨天室友跟我反映说他们b站上不去了，看我能不能登录。我发现我的电脑当时能够登录，但是当晚却始终load不出来，不仅如此，还有很多其他的网站如最近关注的个人博客登录不上，后来通过一系列分析确定应该是DNS污染的问题，并通过修改本地dns服务器来成功解决此问题</p>
</blockquote>
<a id="more"></a>
<h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><h2 id="问题的出现"><a href="#问题的出现" class="headerlink" title="问题的出现"></a>问题的出现</h2><p>2017/10/13日我和室友的电脑先后出现了部分网站上不去的问题（网速经测验没有问题），以我个人为例，打不开的网页有以下几个：</p>
<ul>
<li><a href="https://www.bilibili.com/" target="_blank" rel="noopener">b站</a></li>
<li><a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云存储</a></li>
<li><a href="http://peihao.space/" target="_blank" rel="noopener">关注的私人博客</a></li>
</ul>
<p>这些网站都有一个特点，网页的title能解析出来，但是dom始终是一片空白，说明网页的服务器没问题，html能收到，可能是某个资源解析阻塞了。打开了调试之后发现，bootstrap的<a href="http://www.bootcdn.cn/" target="_blank" rel="noopener">cdn服务
</a>的资源始终加载不出来，看来问题可能在这里。bootstrap的cdn是非常普遍的cdn解决方案，很多网站都采用了。也就是说如果这个问题不解决，很有可能会对我们的上网体验造成很大的困扰。遂上网查询了类似问题，有网友提到了可能是dns污染。我对计算机网络的了解也是一知半解，正好借这个机会捋一捋知识网。</p>
<h1 id="关于DNS污染和DNS劫持"><a href="#关于DNS污染和DNS劫持" class="headerlink" title="关于DNS污染和DNS劫持"></a>关于DNS污染和DNS劫持</h1><h2 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h2><p>在讲<code>DNS</code>之前，还是先提一下<code>计算机网络通讯</code>，<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832511628f1fe2c65534a46aa86b8e654b6d3567c000" target="_blank" rel="noopener">具体</a>不细说，大概意思就是计算机们之间是通过协议来进行通讯，最基本的协议有<code>TCP</code>和<code>UDP</code>，这些协议只需要知道对方的<code>ip</code>和<code>端口号</code>（web服务的端口统一是<code>80</code>）。实际上也就是说理论上你只要知道对方电脑的<code>ip</code>就可以访问。但是世界上计算机这么多,想要记住别人的ip何其苦难而且也没必要。于是人们开发出了<code>域名</code>系统，比如<code>www.baidu.com</code>对应的就是百度服务器的<code>ip</code>，那么我们在浏览器中输入对应的域名，这个域名怎么解析成对应的ip呢？这时候就要靠我们的<code>dns</code>系统了。</p>
<blockquote>
<p>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53</p>
</blockquote>
<p>这是官方对dns的解释，实际上就是一个<code>域名字典</code>，能够根据域名来解析出对应主机的ip地址.我们打开<code>终端</code>，输入</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$<span class="built_in"> ping </span>www.zhihu.com</span><br></pre></td></tr></table></figure>
<p>得到的结果为</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">PING 6ej19t5k0le6q937.alicloudlayer.com (118.178.213.186): 56 data bytes</span><br><span class="line">64 bytes <span class="keyword">from</span> 118.178.213.186: <span class="attribute">icmp_seq</span>=0 <span class="attribute">ttl</span>=29 <span class="attribute">time</span>=27.525 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 118.178.213.186: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=29 <span class="attribute">time</span>=27.360 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 118.178.213.186: <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=29 <span class="attribute">time</span>=24.600 ms</span><br></pre></td></tr></table></figure>
<p>说明我们本机能够访问<code>www.zhihu.com</code>,并且能够看到，解析出来的ip是<code>118.178。213.186</code></p>
<h2 id="DNS污染"><a href="#DNS污染" class="headerlink" title="DNS污染"></a>DNS污染</h2><blockquote>
<p>DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改，通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。</p>
</blockquote>
<p>百度百科上的解释已经很明白了，事实上就是路由器对用户发送的<code>dns请求包</code>做出了<code>假传圣旨</code>的举措（本来它只是个传话的公公）</p>
<h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><blockquote>
<p>DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。</p>
</blockquote>
<p>DNS劫持症状：在某些地区的用户在成功连接宽带后，首次打开任何页面都指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。<br>　　<br>校园网的实现方式应该也算<code>dns挟持</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="DNS劫持-1"><a href="#DNS劫持-1" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>就是指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。范例，网通、电信、铁通的某些用户有时候会发现自己打算访问一个地址，却被转向了各种推送广告等网站，这就是DNS劫持。</p>
<h3 id="DNS污染-1"><a href="#DNS污染-1" class="headerlink" title="DNS污染"></a>DNS污染</h3><p>指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。范例，访问Youtube、Facebook之类网站等出现的状况。</p>
<h1 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h1><h2 id="应对DNS劫持"><a href="#应对DNS劫持" class="headerlink" title="应对DNS劫持"></a>应对DNS劫持</h2><p>可以采用使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）</p>
<h2 id="应对DNS污染"><a href="#应对DNS污染" class="headerlink" title="应对DNS污染"></a>应对DNS污染</h2><p>对于DNS污染，可以说，个人用户很难单单靠设置解决，通常可以使用VPN或者域名远程解析的方法解决，但这大多需要购买付费的VPN或SSH等，也可以通过修改Hosts的方法，手动设置域名正确的IP地址。</p>
<h2 id="本次问题的解决"><a href="#本次问题的解决" class="headerlink" title="本次问题的解决"></a>本次问题的解决</h2><p>单从形式上来看，本次事故更像是DNS污染，因为并不是指向了错误的网站，而是资源加载不出来，但是最后通过修改DNS的方法也成功地解决了这个问题，我的猜测是dns劫持了之后单纯返回了错误的ip。不过更大的疑点是：只有我们宿舍出现了这种情况！（我跑到对面宿舍去借同学的电脑登录我之前登不上的网站发现都没问题…）有种不对的感觉Orz</p>
]]></content>
      <categories>
        <category>技术细节</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>开始记录自己和生活...</title>
    <url>/2017/10/09/%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E8%87%AA%E5%B7%B1%E5%92%8C%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<blockquote>
<h1 id="开通博客的缘由"><a href="#开通博客的缘由" class="headerlink" title="开通博客的缘由"></a>开通博客的缘由</h1><p>大四了，突然发现周围的同学都或多或少带着这样或者那样的光环，反过来看看自己，似乎没有什么值得骄傲的地方。找了个时间专门想了想，自己原来大一大二的时候自己因为怯于自己能力有限，并没有参加各式各样的比赛，相反是将时间大量花费在了看书，练字，画画等系列杂篇上，更为致命的是，以前的那些爱好虽然随着时间和热情的流逝不断地舍弃了，但是心中反而留下了自己很难专注于某件事情的刻板印象。虽然这件事不知道有没有高中时期老师教诲的“遇到难题果断放弃，先做会做的题目”的影响，但事实就是如此，现在的我因为原来大一大二时尝试过太多事情但都半途而废，想要开始做什么事情一旦遇到什么困难就会产生放弃的想法（尤其是在配环境时…）</p>
</blockquote>
<a id="more"></a>
<p>当然了，前面都是一些很丧的话，事情也有积极的一面:我发现自己在编程时还是很专注的，而且自己在前端方向非常感兴趣。可惜的是编程能力只是相对于班上的同学相对优秀，但倘若放在社会上的话根本不值一提。当然没有谁的能力是与生俱来的，但是我同样发现一个令我沮丧的事实，虽然编程时非常投入，也非常享受编程的状态，但是始终缺少自发学习编程的动力。就当我觉得未来漆黑一片时，突然想到了写博客输出的方法。事实上我自己平时也有输出（大三下有所懈怠），不过原来一直是记录在onenote上，只能“内部消化”。以博客的形式来进行输出我觉得有几个优点</p>
<ol>
<li>公开平台，尽管可能没人看，但是绝对有莫名的督促作用</li>
<li>可以锻炼markdown写作的基本功</li>
<li>可以以比较完善的方式系统地整理自己学习的知识和完善自己</li>
</ol>
<p>事实上，我同样也非常享受用一个平台全方面地展示自己，在这里我希望不仅是在编程，同样在读书，喜欢的动画，人生心得等系列方面都能慢慢积累，希望自己能坚持下去</p>
<h1 id="曾经我的生活状态"><a href="#曾经我的生活状态" class="headerlink" title="曾经我的生活状态"></a>曾经我的生活状态</h1><p>虽然暑假拿了夏令营的资格，也和研究生的老师联系好了，但是由于自己的不努力，没有拿到保研资格，也就是说摆在我面前的只有考研这一条路，但是到目前为止，我的考研说实话准备得还不是太好，这一点在我还有闲情来写博客就能看出来。还是老规矩，晚上到操场上反思一下，发现自己根本没有所谓的理想的生活，没有目标也就没有动力，中间还很有一段时间处于时间空余但是又不知道做什么的迷茫状态。老实说，就算是现在我的心中还是有点乱，对未来的大概构想就是考研-帮老师做事-研究生阶段巩固自身技能。现在终于有了博客的帮助，希望它能帮我走得更远。</p>
<h1 id="激励我的大大"><a href="#激励我的大大" class="headerlink" title="激励我的大大"></a>激励我的大大</h1><ol>
<li><a href="http://zhangwenli.com/" target="_blank" rel="noopener">羡辙</a></li>
<li><a href="http://wdxtub.com/1997/09/11/booklist-page/" target="_blank" rel="noopener">小土刀</a></li>
</ol>
<p>初次了解羡辙是在知乎上搜索百度前端学院的task发现有个人给了一个nice的作品，后来又是一次偶然的机会，我正在跟着老师做事，我负责百度echarts的部分，偶然发现了百度前端团队也有她，于是从echarts跟到github和微博，毅然决然地决定成为羡辙老师的粉丝。原因一方面当然是因为人长得漂亮（大雾），其实主要原因是我当时无（ba）聊（gua）翻了很多她的微博，发现原来她的生活轨迹和爱好和我很相似，都喜欢看书和编程，当然她比我厉害很多（主要是能付诸实践和看书能看进去吧）其实大大在编程圈子里也是个很普通的人，但是既然作为和我的爱好重叠度极高且目前已经有较为稳定工作（BAT诶，虽然百度已经没落了，但是也算很强势的互联网公司了），自然是要成为我心目中的标杆啦</p>
<p>小土刀是近期才了解到的，在搜索hexo相关配置问题时偶然发现了这个人的博客，顺手点进去看了看，哟发现大家的兴趣点也都很相似，说实话我最开始点到他的读书计划中心中是有点不屑的，因为他书单里的大多数书也是我的书单的部分（包括编程部分和科普类书部分），很不幸我的书单部分还没怎么开荒，但是后来在知乎里看见了对这个人的主观和客观的评价，发现他还是愿意把自己想做的事给很好地执行的。而这正是我所缺乏的能力，而且大大在自己的博客上全方面展示自己兴趣（包括动漫和武侠小说）让我觉得这就是我想要的生活，知道自己要做什么，并且不断地为这个方向努力</p>
<h1 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h1><p>这两天终于折腾好了博客，配环境总是最累人的事。原先是计划采用<code>jekyll</code>，光是ruby的配置就花了我一晚上，没办法电脑之前brew出了问题，配置ruby之前还被brew折腾了好久，后来还是觉得<code>hexo</code>简单，事实上应该两者差不多，我是觉得hexo的next我比较喜欢，可以拿来直接用，所以跟着教程把hexo搞好了，事实证明<strong><em>一件事做的时候越困难，做完的幸福感越高</em></strong>，配置的过程就不发博客了，因为类似的教程很多。最后感叹一句：</p>
<blockquote>
<p>有困难，上stackoverflow!</p>
</blockquote>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这两天风风火火地搞博客，不知道自己这次还能不能坚持下来，因为考研的缘故，自己这下半年肯定不会很勤快， 如果这次还是不能坚持下来的话…</p>
]]></content>
      <categories>
        <category>随想</category>
      </categories>
  </entry>
  <entry>
    <title>自定义vue-cli脚手架</title>
    <url>/2019/03/25/%E8%87%AA%E5%AE%9A%E4%B9%89vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<blockquote>
<p>因为最近写了很多的vue小工程练手，但是越来越发现vuecli的webpack模板不够用了，每次重新构建的时候都需要花很多心思，花了一天的时间来研究和使用vuecli的自定义构建，非常好用</p>
</blockquote>
<a id="more"></a>
<h1 id="Fork一份标准库"><a href="#Fork一份标准库" class="headerlink" title="Fork一份标准库"></a>Fork一份标准库</h1><p>去<a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="noopener">vue-webpack模板</a>的标准库下fork一份，并且创建一份自己的分支</p>
<h1 id="在本地进行修改"><a href="#在本地进行修改" class="headerlink" title="在本地进行修改"></a>在本地进行修改</h1><p>将fork的项目clone到本地，进行修改</p>
<p>具体的步骤和解释参考<a href="https://segmentfault.com/a/1190000012074462" target="_blank" rel="noopener">这个文章</a></p>
<p>我只讲一下我做了哪些改动</p>
<h2 id="1-打开config-index-js中的autoOpenBrowser"><a href="#1-打开config-index-js中的autoOpenBrowser" class="headerlink" title="1 打开config/index.js中的autoOpenBrowser"></a>1 打开<code>config/index.js</code>中的autoOpenBrowser</h2><h2 id="2-editorConfig中调整indent-size为4，并且将其风格改为tab"><a href="#2-editorConfig中调整indent-size为4，并且将其风格改为tab" class="headerlink" title="2 .editorConfig中调整indent_size为4，并且将其风格改为tab"></a>2 <code>.editorConfig</code>中调整<code>indent_size</code>为4，并且将其风格改为tab</h2><h2 id="3-增加-vuex版块"><a href="#3-增加-vuex版块" class="headerlink" title="3 增加 vuex版块"></a>3 增加 <code>vuex</code>版块</h2><h2 id="4-增加mock和api版块"><a href="#4-增加mock和api版块" class="headerlink" title="4 增加mock和api版块"></a>4 增加mock和api版块</h2><h2 id="5-增加page版块"><a href="#5-增加page版块" class="headerlink" title="5 增加page版块"></a>5 增加page版块</h2><h2 id="6-增加less"><a href="#6-增加less" class="headerlink" title="6 增加less"></a>6 增加less</h2><h2 id="7-增加common文件夹，并且写了一些公共样式"><a href="#7-增加common文件夹，并且写了一些公共样式" class="headerlink" title="7 增加common文件夹，并且写了一些公共样式"></a>7 增加common文件夹，并且写了一些公共样式</h2><h2 id="8-增加less的全局变量"><a href="#8-增加less的全局变量" class="headerlink" title="8 增加less的全局变量"></a>8 增加less的全局变量</h2><p>参考<a href="https://blog.csdn.net/hani_wen/article/details/81007852" target="_blank" rel="noopener">这篇文章</a></p>
<blockquote>
<p>注意，增加的全部变量只能引用一个less文件，不能在这个文件里引用其他的文件</p>
</blockquote>
]]></content>
      <categories>
        <category>技术细节</category>
      </categories>
  </entry>
  <entry>
    <title>我的编程入门</title>
    <url>/2017/10/10/%E6%88%91%E7%9A%84%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>其实建立这个博客的主要目的也是增加自己在编程方向的动力，那么自然需要有些文章专门用来做开荒的布局，这篇文章记录了我之前总结下来的自己未来应该在编程方面的努力方向（虽然基本没怎么动），希望在未来的日子里我能不断地补充这篇文章里的链接。</p>
</blockquote>
<a id="more"></a>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul>
<li>CSS权威指南（第3版）</li>
<li>CSS3 专业网页开发指南</li>
<li>CSS揭秘</li>
<li><a href="http://less.bootcss.com/" target="_blank" rel="noopener">预处理器</a>的学习</li>
</ul>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul>
<li>JS高级程序设计</li>
<li>蝴蝶书</li>
<li>你不知道的JS</li>
<li>阮一峰老师的《ES6 标准入门》</li>
<li>JS设计模式与开发实践</li>
<li>高性能JS</li>
</ul>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul>
<li>BootStrap</li>
<li>Vue</li>
</ul>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><ul>
<li><a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task" target="_blank" rel="noopener">百度前端学院1</a></li>
<li><a href="https://github.com/baidu-ife/ife/tree/master/2015_summer" target="_blank" rel="noopener">百度前端学院2</a></li>
<li><a href="https://github.com/ruanyf/jstraining" target="_blank" rel="noopener">阮一峰老师的全栈教程</a></li>
<li>参加2018年的<code>百度前端学院</code></li>
</ul>
<h2 id="有意思的资料"><a href="#有意思的资料" class="headerlink" title="有意思的资料"></a>有意思的资料</h2><p><a href="https://daisyhawen.gitbooks.io/web-practice-book/content/2_js/05_ajax/01.html" target="_blank" rel="noopener">一个网友自己整理的前端学习知识</a></p>
<h1 id="通用知识"><a href="#通用知识" class="headerlink" title="通用知识"></a>通用知识</h1><blockquote>
<p>注：属于比较杂碎的知识，不系统但很重要</p>
</blockquote>
<ul>
<li>Git（心中的痛，一直在用，一直不精）</li>
<li>数据库（还没有正儿八经地用过，项目接触多了应该就还好）</li>
<li>webGIS</li>
<li>three.js(算是基础比较牢靠，但需要项目的磨练)</li>
<li>spacemacs(非常好看的emacs主题，但是emacs真**难用)</li>
</ul>
<h1 id="计算机知识"><a href="#计算机知识" class="headerlink" title="计算机知识"></a>计算机知识</h1><h2 id="计算机通用知识"><a href="#计算机通用知识" class="headerlink" title="计算机通用知识"></a>计算机通用知识</h2><ul>
<li>SICP（不说了，神书，大二时看完了前两章，后来就没动过了…）</li>
<li><a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/Draft/index.html" target="_blank" rel="noopener">计算机程序设计</a></li>
<li><a href="https://cn.udacity.com/course/design-of-computer-programs--cs212" target="_blank" rel="noopener">计算机程序设计中文</a></li>
<li><a href="https://github.com/DeathKing/Learning-SICP/" target="_blank" rel="noopener">SICP中文教学视频</a></li>
<li><a href="http://composingprograms.com/" target="_blank" rel="noopener">一个小的导论</a></li>
<li><a href="http://sicp.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">SICP习题集</a></li>
</ul>
<h2 id="开始一些小项目"><a href="#开始一些小项目" class="headerlink" title="开始一些小项目"></a>开始一些小项目</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/alchemelon" target="_blank" rel="noopener">麻瓜炼金所</a></li>
<li><a href="https://book.douban.com/subject/1998341/" target="_blank" rel="noopener">计算机系统要素</a></li>
</ul>
<h2 id="计算机系统基础"><a href="#计算机系统基础" class="headerlink" title="计算机系统基础"></a>计算机系统基础</h2><ul>
<li><a href="http://csapp.cs.cmu.edu/" target="_blank" rel="noopener">深入理解j计算机系统</a></li>
<li><a href="https://book.douban.com/subject/1139336/" target="_blank" rel="noopener">c语言程序设计</a></li>
</ul>
<h2 id="数据结构和算法导论"><a href="#数据结构和算法导论" class="headerlink" title="数据结构和算法导论"></a>数据结构和算法导论</h2><ul>
<li>算法导论</li>
<li><a href="https://book.douban.com/subject/1139426/" target="_blank" rel="noopener">数据结构和算法分析</a></li>
<li><a href="http://open.163.com/special/opencourse/algorithms.html" target="_blank" rel="noopener">MIT算法导论</a></li>
<li><a href="https://book.douban.com/subject/3227098/" target="_blank" rel="noopener">编程珠玑</a></li>
<li><a href="https://book.douban.com/subject/1173548/" target="_blank" rel="noopener">程序设计实践</a></li>
</ul>
<h2 id="编程语言基础"><a href="#编程语言基础" class="headerlink" title="编程语言基础"></a>编程语言基础</h2><ul>
<li><a href="https://book.douban.com/subject/2152385/" target="_blank" rel="noopener">程序设计语言-实践之路</a></li>
<li><a href="https://www.coursera.org/learn/programming-languages" target="_blank" rel="noopener">程序设计语言公开课</a></li>
<li><a href="https://cn.udacity.com/course/programming-languages--cs262" target="_blank" rel="noopener">构建一个浏览器的实践</a></li>
<li><a href="http://inst.eecs.berkeley.edu/~cs61a/fa13/proj/scheme/scheme.html" target="_blank" rel="noopener">python实现scheme的解释器</a></li>
</ul>
<h2 id="书籍阅读"><a href="#书籍阅读" class="headerlink" title="书籍阅读"></a>书籍阅读</h2><ul>
<li>代码大全</li>
<li>程序员修炼之道</li>
</ul>
<blockquote>
<p>估计我能把前端的部分搞好就已经很不容易了，接下来的部分以后再慢慢学吧</p>
</blockquote>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计之路</title>
    <url>/2017/11/22/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<blockquote>
<p>这段时间做了一些项目，深刻认识到自己设计功底的缺乏。这里列一些暂时会用到的设计资源，以后有时间的话要把设计这一块专门整理一下的。</p>
</blockquote>
<a id="more"></a>
<h1 id="前端页面设计"><a href="#前端页面设计" class="headerlink" title="前端页面设计"></a>前端页面设计</h1><h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><p>这个不多说，远近闻名的前端框架。我也是最近才接触的，接触了才发现其功能之强大</p>
<h2 id="Flat-UI"><a href="#Flat-UI" class="headerlink" title="Flat UI"></a>Flat UI</h2><p><a href="http://www.bootcss.com/p/flat-ui/" target="_blank" rel="noopener">官网</a>。配色非常好看，可惜收费，所以只能拿来借鉴…</p>
<p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1511362697288.png" alt></p>
<p><a href="http://flatuicolors.com/" target="_blank" rel="noopener">Flat UI 配色</a>，这个链接也很重要，它提供了一些web安全色，都是非常舒服的颜色，可以大胆用。使用起来也很方便，网站里有copy的按钮，选好直接粘贴即可。</p>
<h1 id="符号设计"><a href="#符号设计" class="headerlink" title="符号设计"></a>符号设计</h1><h2 id="阿里矢量图标库"><a href="#阿里矢量图标库" class="headerlink" title="阿里矢量图标库"></a>阿里矢量图标库</h2><p><a href="http://iconfont.cn/home/index?spm=a313x.7781069.1998910419.2" target="_blank" rel="noopener">官网</a><br><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1511362404493.png" alt></p>
<p>惯性做法是在官网上选好图标，下载下来，然后放在本地或者是存在图床里供html使用</p>
<h2 id="Font-awesome"><a href="#Font-awesome" class="headerlink" title="Font-awesome"></a>Font-awesome</h2><p>我最开始是在个性化这个博客时接触到的，但是之前一个项目没有机会使用。这次这个webGIS的课程设计终于有机会尝试一下了，果然…完爆之前一个方法，非常的方便，可定制性也很高，可以满足99%的设计需求</p>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>超实用的文档管理工具DASH</title>
    <url>/2019/10/16/%E8%B6%85%E5%AE%9E%E7%94%A8%E7%9A%84%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7DASH/</url>
    <content><![CDATA[<p>一般人管理文档的方式可能是需要的时候就去查，更仔细一点的可能是在chrome建个书签文件夹专门用来整理遇到的api文档网站，那么有没有更为可靠的软件可以帮我们做到这一点呢?</p>
<a id="more"></a>
<p><a href="https://kapeli.com/dash" target="_blank" rel="noopener">DASH</a></p>
<p>Dash is an API Documentation Browser and Code Snippet Manager. Dash stores snippets of code and instantly searches offline documentation sets for 200+ APIs, 100+ cheat sheets and more. You can even generate your own docsets or request docsets to be included.</p>
<h1 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h1><h3 id="1-海量文档"><a href="#1-海量文档" class="headerlink" title="1. 海量文档"></a>1. 海量文档</h3><p>DASH上有海量的文档，几乎包含了所以你可能接触到的语言或者工具</p>
<h3 id="2-文档可离线"><a href="#2-文档可离线" class="headerlink" title="2. 文档可离线"></a>2. 文档可离线</h3><p>我们可以将文档下载下来，这样离线也是可以查询的</p>
<h3 id="3-内置google和Stackoverflow"><a href="#3-内置google和Stackoverflow" class="headerlink" title="3. 内置google和Stackoverflow"></a>3. 内置google和Stackoverflow</h3><p>在搜索api的同时也会自行搜索stackoverflow上的相关问题提供给你，非常方便</p>
<h3 id="4-支持自定义snippet"><a href="#4-支持自定义snippet" class="headerlink" title="4. 支持自定义snippet"></a>4. 支持自定义snippet</h3><p>有了它，你就可以有了一个无限量（只要你电脑内存空间够）的snippet管理平台，并且支持高亮，缩紧，搜索，用起来非常非常方便.而且snippet还支持按标签分类，真的谁用谁知道</p>
<h3 id="5-与其他平台的集成"><a href="#5-与其他平台的集成" class="headerlink" title="5. 与其他平台的集成"></a>5. 与其他平台的集成</h3><p>DASH可以和很多很多平台集成，这里举我最常用的两个</p>
<h4 id="5-1-Alfred"><a href="#5-1-Alfred" class="headerlink" title="5.1 Alfred"></a>5.1 Alfred</h4><p>直接 dash + 关键字即可</p>
<h4 id="5-2-VSC"><a href="#5-2-VSC" class="headerlink" title="5.2 VSC"></a>5.2 VSC</h4><p>首先在插件商店搜索DASH，下载对应插件，然后在代码页面选中单词，输入control+h，即可打开dash并且在dash中搜索响应api</p>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><p>dash还有很多很多功能，总的来说是一个非常高效的提高开发体验的工具，极其推荐使用</p>
]]></content>
      <categories>
        <category>技术细节</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2018/09/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>设计模式始终是一个巨大的话题，总是要涉及，干脆写一篇博客来进行总结那些常见的设计模式</p>
</blockquote>
<a id="more"></a>
<h1 id="构建函数模式"><a href="#构建函数模式" class="headerlink" title="构建函数模式"></a>构建函数模式</h1><blockquote>
<p>在es6中，这种模式和原型模式统一了，都是很好的设计模式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, gender, score) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.gender = gender;</span><br><span class="line">      <span class="keyword">this</span>.score = score;</span><br><span class="line">      <span class="keyword">this</span>.quality = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sumScore() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.score + <span class="keyword">this</span>.quality;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> whh = <span class="keyword">new</span> Student(<span class="string">'王花花'</span>, <span class="string">'男'</span>, <span class="number">89</span>);</span><br><span class="line">  <span class="keyword">var</span> lsd = <span class="keyword">new</span> Student(<span class="string">'李拴蛋'</span>, <span class="string">'女'</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  whh.score = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(whh.name, whh.sumScore())</span><br><span class="line">  <span class="built_in">console</span>.log(lsd.name, lsd.sumScore())</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, gender, score) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.gender = gender;</span><br><span class="line">      <span class="keyword">this</span>.score = score;</span><br><span class="line">      <span class="keyword">this</span>.quality = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.mount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mount() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="构建者模式"><a href="#构建者模式" class="headerlink" title="构建者模式"></a>构建者模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">StudentBuilder</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>() &#123;</span><br><span class="line">     <span class="keyword">this</span>.student = <span class="keyword">new</span> Student();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   setName(name) &#123;</span><br><span class="line">     <span class="keyword">this</span>.student.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   setGender(gender) &#123;</span><br><span class="line">     <span class="keyword">if</span> (gender != <span class="string">'男'</span> &amp;&amp; gender != <span class="string">'女'</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="string">'好玩不'</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">this</span>.student.gender = gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   setHairLength(hairLength) &#123;</span><br><span class="line">     <span class="keyword">if</span> (</span><br><span class="line">       (<span class="keyword">this</span>.student.gender == <span class="string">'男'</span> &amp;&amp; hairLength &gt; <span class="number">1</span>) ||</span><br><span class="line">       (<span class="keyword">this</span>.student.gender == <span class="string">'女'</span> &amp;&amp; hairLength &gt; <span class="number">25</span>)</span><br><span class="line">     ) <span class="keyword">throw</span> <span class="string">'回去剪头'</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">this</span>.student.hairLength = hairLength;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   build() &#123;</span><br><span class="line">     studentCount++;</span><br><span class="line">     <span class="built_in">console</span>.log(studentCount);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.student;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> builder = <span class="keyword">new</span> StudentBuilder();</span><br><span class="line"> builder.setName(<span class="string">'王花花'</span>);</span><br><span class="line"> builder.setGender(<span class="string">'男'</span>);</span><br><span class="line"> builder.setHairLength(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">const</span> whh = builder.build();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> builder2 = <span class="keyword">new</span> StudentBuilder();</span><br><span class="line"> builder2.setName(<span class="string">'李拴蛋'</span>);</span><br><span class="line"> builder2.setGender(<span class="string">'女'</span>);</span><br><span class="line"> builder2.setHairLength(<span class="number">20</span>);</span><br><span class="line"> <span class="keyword">const</span> lsd = builder2.build();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(lsd);</span><br></pre></td></tr></table></figure>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><blockquote>
<p>工厂模式的特点就是使用<strong>函数</strong>来封装特定接口的细节.它虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, subjects) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果是文科生：['政治', '历史', '地理']</span></span><br><span class="line">      <span class="comment">// 如果是文科生：['数学', '物理', '化学']</span></span><br><span class="line">      <span class="keyword">this</span>.subjects = subjects;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">factory</span>(<span class="params">name, type</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'文科'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, [<span class="string">'政治'</span>, <span class="string">'历史'</span>, <span class="string">'地理'</span>])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'理科'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, [<span class="string">'数学'</span>, <span class="string">'物理'</span>, <span class="string">'化学'</span>])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'体育'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, [<span class="string">'长跑'</span>, <span class="string">'...'</span>])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'没有这个专业，别瞎填'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> whh = factory(<span class="string">'王花花'</span>, <span class="string">'文科'</span>);</span><br><span class="line">  <span class="keyword">const</span> lsd = factory(<span class="string">'李拴蛋'</span>, <span class="string">'理科'</span>);</span><br><span class="line">  <span class="keyword">const</span> zks = factory(<span class="string">'赵可爽'</span>, <span class="string">'体育'</span>);</span><br><span class="line">  <span class="keyword">const</span> lbb = factory(<span class="string">'刘备备'</span>, <span class="string">'撒盐'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(whh);</span><br><span class="line">  <span class="built_in">console</span>.log(lsd);</span><br><span class="line">  <span class="built_in">console</span>.log(zks);</span><br></pre></td></tr></table></figure>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote>
<p>单例模式最突出的特点就是这个类只有一个实例，并且提供一个全局访问他的接口  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="comment">// 如果不是第一次new（instance肯定是存在的）</span></span><br><span class="line">    <span class="keyword">if</span> (Resource.instance)</span><br><span class="line">      <span class="keyword">return</span> Resource.instance;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 否则（instance不存在）</span></span><br><span class="line">      <span class="comment">// 组装新对象</span></span><br><span class="line">      <span class="keyword">this</span>.balance = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将其存到Resource机器上</span></span><br><span class="line">      Resource.instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = <span class="keyword">new</span> Resource();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'r:'</span>, r);</span><br><span class="line">r.balance = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'r:'</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r2 = <span class="keyword">new</span> Resource();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'r2:'</span>, r2);</span><br><span class="line"></span><br><span class="line">r.balance = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'r2:'</span>, r2);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>(转)js闭包问题解决</title>
    <url>/2018/07/05/%E8%BD%AC-js%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>最近又碰到了js的闭包问题，感觉自己的基础还不扎实…在网上找到了一个文章已经把解决方法总结得很好了，直接搬运一下，之后再加点自己的东西<br><a id="more"></a></p>
<h1 id="JS中for循环里面的闭包问题的原因及解决办法"><a href="#JS中for循环里面的闭包问题的原因及解决办法" class="headerlink" title="JS中for循环里面的闭包问题的原因及解决办法"></a>JS中for循环里面的闭包问题的原因及解决办法</h1><p>我们先看一个正常的for循环，普通函数里面有一个for循环，for循环结束后最终返回结果数组</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        arr[i] = i;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">alert(box()) <span class="comment">//正常情况不需要闭包，就可以达到预期效果</span></span><br><span class="line">			   <span class="comment">//输出结果为一个数组 0,1,2,3,4</span></span><br></pre></td></tr></table></figure>
<p>有时我们需要在for循环里面添加一个匿名函数来实现更多功能，看下面代码</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环里面包含闭包函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        arr[i] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;                            <span class="comment">//由于这个闭包的关系，他是循环完毕之后才返回，最终结果是4++是5</span></span><br><span class="line">        &#125;                                        <span class="comment">//这个匿名函数里面根本没有i这个变量，所以匿名函数会从父级函数中去找i，</span></span><br><span class="line">    &#125;                                            <span class="comment">//当找到这个i的时候，for循环已经循环完毕了，所以最终会返回5</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//alert(box());                                    //执行5次匿名函数本身</span></span><br><span class="line"><span class="comment">//alert(box()[1]);　　　　　　　　　　　　　　　　　　　//执行第2个匿名函数本身</span></span><br><span class="line"><span class="comment">//alert(box().length);                            //最终返回的是一个数组，数组的长度为5</span></span><br><span class="line">alert(box()[<span class="number">0</span>]());                                <span class="comment">//数组中的第一个数返回的是5，这是为什么？</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码就形成了一个闭包：</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见的方式，就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量。</p>
</blockquote>
<p>在for循环里面的匿名函数执行 return i 语句的时候，由于匿名函数里面没有i这个变量，所以这个i他要从父级函数中寻找i，而父级函数中的i在for循环中，当找到这个i的时候，是for循环完毕的i，也就是5，所以这个box得到的是一个数组[5,5,5,5,5]。</p>
<h1 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h1><p>在看解决方案一之前，我们先看一下匿名函数的自我执行：</p>
<p>匿名函数自我执行的写法是，在函数体外面加一对圆括号，形成一个表达式，在圆括号后面再加一个圆括号，里面可传入参数。</p>
<p>例如下代码：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">function</span>()&#123;</span><br><span class="line">    alert(<span class="name">'lee'</span>)<span class="comment">;                //匿名函数自我执行(匿名函数)()</span></span><br><span class="line">&#125;)()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>我们再来看解决方案1：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        arr[i] = (<span class="function"><span class="keyword">function</span><span class="params">(num)</span></span>&#123;                    <span class="comment">//自我执行，并传参(将匿名函数形成一个表达式)(传递一个参数)</span></span><br><span class="line">            <span class="keyword">return</span> num;                            <span class="comment">//这里的num写什么都可以                    </span></span><br><span class="line">        &#125;)(i);                                    <span class="comment">//这时候这个括号里面的i和上面arr[i]的值是一样的都是取自for循环里面的i                            </span></span><br><span class="line">    &#125;                                            </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//alert(box());                                </span></span><br><span class="line"><span class="comment">//alert(box()[1]);</span></span><br><span class="line"><span class="comment">//alert(box().length);                            </span></span><br><span class="line">alert(box()[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>通过给匿名函数传参，而传递的这个参数i是每次执行for循环里面的i，每次传递的参数i的值都不一样，匿名函数里面的num接收传递的参数i，所以box()最终输出结果为[0,1,2,3,4]</p>
<h1 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h1><p>这种方案的原理就是在匿名函数1里面再写入一个匿名函数2，这个匿名函数2需要的num值会在他的父级函数匿名函数1里面去寻找，而匿名函数1里面的num值就是传入的这个参数i，和上面例子中的i是一样的，</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">function box()&#123;</span><br><span class="line"><span class="code">    var arr = [];</span></span><br><span class="line"><span class="code">    for(var i=0;i&lt;5;i++)&#123;</span></span><br><span class="line"><span class="code">        arr[i] = (function(num)&#123;</span></span><br><span class="line"><span class="code">        //num在这里                                    //原理和上面一种方法一样的，所以可以实现闭包                    </span></span><br><span class="line"><span class="code">            return function()&#123;                        //在这个闭包里面再写一个匿名函数</span></span><br><span class="line"><span class="code">                return num;                            </span></span><br><span class="line"><span class="code">            &#125;;                                                                </span></span><br><span class="line"><span class="code">        &#125;)(i)                                                </span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    return arr;</span></span><br><span class="line">&#125;</span><br><span class="line">//alert(box());                                </span><br><span class="line">//alert(box()[1]);</span><br><span class="line">//alert(box().length);</span><br><span class="line">var b = box();                            </span><br><span class="line">alert(b[<span class="string">0</span>](<span class="link"></span>));</span><br><span class="line">alert(box()[<span class="string">0</span>](<span class="link"></span>));</span><br></pre></td></tr></table></figure>
<p>box()最终返回结果[0,1,2,3,4],</p>
<h1 id="解决方案3"><a href="#解决方案3" class="headerlink" title="解决方案3"></a>解决方案3</h1><p>如果将一个匿名函数自我执行的时候赋值给一个变量，那么这个匿名函数中的圆括号的可以去掉的，看下面代码，</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tip = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;         <span class="comment">//这样把匿名函数自我执行的时候赋值给一个变量，那么圆括号是可以去掉的</span></span><br><span class="line">    alert(<span class="string">'lee'</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>利用匿名函数的这一特点，我们可以将解决方案1中的代码改进一下：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        arr[i] = <span class="function"><span class="keyword">function</span><span class="params">(num)</span></span>&#123;                </span><br><span class="line">            <span class="keyword">return</span> num;                            </span><br><span class="line">        &#125;(i);                                </span><br><span class="line">    &#125;                                            </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//alert(box());                                </span></span><br><span class="line"><span class="comment">//alert(box()[1]);</span></span><br><span class="line"><span class="comment">//alert(box().length);                            </span></span><br><span class="line">alert(box()[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
<h1 id="解决方案4"><a href="#解决方案4" class="headerlink" title="解决方案4"></a>解决方案4</h1><p><img src="http://oy2kvpd7z.bkt.clouddn.com/md/1536194960944.png" alt></p>
<p>匿名函数在执行的时候他本身就传递给了一个变量arr[i]，所以匿名函数的圆括号是可以去掉的。</p>
<p>以上就是几种解决for循环中闭包的办法，当然还有更多办法，大家可自行google或者bing其他资料来加深印象(百度是基本上搜不到什么有用的文章的)。</p>
]]></content>
      <categories>
        <category>技术细节</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>近期开荒计划</title>
    <url>/2017/10/18/%E8%BF%91%E6%9C%9F%E5%BC%80%E8%8D%92%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<blockquote>
<ol>
<li>git</li>
<li>数据库</li>
<li>sass</li>
<li>dash</li>
<li>alfred</li>
<li>框架</li>
<li>配置一款顺手的编辑器</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="近期开荒计划"><a href="#近期开荒计划" class="headerlink" title="近期开荒计划"></a>近期开荒计划</h1><blockquote>
<p>因为webstorm太过笨重，于是想着找些轻量级的替代品。配置环境这种事情最是消磨时间也最能打击人，我花了一下午加半晚上的时间尝试了现行的较优的选择<code>atom</code>和<code>vsc</code>，事实证明，我可能真的比较蠢，也可能是缺乏耐心，没有一项我觉得比较好用，编辑器的事还是之后再说把</p>
</blockquote>
<h1 id="我对编辑器的要求"><a href="#我对编辑器的要求" class="headerlink" title="我对编辑器的要求"></a>我对编辑器的要求</h1><ul>
<li>配色好看（atom的配色是我目前看过最好看的）</li>
<li>对前端支持较好（atom比较优异）</li>
<li>对markdown支持较好（说实话我两款编辑器的markdown都用过了，还是觉得<code>macdown</code>好用且好看且轻便）</li>
<li>插件下载快速且可配置型高（这个vsc比atom好，atom下载太慢了，而且可配置项少，有的插件官网上都没说明白…）</li>
</ul>
<blockquote>
<p>我对编程应该还是持有兴趣的，但是感觉自己耐心不足且能力极其有限，唉，还是只能走一步看一步了</p>
</blockquote>
]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
  </entry>
  <entry>
    <title>闲谈&amp;近期总结</title>
    <url>/2018/07/20/%E9%97%B2%E8%B0%88-%E8%BF%91%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>最近有一些事觉得很麻烦把，晚上去操场整理了一下思路，现在大概清晰一点了，写下来记录一下</p>
<a id="more"></a>
<h1 id="1-应该保持的习惯"><a href="#1-应该保持的习惯" class="headerlink" title="1.应该保持的习惯"></a>1.应该保持的习惯</h1><h2 id="思考的时候去操场散步"><a href="#思考的时候去操场散步" class="headerlink" title="思考的时候去操场散步"></a>思考的时候去操场散步</h2><p>已经很久没有去操场单独只是为了思考问题了，但事实证明这真的很有作用。在图书馆或者机房都无法完全沉浸式地去思考问题，但是操场可以，戴上bose就能体会到与世隔绝的感觉，真的对思考帮助很大</p>
<h1 id="2-关于爱情"><a href="#2-关于爱情" class="headerlink" title="2.关于爱情"></a>2.关于爱情</h1><p>晚上跟两个同学聊天，收货真的很大。但是后来仔细想了一下，问题还是远比我想象的复杂，这无关技巧，只在于恋爱本身，我想地越深入就会越觉得对它的本质感到好奇</p>
<p>当我在想到大学恋爱实际上不会很长久的时候，莫名地感到了一丝恐惧，进而突然想到，喜欢一个人究竟以意味着什么呢。</p>
<p>问题也许可以更深一步，那就是爱情或者说恋爱，对于一个独立个体来说，究竟意味什么呢？</p>
<p>从生理学的角度上讲无非就是多巴胺和荷尔蒙，但这样未免有失情趣。我以我少的可怜的经验去仔细揣度了一下，一对年轻的男女，相遇相恋，结婚生子，然后轮回。这是正常的较为理想的流程，可是如果是一个人的话，可能唯一的感觉就是孤独无靠吧。那么，为什么恋爱或者爱情已经固化为了人类的一项固有标签呢？繁衍后代的本能当然是一个很好的说辞，但这并不是我想要的答案。对于年轻人来说，恋爱对他们可能意味着新鲜，有趣，性，认同感。细化到生活中（或者说是用功利的眼光看待）可能是想想做的事能有人陪，一起分享开心，一起承担痛苦。</p>
<p>我在自己思考了一番之后打开了知乎，发现知乎现在果然跟我大二时的质量完全不能比了。不过这也算是我为了获取某个答案而采取捷径的恶果。当然后来才发现是自己选题质量不好，”爱情的本质是什么“这个问题下的回答质量普遍偏低，”爱情是什么“相对略好</p>
<p>看完答案之后我有点怅然若失，因为感觉不是自己想要的，突然意识到自己想要问的是”婚姻究竟以为着什么“ ”两个人的结合究竟意味着什么“</p>
<p>不过细想，爱情这种东西，似乎并不应然属于每一个人甚至是已经成家的人，再往深处想，就会开始质疑爱情本身的定义了</p>
<h1 id="3-关于自己"><a href="#3-关于自己" class="headerlink" title="3.关于自己"></a>3.关于自己</h1><p>爱好很杂并不一定是一件坏事，但是在该积累技术能力的时候把时间都浪费在这个上面就会显得很不为自己的未来负责</p>
<p>我决定未来一段时间不玩游戏（饥荒 &amp; 塞尔达）</p>
<p>自己的动力一直不足说到底还是不确信自己究竟未来应该做什么</p>
<p>现在差不多坚定下来了，还是主要做前端</p>
<p>另外，好久没写文章了。以前都是在ulysess上想到什么写什么，但其实这样不太好，因为输出还是最好在一个公共的平台，这样才有交流和获取更多信息的可能性。好久没有写文章&amp;看书的后果就是自己连一些基本的观点都说不利索了</p>
<p>之前翻阅原来的知乎答案的时候发现有时候自己连大二的时候都不如。曾经的自己对很多人文社科类的知识感兴趣，愿意看很多书来试图靠近一点点世界的真向，但是现在有的时候什么都不太想做，这样的自己又回到了原点</p>
<p>作为曾经尝试过很多的我，当然知道一些领域如哲学是很难入门的</p>
<p>已经很久没有体会到纯粹的智识性趣味了</p>
]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>个人成长</tag>
      </tags>
  </entry>
  <entry>
    <title>一键图床指南</title>
    <url>/2017/10/19/%E4%B8%80%E9%94%AE%E5%9B%BE%E5%BA%8A%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>写<code>markdown</code>的过程是非常爽的，但是有一点始终是我心中的一根刺，那就是图床。博客理论上来说是可以把图片存在本地然后调用相对路径的，但是这么做一方面加重了上传的负担，一方面加重了网站的负担。比较推荐的方式是<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BA%8A/10721348?fr=aladdin" target="_blank" rel="noopener">图床</a>。但是图床虽然副作用小，但当一篇博客里需要引用的图片变多时，图床繁琐的步骤往往会成为你发疯的诱因.我在尝试了一个晚上之后终于解决了这个问题</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="传统图床步骤"><a href="#传统图床步骤" class="headerlink" title="传统图床步骤"></a>传统图床步骤</h2><p>一般来说，正常途径下我们写博客使用图床需要经过以下几个步骤</p>
<ul>
<li>使用快捷键截图</li>
<li>打开<a href="https://www.qiniu.com/?hmsr=biaoti&amp;hmpl=pinzhuan&amp;hmcu=biaoti&amp;hmkw=&amp;hmci=" target="_blank" rel="noopener">七牛云存储</a></li>
<li>上传本地图片</li>
<li>复制外链</li>
</ul>
<p>当然你可以说我可以开始写博客时把七牛打开，然后需要时往里面塞就好了。事实告诉我，当我在网上看见截完图之后立刻上传并且生成外链一气呵成时，前面的4个固定步骤在我看来就如同原罪一般不可原谅。于是开始了改造之旅…</p>
<blockquote>
<p>首先说明，我在网上找了很多办法，但是很多都不一而終（手残如我…）。本文中会把可能的方法都列出来，但是我尝试失败了的就不细说了，只提我自己做好了的。我自己没有实现不代表方法不可行，理论上来说都是可以的</p>
</blockquote>
<h1 id="可用方法"><a href="#可用方法" class="headerlink" title="可用方法"></a>可用方法</h1><h2 id="系统自带截图的设置"><a href="#系统自带截图的设置" class="headerlink" title="系统自带截图的设置"></a>系统自带截图的设置</h2><p>首先在讲各个方法之前，先把系统给的截图给改一下。默认的设置里<code>command+shitf+4</code>是截图,<code>command+shift+4+control</code>是截图并且存入剪切板，后者对我们来说更为实用，但是更难按，在系统的键盘设置里把前者的默认按键和后者换一下即可</p>
<h2 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h2><p><a href="https://github.com/tiann/markdown-img-upload" target="_blank" rel="noopener">参考链接</a></p>
<p>这个是<a href="https://www.alfredapp.com/" target="_blank" rel="noopener">alfred</a>的特殊技能（alfred的文章我之后会专门写），并且需要购买<code>powerback</code>包。具备了上述条件之后，只需要按照参考链接里的步骤，安装里面的wordflow，配置好七牛的信息，应该就可以运行了。我自己是一切都搞好了，但是实践起来发现不是这回事，总是报网络的错，我估摸着可能是七牛的api改了，但是也没那个闲工夫去琢磨workflow里的东西，遂作罢。</p>
<p>|补充| 后来找到原因了，原来是存储空间是不在华东的缘故，重新建立了一个华东的存储区，并且重新修改了一下配置文件，可以运行了。而且我在另外一个同学的电脑上也查看了效果，并没有它说的分辨率丢失的问题，那么workflow就是目前我非常完美的一个解决方案了，快捷（只需要截图然后粘贴），安全（可以在七牛上管理）。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul>
<li><code>command+shift+4</code>截图</li>
<li>在编辑器里<code>command+control+v</code>粘贴</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这个workflow已经非常强大了，简单易懂，但是还是存在缺陷，那就是粘贴出来之后的是html里的img格式，更让我震惊的是markdown竟然也支持这个格式！（感觉不是markdown支持，应该算是本身markdown就是嵌在html里通过markdown解释器编译成dom元素吧）。作者给出来的理由是retina屏幕上截的图在其他屏幕上非常模糊，通过这个方法能够避免这种问题的出现。我试图修改python文件，让它返回markdown里正常的链接，可以是可以，但是还是有点害怕作者说的问题…另外还有一个小缺点是有一点点的阻塞感…（逼死强迫症）</p>
<blockquote>
<p>用起来很简便，但是我总觉得一个<code>img</code>元素的出现很诡异…</p>
</blockquote>
<h2 id="atom的插件"><a href="#atom的插件" class="headerlink" title="atom的插件"></a>atom的插件</h2><p><a href="http://www.jianshu.com/p/af4d34d39797" target="_blank" rel="noopener">参考链接</a></p>
<p>正好我最近在配置atom，但说实话我是不太想用atom来做markdown的（界面没<code>macdown</code>好看+操作空间太小了）。但是既然这个方法可行那还是姑且尝试一下把，我把里面两个插件都下下来了，但又一次报错，这次是包本身的问题，又是个什么函数找不到了，怒删之。更何况这个解决方案本身就不太好，因为只能解决atom这一个平台的问题。</p>
<h2 id="iPic"><a href="#iPic" class="headerlink" title="iPic"></a>iPic</h2><p><a href="https://toolinbox.net/iPic/" target="_blank" rel="noopener">参考链接</a></p>
<p>这个我最后是配置好了的，但是还是感觉有一个缺陷，那就是只能默认存储在微博上（而且是存储在匿名账户上！）这样一方面感觉是没有安全感，另一方面是觉得日后不好管理，但是付费版需要56元/年…总体来说这个软件总体来说除了安全性之外还是不错的</p>
<h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul>
<li><code>command+shift+4</code>截图</li>
<li><code>command+u</code>上传图片</li>
<li><code>command+v</code>粘贴</li>
</ul>
<h2 id="photocloud"><a href="#photocloud" class="headerlink" title="photocloud"></a>photocloud</h2><p><a href="https://www.v2ex.com/t/318201" target="_blank" rel="noopener">参考链接</a></p>
<p>这个软件需要在appstore官网上下载，看了晚上的宣传，感觉还是不错的，但是当我真正使用时才发现完全不是这回事。首先，截图方式太傻，完全没有本地截图然后自动上传到剪切板那么便捷，其次，七牛云存储！！！我发现按要求配置好了之后，还是会报错<code>incorrect region</code>，网上搜了一下，好像是存储空间应该选华东（默认是华东），要么我换一个存储在华东的空间，要么修改远吗（可是这是一个软件并不能修改…）可是当我修改成华东之后发现还是报了一样的错，服了，遂删之。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后还是两种方法都实现了，<code>ipics</code>真的挺不错的，但是微博链接还是有点不放心。workflows的方法真心强，而且更改了链接之后发现还是非常完美的。workflow虽然好但是那是相对于购买了alfred的powerback的用户来说的，对于没有购买alfred的powerback的人，我的建议还是<code>ipic</code>。<code>photocloud</code>不仅截图不好用，而且七牛设置总是出问题，差评…</p>
]]></content>
      <categories>
        <category>技术细节</category>
      </categories>
  </entry>
  <entry>
    <title>【css布局之position】</title>
    <url>/2018/03/03/%E3%80%90css%E5%B8%83%E5%B1%80%E4%B9%8Bposition%E3%80%91/</url>
    <content><![CDATA[<blockquote>
<p>这段时间在刷百度前端学院，从最基础的task开始刷。好久没有碰css了，一年前做起来轻车熟路的东西，现在竟然要花很久来调试，于是想着干脆写几篇文章来彻底整理一下有关css布局的东西，这一篇从position开始。</p>
</blockquote>
<a id="more"></a>
<h1 id="css中的positon"><a href="#css中的positon" class="headerlink" title="css中的positon"></a>css中的positon</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2>]]></content>
      <categories>
        <category>系统学习</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>《正义从哪里来》读书笔记</title>
    <url>/2017/11/16/%E3%80%8A%E6%AD%A3%E4%B9%89%E4%BB%8E%E5%93%AA%E9%87%8C%E6%9D%A5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>这本书对我来说意义非常重大，一定程度上构建起了我心中的正义及公义体系。后续还衍生了很多文章和思考，这都是后话。我原来做的笔记已经比较完善了，这里直接搬过来。当然还是需要修改的，至少就我目前看来这本书还是非常有价值的，需要反复品读。<br>（这本书真的是干货满满，常读常新）</p>
<p>评分：5分</p>
</blockquote>
<a id="more"></a>
<h1 id="序言：似是而非种种"><a href="#序言：似是而非种种" class="headerlink" title="序言：似是而非种种"></a>序言：似是而非种种</h1><p>美德是不是我们应该追求的东西？答案似乎是不言而喻的。在亚里士多德看来，国家或任何形式的政治社会——终归是为了促进美德而存在的，而不仅仅是简单地使人们共处。那么，看来每个人都会同意，一个国家如果具有更多的美德，总要好过具有较少的美德</p>
<p>亚里士多德认为：正是因为财产私有，人们才可以克制贪欲，从而表现出慷慨慈善的美德，正是因为情欲上的自制，人们才不至于淫乱他人的妻子，如果私有制和传统的婚姻关系不复存在，那么自制和慈善这类美德也会令人惋惜地随之灭亡————为什么亚里士多德反对柏拉图的理想国</p>
<p>这种二元论的论调并不少见——斯多葛学派认为，所谓的黑暗，并不是一个实体，只是光明的缺失罢了</p>
<p>美德的性质到底是什么？是顺应人性（自然主义，主张道德应当以人的自然本性为基础）还是克制人性（人类几乎所有的令人尊敬的特性都不是天性自然发展的结果，而是对天性的成功克服），抑或是顺应和克制的某种比例的组合？</p>
<ul>
<li>东方：“仁”，对父母之爱胜过远亲，对远亲胜过陌生人【顺从本性】</li>
<li>西方：“爱人如己”，爱自己的仇人，使自己对上帝的爱超越于血缘人伦之上【克制本性】</li>
</ul>
<p>东西方的这两种价值体系，在人伦关系的问题上，哪个更抓住了美德的本质呢？中国儒家想必会部分地同意穆勒的看法“克己复礼”。这就很容易使人对美德理解陷入一种混合论：在某些事情上（譬如贪欲，淫欲）应当克制人欲，而在另外一些事情上（譬如父子人伦）则应当顺应人欲。这就意味着 <strong>任何政治哲学与伦理学所应当做出的努力无非都是某种列表的工作，在顺应人与和克制人性这两个栏目里一项项地罗列着五花八门的具体内容，而任何抽象原则都不该在哲人们的考虑之列。也就是说，像亚里士多德那样开列一个“德性表”的工作才是找对了方向</strong></p>
<p><b style="color:orange">于是在关乎正义的一切问题上，我们只能一个个地处理特殊问题，而无力处理一般性的问题</b>    </p>
<p>庄子：人之所以成为人，并非出自于造物主的特殊安排，只不过是一种偶然罢了，没什么值得骄傲的。人和蝴蝶，虫子老鼠没有什么本质的不同——哲学皇帝马克奥勒：死亡不是别的，只是元素的分解，死是合乎本性的，而合乎本性的东西都不是恶</p>
<p>当然，上述的这种对死亡的观点没有错，但是也忽略了很重要的一点：生离死别和疾病的痛苦。如果死亡只是按个按钮就能迅速实现的过程，以上述的观点来看待倒也无妨，但是现实往往复杂得多。</p>
<p>哲学皇帝马克奥勒留写在沉思录里的一段内容：如果一个事物不断变化的过程中元素本身并没有受到任何伤害，为什么一个人竟忧虑所有这些元素的变化和分解呢？因为死是合乎本性的，而合乎本性的东西都不是恶的。</p>
<p>我们在叹服东西方这两位大哲的豁达之余，不妨依照同样的逻辑设想这样一个问题：当你因为一场灾难而倾家荡产的时候，你的钱财本身并没有受到任何损害。你应该以欢乐的心情接受你的钱流到了别人手上这个事实，因为流通聚散本身就是合乎本性的，而我们已经晓得合乎本性的都不是恶的。</p>
<p>这也许会引起我们的疑惑，一个人要丧失何等程度的理智才能接受如此这般的美妙说辞呢？</p>
<p>万事万物的因缘聚合确实称得上是古代智者的一项伟大发现，但由这一项自然科学的认识推广到人生哲学的高度，其强词夺理的荒谬术是显而易见的</p>
<p>但是，人们欣赏并渴慕这种达观的态度，并不会去认真思考这种态度背后的那种貌似合理的解释究竟能有几分能够站得住脚——————这正是人类最经典的认知模式之一，对于社会与文化问题是很有解释力的</p>
<p><code>武侠小说</code>：因为正义在现实世界里屡屡得不到伸张，人们看到的永远都是“杀人放火金腰带，修桥补路无尸骸”，总是有心抗争却总是怯于抗争，于是只有借助武侠的白日梦来对沉浮已久的正义作出替代性的伸张。</p>
<p><strong>武侠小说的兴盛正说明了人们法制意识的淡化，我们总是希冀于侠客从天外飞来主持公道，却不肯希冀于一个完善的法制世界，由法制来伸张正义。</strong></p>
<p>这样说来，西方的侦探小说和中国本土的武侠小说似乎形成了一个鲜明的对照，前者重人权，尚法制，后者不但毫无人权和法制的观念，而且最要不得的————崇尚暴力</p>
<p>但是，美国的那些超级英雄，他拥有者远超常人的非凡本领，有利于常规世界之外，到处行侠仗义，铲恶锄奸，定人生死。值得留意的是，他们之所以断定是非，凭借的是各自的良知，而不是系统的法律知识和规范的法律程序。</p>
<blockquote>
<p>在作者看来，武侠小说并不是一种中国特有的地方性文学，而是一种具有普世意义的”白日梦小说“，其核心阅读趣味不是”行侠“，而是获得一种操纵性的能力，让人体验那种为所欲为的快感以及成功的喜悦。只不过因为伸张正义是人类的一种本能的追去，而且现实社会必不可免的不公永远刺激着人们对正义的渴望，所以”行侠”才是主人公的必修课之一，成为一种如此令人愉悦的阅读体验，却算不得武侠小说的本质特征</p>
</blockquote>
<p>上帝可以说是侠客的终极形式，最高的武功，最好的品格以及完美的侠义精神。侠客会犯错，上帝不会</p>
<p>瞿秋白曾嘲讽武侠小说，称其徒然使人宽慰于“济贫自有飞仙剑，尔等安心做奴才”</p>
<p>如果说沉迷于武侠小说意味着国人法制意识的淡化，那么我们同样看到，对上帝的信仰并不曾昭示着基督教世界也存在着同样的法制意识的淡漠的情形。在上帝脚下做奴才算不得什么丢脸的事情，而且西方社会对“飞仙剑“的渴慕并不必然导致瞿秋白所担忧的“安心做奴才”的可悲结果，至善至公的“最后审判”并不曾使人们放弃了对现实利益的锱铢必较，不曾使人们放弃了对显示正义的一点一滴的尽力伸张。</p>
<p>世道人心永远是真信仰的大敌。“在过去的两千年的宗教创始人中，有许多是反对财产和家庭的，但是只有那些赞成财产和家庭的宗教延续了下来“——他不晓得反对财产和家庭的宗教也完全可以迎合世道人心地转而支持财产和家庭，因为被尊重的不一定等于被遵从的</p>
<p>看上去似乎令人难以置信，《圣经》，尤其是耶稣的登山宝训，并不是什么难读的文字，不像许多佛教经典那样充斥着繁琐艰深的理论思辨，也不需要读者有任何文字学的专业素养，而且其中的故事清晰流畅，训诫简单易懂,信众只需要具备最基本的理性就足以看出训诫条文和实际行为规范之间的反差。</p>
<p>这似乎意味着，逻辑一贯性在人类的思维中是一个何等不受欢迎的角色，而现实的，便利的因素是如何驱使人们以割裂的眼光看待事物。</p>
<p>近些年来，世界上兴起了一个“全球伦理”运动，该运动由德国神学家孔汉思主张，在各个国家掀起了一次又一次的讨论热潮。</p>
<p>提倡全球伦理的出发点是这样：随着当代世界的全球化进程的发展，世界各地在政治，经济，文化上的冲突不但没有随之减少，反而愈演愈恶劣了，想要清楚这些冲突，除非大家都有共同的伦理准则</p>
<p>这个思路看上去是如此的合情合理，以至于就连反对者们也往往把矛头指向它的可行性上，然而在我看来，全球伦理在出发点上就很难站得住脚。</p>
<p>理由就是，<strong>真正影响人们行为方式的并不是什么人人认可的伦理准则，而是每个人之所以浸淫其中的风俗习惯</strong>。即使在同一个教派或者组织内部，所有成员无论在名义上还是在实质上都分享着共同的理想和伦理准则，然而这依然避免不了无休无止的派系分裂，譬如在广义的基督教阵营里，旧教之于新教，其斗争的惨烈程度丝毫不亚于基督教之于异教。几乎在任何一个文化共同体之中。</p>
<p>甚至在同样的风俗习惯下，人与人的纷争仍然不可避免，这实在是天性使然，以至于任何精心而为之的理性设计都会面临捉襟见肘的窘境。无论是孔子的己所不欲还是罗尔斯的无知之幕都在试图以某种抽象的理性原则来解决实际的正义问题，但人们之所以采纳或者不采纳，往往不是因为他们合理不合理，高尚不高尚。</p>
<p>”释楚以为外惧“的故事正是“生于忧患死于安乐”的道理，是一种情形的理性认识</p>
<p>因为，在非理性的层面，“排外”是人类一种根深蒂固的心理机制，以至于人们只要随机分组就会产生“爱国主义”。虽然这样形成的道德情操分析起来会令人感觉相当荒谬，但是作为一种群居动物，这种特质实在可以帮助人类在小群体的原始社群里很好地存活下来</p>
<p>千百万年的演化使我们适宜于原始小群体的群居模式，从而必然在基因上就和文明社会的组织结构不相融洽，但我们又能怎么办呢，毕竟已经退不回“小国寡民”的时代了</p>
<blockquote>
<p>有人的地方就有纷争，不过若非如此，人类也不会形成正义的观念——我们摆不脱本能的欲望和生存的竞争，而正是在这些卑下龌龊之中产生了高尚的道德情操。<strong>正义的应然状态可以被设计成任何样子，但是它的实物状态却只有唯一的一种面貌，即在你争我抢中形成的动态平衡。</strong></p>
</blockquote>
<p>于丹教授的论语系列走红解释了一个相当耐人寻味的问题，即人们总是孤立地而非符合逻辑一贯性地看待事物。人们一方面会欣赏猴子因为不舍不弃最后采到松果的故事，一方面也会扼腕猴子因为同样的不舍不弃而被农民捉到的故事，竟然很少有人意识到这两个故事说的是同一种行为模式</p>
<p>我们很难想象一只一旦被瓶子卡住就会松手逃脱的猴子能够在严寒的饥荒季节死守住最后一枚松果</p>
<p>东野圭吾在《彷徨之刃》简述了一个两名少年轮奸少女致死，但根据相应的法律凶手不会被判太重的刑，死者的父亲对此完全不能接受，并开始了为女儿的复仇之路，其结尾借一位参与案件的警察之口道出了道德上的困惑“警察到底是什么呢？是站在正义的那一边吗？不是，只是逮捕犯了法的人而已。警察并非保护市民，警察要保护的是法律，为了防治法律被破坏，拼了命地东奔西跑，但是法律是绝对正确的吗？如果绝对正确的话，为什么又要频频修改呢？法律并非完善的，为了保护不完善的法律，警察就可以为所欲为吗？践踏他人的内心也无所谓吗？”</p>
<p>在日本的通俗作品中其实很少会表达这样的困惑，似乎在绝大多数的作家看来，谋杀就是谋杀，任何形式，任何理由的谋杀都是应当受到法律制裁的。他们一般不会产生雪莱式的思考“各色人等中的最完全的机器，是被雇佣的暴徒”。</p>
<p>相反，欧美作品反而不会把法律放在至高无上的地位，甚至有时候会出于人情味的考虑简直到了无视法律的地步  </p>
<p>2007年《狙击手》讲述了一个男主在目睹了法律对穷凶极恶的权力者无能为力之后，终于用自己的狙击步枪伸张了正义。美国观众喜欢这样的主题，因为正义终于在法律不及的地方得到了伸张。中国观众似乎也喜欢这样的主题，因为1）正义得到了伸张2）这是发生在外国的故事</p>
<p>尤其耐人寻味的是，亚洲国家的通俗文艺虽然也会表现同样的主题，但总会将其设定为“历史题材”。对私人执法的认同，在亚洲国家一般被表现为过去时，而在欧美国家往往被表现为现在进行时</p>
<blockquote>
<p>那么个人良知究竟应不应该凌驾于法律之上呢？——这个问题并不意味着良知可以无视法律，而仅仅意味着：在人们寻求正义的时候，法律手段理所当然的具有优先权，但是它既不是唯一的手段，也不是最后的手段</p>
</blockquote>
<p>对于这个问题，日本的通俗作品给出的答案往往是否定的。这两种价值观哪一种才是更可求的，或者说更逼近“正义”的呢？对于这个问题的答案，作为旁观者的我们，究竟是可以给出一个直截了当的答复呢，还是只能站在社群主义者的立场，对两种文化传统报以同等程度的尊重呢？</p>
<h1 id="要幸福还是要公正？"><a href="#要幸福还是要公正？" class="headerlink" title="要幸福还是要公正？"></a>要幸福还是要公正？</h1><p>人们如此渴求着正义，而所谓正义只是一种约定俗成的观念，并且总是混沌的，模糊的，屡屡经不起苛刻逻辑的追问，任何建立一套清晰的理论体系的企图都将是徒劳的，之多可以被看作一种动机良好的呼吁罢了</p>
<p>柏拉图记述苏格拉底等人关于正义的一场漫长的辩难,在开场后不久，诡辩派哲人色拉叙霍马思就以令人生厌的口吻提出了一个更加令人生厌的命题“正义不是别的，就是强者的利益“。</p>
<p>所谓强者，色拉叙霍马思把他们等同于国家的统治者，但不见得就是国王，因为“统治各个国家的人有的是独裁者，有的是平民，有的是贵族”。于是，色拉叙霍马思认真地做出了以下的一番推理</p>
<blockquote>
<p>难道不是谁强谁统治吗？每一种统治者都制定对自己有利的法律，平民政府制定民主法律，独裁政府制定独裁法律，以此类推。他们制定了法律告诉大家，凡是对政府有利的，对百姓就是正义的，谁不遵守，他就有违法之罪，又有不正义之名。因此我的意思是，在任何国家，所谓正义就是当时政府的利益。政府当然有权，所以唯一合理的解释就是，不管在什么地方，正义就是强者的利益</p>
</blockquote>
<p>毫无悬念的是，在苏格拉底步步紧逼的反诘下，色拉叙霍马思很快就败下阵来。尽管直到现代社会，法律依然或多少地偏袒着强者的利益，但有谁相信这世界就“应该如此”呢？</p>
<p>毫无疑问的，今天也不会有多少人乐于站在色拉叙霍马思一边和苏格拉底作对，但如果我们深究一下，色拉叙霍马思的推理究竟是因为是错的所以才是可厌的，还是恰恰相反，因为它是可厌的，所以才是错的？又或者“何谓正义”这个问题本身就是主观的，所以只要某个答案是可厌的，当然就是错的？</p>
<p>在许多人看来，就算很难给正义下一个准确定义，至少它不应该是主观的——要么该有客观的目标，要么该有客观的标准，那么“等值回报”看起来就是一个不错的标准。人们在寻求正义的时候往往都是为了“讨还公道”，而讨还公道往往也正是视图为恩怨情仇寻得一个令人满意的“等值回报”。</p>
<p>但事实上，以德报怨，息事宁人恰恰是时至今日你仍然被底层百姓奉为座右铭的至理名言。而“恩怨分明”这类的口号反而更多地出现在主流社会之外的江湖社会上。</p>
<p>这自然就出现一个矛盾，在百姓的心中，既渴望着“善有善报，恶有恶报”，相信善恶各自获得等值的回报才是正义，又完全不认可“以怨报怨”的人生态度，对于自身蒙受的不公正待遇，他们却推崇的是让三分，退一步式的息事宁人的人生哲学——“宽身之仁”</p>
<p>我们借由于丹教授的论语中可以把这个问题逼到极端：为什么与孔子完全背道而驰的解读反而最能攥住百姓的心？</p>
<p>孔子所标榜的礼，往往反映着世袭的封建贵族的道德品质，封建贵族想有世袭特权，生活保障度很高，又往往世代生活在熟人社会里，所以很容易培养出重名誉甚于重生命的道德观念——欧洲的封建社会也具有同样的特点，可见特定的社会结构对特定的道德观念的影响</p>
<p>在对待恩怨的态度上，什么才是最本真的人情呢？答案是显而易见的，以德报德，以怨报怨，善有善报，恶有恶报，这就是最本真的人情。诚如穆勒所说，报复的欲望“自发地出于两种情感，一是自卫冲动，二是同情心”，两者都是极为自然的情感，都是本能，或者说是类似于本能</p>
<p><strong>正如“我痛故我在”比“我思故我在”来得直截了当，“讨还公道”的情感也是直截了当地就发生了，而且就算公道讨不回来，讨还公道的情感也必须宣泄出去，这就意味着，即使无法直接报复在加害者身上，也必须找个攻击对象才行，这就是心理学所谓“替代性”攻击</strong></p>
<p>对于如此不合人情的论调，至少有两种应对方案</p>
<ul>
<li>引入上帝的角色，给等值报复赋予了神圣的依据。有一种正义，它的目的不在纠正犯罪得人，不再对别人起模范作用，也不再赔偿损害。这正义乃是以纯粹适合为基础的。它不单使被损害的一方感到满足，而且使所有聪明的旁观者也都感到满足，正如优美音乐使心地健康的人喜欢一样</li>
<li>“规则功利主义”认为等值报复的规则从长期来看对社会有利，倘若瓦解了这个规则，势必会助长恶行。</li>
</ul>
<p>在最限于体制的儒家看来，对恩怨分别给予等值的回报，这是人之常情，是最天然本真的对“公平“的诉求，因此便具有了道德上的权重。所以儒家不但提倡恩怨分明，甚至鼓励人们不经司法程序而手刃血仇————即便在汉唐以后，这种复仇行为仍然在很大程度上受到社会主流伦理观念的赞许，有时甚至还会得到法律上的保护。当然，因为社会结构的变动，所以历朝历代对这个问题的态度还是摇摆不定的。</p>
<p>但事情的另一面是，正所谓“刑不上大夫，礼不下庶人”，这种本之人情的恩怨态度已经被确认为礼制的内容，便更多地彰显着贵族精神的光环，并不要求庶人也同样遵守。孔子的一贯主张里，只要求君子做好表率，把贵族的道德标准春风化雨式地感染到庶人，但是并不强求庶人</p>
<p>随着宗法社会的瓦解，人们面对的一个棘手的问题便是如何在传统的封建贵族阶级彻底消亡之后重新解读儒家思想中无法遮盖的贵族精神。</p>
<p>这也算是一件无可奈何的事情，毕竟君子和小人的生存状况有着天壤之别，“小人”想要快意恩仇，需要付出比君子高得多的代价，反而相信吃亏是福会使日子好捱得多——这也正体现着君子和小人的一个显著区别： 君子寻求公正，小人注重幸福。前者是原则主义，后者是结果主义</p>
<p>这个时候出现了一个棘手的问题：对幸福生活的追求是人的基本追求，正如对公正的追求同样是人的基本追求一样，而在有怨不伸的前提下获得的幸福是真正的幸福吗？那么在鱼和熊掌不可兼得的情况下，追求幸福的结果主义与追求公正的原则主义，哪一个具有更高的道德权重呢</p>
<h1 id="何谓正义，是具体的目标还是抽象的准则？"><a href="#何谓正义，是具体的目标还是抽象的准则？" class="headerlink" title="何谓正义，是具体的目标还是抽象的准则？"></a>何谓正义，是具体的目标还是抽象的准则？</h1><p>在任何一个笑贫不笑娼的时代，所谓的“体面的失败者”就像椭圆的正方形一样，本身就是个自相矛盾的概念</p>
<p>比如说决斗的荣誉是会随着时代而改变的，现在的我们可以一笑置之，可在古代的欧洲这是不容拒绝的事。道德家神学家都没能做到的事被民主时代做到了。</p>
<blockquote>
<p>正义到底是某些具体的目标？还是某种抽象的准则？<br>我们是否可以达到绝对的正义？如果不可能的话，是否至少可以将之清晰地描述出来？<br>正义究竟是永恒不变的，还是一时一地的？这个问题随着人类的历史，深深困扰着最杰出的才智之士们，直至如今，对正义的困惑就像圣奥古斯丁对时间的困惑：如果没人问我，我是明白的，如果我想给问我的人解释，那么我就不明白了</p>
</blockquote>
<p>首先必须要指出的是，‘正义’一词的含义常常比较宽泛而模糊，时而指公平或正当，时而指善或福利。结果主义更加和福利有关，原则主义更加和公平有关，这实际上是义务论和目的论的区别</p>
<p>基督徒说上帝“至善至公”，对公平的追求往往就是对善的追求，尽管反之未必。</p>
<p>justice的定义来源于古罗马正义女神的名字，该女神蒙着双眼，左手提天平，右手执剑。梦魇象征着正义依靠理智不可被干感官蒙蔽，剑象征着制裁的严厉，天平象征着裁量公平。正义女神雕像背后的那句古罗马谚语“为实现正义，哪怕天崩地裂”。看起来，正义女神是偏向原则主义的，结果主义难道就相形见绌了吗？</p>
<p>例子：女主被杀，男主要去杀凶手，但是另一个人出来让他别傻因为在没有套出信息之前会有更多无辜的人被杀，而现在不去抓的话就很可能很难再抓住了——你怎么做？需要需要考虑其他人的感受</p>
<p>我不知道有多少人会站在这个里面的男主一遍，但是男主的支持者们如果碰到更加极端的例子，不知道还会不会坚持自己原来的态度————吴三桂冲冠一怒为红颜，假定这就是全部的历史真相的话，吴三桂为了寻求公平，确实搅得天崩地裂</p>
<p>亲亲原则，等值复仇原则两种都是上古社会最天然，最本真的道德，因为这正是最天然，最本真的人情，儒家所谓缘人情而治理，缘的就是这样的人情。等值观念是人的一种基本的心理模式，很难想象善待敌人的人能在最开始的那么残酷的环境里活下来。</p>
<p><strong>对公平的诉求是人的一种先天的心理认知模式，是与生俱来的，是一种只有形式而没有具体内容的先验的道德</strong></p>
<p>正义女神也只能衡量公平而无法衡量正义</p>
<p>从历史脉络来看，正义的概念应该比公平晚，因为前者需要文明的积淀，后者则是与生俱来的</p>
<div style="color:orange">正义因为其含义的模糊性以及标准的相对性，注定会是一个无法被清晰讨论的问题，为了避免这个问题，我们只有把复杂的“正义”还原到两个最基本的层面：公平和利害（完全缺乏客观标准）。但是，随后我们就会发现，公平和正义竟然完全缺乏客观标准</div>

<h1 id="高贵的谎言"><a href="#高贵的谎言" class="headerlink" title="高贵的谎言"></a>高贵的谎言</h1><p>依清代典章制度，滿臣上疏自称奴才，汉臣上疏只能自称臣</p>
<p>奴才，这个具有侮辱性的称谓在清代却具有尊荣和特权，如果我们援以“一直抱怨，以德报德”的等值原则，一个人当了奴才，到底是德还是怨呢？</p>
<p>今天看来，主奴关系显然标志着对奴才的基本人权的践踏，但是在缺乏现代人观念且世代为奴的古人看来，主奴关系恐怕是一个人所能想象的最好的关系，既有温情脉脉的家庭之感，又有幸福生活的妥善保障。</p>
<p>如果是单纯以追求幸福或者以增进生活福祉为目的，那么，维护或者建设和谐的主仆关系至少是众多可取的社会改良方案当中的一种，如此一来，编造一些“天赋主权”和“天赋奴权”之类的幻化当然合乎正义</p>
<p>柏拉图在设计自己心目中的理想国时就遇到过这种问题，因为他必须使理想国里分属三大等级的人各安其位，否则就有人产生僭越的念头，于是柏拉图编造了一种高贵的谎言，声称“神创造了三种人，每一种因其材质不同适合做的事也不同”。<strong>柏拉图相当清醒地认为，使当代人相信这个神话是不太可能的，但是通过有效而持久的教育，完全可以使下一代，乃至以后所有世代都对此深信不疑</strong>。柏拉图自己一点也不觉得自己用心险恶，这在他而言确实是一种正义的追求。</p>
<p>“您不认为，每个宗教都必须有一些打动人心的东西吗？我们的信仰就是为了打动人心而存在着的，这东西只能意会，不可言传，当人们寄予一种信仰以某种——您认为是虚张声势的——礼拜仪式时，人们就得服从宗教的戒律和习俗，只要您考察一下我们的道德，就会看到这一点”</p>
<p>事实上，为现代人耳熟能详的一些极具正义感的社会追求正是建立在各种各样的“高贵的谎言”之上的——天赋人权。<strong>他们有些可能对人类福祉的增进不可谓不居功至伟，但是仍然是一个高贵的谎言，因为谁也论证不出人为什么会天然的享有某些权利</strong>。事实上，天赋人权之所以受到广大人民的追捧，是有其特殊的文化背景的，即人类长期以来都相信自己只能发现权利，而不能创造权力。</p>
<p>实际上，所谓权力完全是人的社会属性，并属于应然范畴，我们可以说人天生有吃饭的欲望和能力，但没法说人家具有吃饭的权力，而任何应然问题都不可能是“天赋”的，而只能是道德的诉求，<strong>是人与人在社会交往过程中各自出于最大限度地争夺私利的目的，经过种种斗争与妥协而逐渐磨合出来的</strong></p>
<p>也就是说，所谓的天赋人权，并不是一个事实，而仅仅只能是一个追求，为增进生活的福祉为目的。——————也就是说，天赋人权是被作为解决公众不幸和政府腐败的一块基石，或者说是公众用以增进生活肤福祉的一件工具，或者说是公众的一种联合逐利的手段。</p>
<p>那么不妨问一个问题，如果可以达到同样的目的，“君授神权”“天赋奴权”是否可以和“天赋人权”获得同样的道德权重？或者说，人们之所以抛弃前两者，是因为它们无法达到与天赋人权所可能带来的同等的福祉的增进？</p>
<p>仅仅在心理学的层面上，天赋人权才是一个实然问题，即其源自人类天生的妒忌和攀比心理。譬如陈胜的“王侯将相宁有种乎”和项羽的“彼可取而代之”，陈胜和项羽虽然看到自己和王侯将相之间的现实悬殊，但显然认为对方所享有的权利自己同样有权享受</p>
<p>秦始皇所享有的权利之所以不会被卢梭认定为天赋人权，因为这和天赋没有任何关系。所谓天赋人权，只是私心在博弈中艰难赢得的战利品，是竞争中的人与人一个阶段性妥协的结果，<code>既非自然的事实也没有任何高尚感可言</code></p>
<p>那么，既然天赋人权既是逐利的结果，又是逐利的手段，若它和利益发生了冲突，应当怎么解决呢？譬如有这样一位八旗亲贵，世代包衣，饱受皇恩眷顾，但假定他度过卢梭的书，又了解美国独立战争的全部经过，深知自己和皇帝拥有同样的天赋人权，他应当何去何从呢？</p>
<p>信息控制是主人控制努力的一项重要的管理技术，但这不太适宜解释清朝的政治传统，满汉大臣们虽然在阅读范围上分别受到了一些局限，但作为当时社会里的精英分子，即时称不上学识渊博，至少也有基本的文化素养并且见多识广，他们难道真的不曾想要过讨还自己的某种权利吗？</p>
<p>严格辨析来说，人们是否享有天赋人权是一回事，在发现自己的天赋人权遭到侵犯之后是否具有讨还天赋人权的权利，这是另外一回事。统治者或许有这种权利，但人民只有逆来顺受的义务——————令人吃惊的是，这不是古老的君权神授理论的结果，而是康德在1797年基于实践理性原理缜密论证出来的，从人的自由意志，天赋权利，人不能以人为手段，建设法治社会，推理出“人们有义务去忍受最高权力的任意滥用，即使觉得这种滥用是不能忍受的”。</p>
<p>我们从中似乎隐约看到了色拉叙霍马思狂妄的身影，然而不仅康德，黑格尔也紧承其后，论证“德行就是服从政府”</p>
<p>米塞斯提出”自由通则“——————任何人的行为只受唯一的限制：不对他人造成损害，前提是所有人都享有基本人权</p>
<p>穆勒在《论自由》中试图确立“一条极为简单的原则”，即“人类获权——无论以个体的还是集体的方式————————干涉他们当中任何成员的行动自由的唯一目的，就是自我保护”</p>
<p>如果“天赋人权”和“以直报怨”都是平衡私利的结果，那么为什么甘做奴才就是会受到道德责难？</p>
<p>“人人生而平等”可以想象，持有这个观点想必会受到相当广泛的赞同——但可惜的是，这只是一个“高贵的谎言”，找不到任何有力的论据，<strong>仅仅认为人人应该生而平等并不意味着人人“确实”生而平等</strong></p>
<p>确实，世界上没有任何一个问题是真正不言而喻的。</p>
<p>生而平等固然论证不出，但是“生而不平等”的现象却比比皆是，即使抛开出身的不平等，人的天赋，性情也是不平等的。如果我们认同“万物并育而不相害，道并行而不悖”，认为在不损害他人的前提下每个人可以根据自身的天性自由发展，那么既然可以存在卡里斯玛式的天生领袖，为什么不可以存在某种类型的天生的奴才呢？</p>
<p>穆勒曾经专门讨论过人有没有卖身为奴的自由，他的结论是否定的——自由原则不能使人拥有放弃自由的自由。在这个问题上我们看到了穆勒感情用事的一面，他的结论并没有足够的逻辑支持，而只要我们甘愿做一个铁石心肠而头脑清晰的人</p>
<p>那么为什么做奴才这件事在大多数人眼中就是如此的不光彩呢？问题并非如此简单，如果仅仅是贬损人的尊严，并不必然就是不道德的，譬如基督徒奉行谦卑，在神面前极力贬损自己的尊严</p>
<p>即使是无神论者，它们会嘲讽神的虚伪，却很少会把宗教信仰和奴才划上等号。也就是说，在绝大多数的无神论者看来，即便是侍奉以为被人类自己臆想出来的虚妄的神，在道德上也远远高于侍奉以为有着血肉之躯的主人</p>
<p>一个耐人寻味的对照是：无论是东方还是西方，不卑不亢，恢宏大度自古以来都被看作是君子的美德，亦即一个人在道德上应当表现出来的中庸之道</p>
<p>融洽的主奴关系甚至连上帝也会为之欣悦，在旧约中有例</p>
<p>美国在1936—1938年开展节目，走访了大量曾经做黑奴的老人，记忆中有意料之中的血泪史，也有一些温暖的，甚至称得上是甜蜜的日子</p>
<p>即使是在幻想着人人平等，财产共有的空想社会主义者那里，也并不全然排斥奴隶的存在——乌托邦</p>
<p>从古至今，主奴关系从未受到普遍的排斥，这就意味着，普遍的平等（权力上的平等）从来就没有成为人们的普遍追求，平等从来都是平等者内部的平等，除此之外，相当程度上都是嫉妒心作祟——“文人相轻”</p>
<p>假设一个例子“一个男性临死前想去偷窥一位邻家女生”——确定的是他的行为不会被任何人发现，这件事在道德上是可行的。我们当然会谴责这种流氓行为，但是我们之所以作出谴责是因为我们知道了他的所作所为</p>
<p>艳照门事件。假设一个艺人在家里做这些事，之后不小心才散布在社会里。自由主义者所努力捍卫的“私域”被打破了，问题究竟出在哪？</p>
<p>当然，如果按照传统的道德观念来看，问题会简单很多，所谓“君子慎独”</p>
<p>如果照片不曾泄露的话，我们按照“以直报怨”的原则来寻求公正，发现找不出受害人——公正无从伸张，这样就意味着，道德和公正是可以剥离的。一件不道德的事其实可以是很公正的，那么，惩罚或谴责的依据从哪里来呢？</p>
<p>但是，问题当真可以如此简化吗？李敖在北大演讲时，谈到俄国小说“雅玛”女主人公是移民妓女，但她认为自己仍然是一个处女，因为她在用自己卖淫的钱资助共产党的事业和俄国的革命，她从事的是一项伟大的事业——那么滥交仍然是“败坏善行”吗</p>
<p>对于“妓女赚来的钱捐给共产党”此类的问题，儒家讲“经权之别”，亦即在原则性和灵活性之间采取一种谨慎而不拘泥的态度——人们很早就意识到，简单的道德训诫根本应对不了复杂多变的现实世界——罗素所说“即使是能够以简单的戒律做出决定，诸如不说谎或者不偷盗，这种戒律的正当性证明也只能通过考虑结果得到，人们必须承认，一个诸如十诫的行为规范很难是正确的，除非以结果的善恶来确定行为的正当与否，因为在一个如此复杂的世界里，服从十诫不可能总是带来比不服从它更好的结果”</p>
<h1 id="作为社群主义者的上帝"><a href="#作为社群主义者的上帝" class="headerlink" title="作为社群主义者的上帝"></a>作为社群主义者的上帝</h1><p>一个人不应该凭着怜悯，放纵或者愤怒莅审判，而至应该凭着理性，在人民中间，正义所诉求的只有公平</p>
<p>人所行的，在自己眼里都看为公，唯有耶和华衡量人心</p>
<p>妇女和儿童能不能杀？对罪人的惩罚能不能牵累无辜者？上帝对此会怎么做？这些问题，并不像看上去的那么不言而喻</p>
<p>终身吃土——出自圣经</p>
<p>上帝极有可能是一个社群主义者。从巴别塔的故事来看，上帝很可能并不希望人类社会结成一个统一的文化共同体，而是使其分散成若干个彼此难以沟通的小型社群。在社群内部，每个人的道德责任都是和他人关联的，甚至可能一荣俱荣，一损俱损。</p>
<p>有一点值得注意的是，持《新约》信仰的人一般会相信“最终”每个人都会得到公正的审判，或上天堂，或下地狱，泾渭分明。但若仅从文本上来看的话，《新约》重视心灵和天堂的福祉，《旧约》则相当世俗化，上帝的赏赐往往是财富丰饶，子孙繁衍，惩罚则是现实的——肉体上的毁灭</p>
<p>这就关乎人的另外一种心理，你接受了某种恩惠，就必须承担相应的责任，尽管给你的这份恩惠并不曾得到你的同意，举例子说明：父母既然给了你生命，你便理所当然地对父母承担责任——尽管可能存在争议，但这毕竟是千百年来的共识。“我把孩子养育，使他们养大，他们却背叛了我”这是连上帝都无法接受的事。那么对于父母的罪过，在生育自己之前所犯的罪过，自己“是不是”或者“该不该”承担一定的责任呢？</p>
<p>自由主义者对这种问题一般都会说“不”，但在上帝的眼里，责任是明显具备连带性的。上帝的连带性对于原罪理论是一个很好的注脚。自由主义者不会认同这样的观点，生活在21世纪的我们凭什么腰围远在山顶洞人时期的人类始祖的过错负责？但是，无论在基督教的理论体系里，还是在现实世界本身，这首先不是一个应然问题，而是一个实然问题</p>
<p>无神论者可以从这个角度来理解问题，即人类始祖给了我们生命（尽管未经我们同意），所以我们有义务担负他们的罪过。自由主义者也可以坚持自己的立场，只要他们坚持道德一贯性<strong>我可以拒绝为我没做过的事负责，但我同样应该拒绝为我没做过的事享受福利</strong></p>
<p>这是一个相当有趣的现象，因为很多时候如果站在自由主义的立场，当代我们显然不应该僭越祖先的这份荣耀，正如从未拥有过黑奴并坚决反对奴隶制度的当代美国人不应该对祖先的历史过错作出道歉</p>
<p>这是一个相当具有普世性的问题，譬如今天的中国人为大汉皇帝高唱赞歌，尽管此人血缘意义上的祖先也许在汉代饱受皇帝的欺凌，过尽了猪狗不如的日子，然而时间却使两千年的铸成丰功的皇帝被认同为祖先，因为这不但有助于增进当下的民族认同，更会为个人带来出身上的优越感，那么在公平的原则下，我们在享受祖先给我们带来的历史荣誉感的同时，理当同时承担下祖先所犯的过错，并且想办法做出弥补，我们和祖先构成了一种时间上的共同体。</p>
<p>时间共同体和空间共同体共同影响着塑造着我们每一个人，地域歧视就是最为显著，也最令人厌恶的一种表现，你会因为你的出身受到不同程度的尊重或歧视，人们会根据你所在的共同体的特点来给你做出初步评价，其理由完全和你个人无关，这实在是人类固有的心理机制使然</p>
<p>这首先是一个实然问题，无论是时间共同体还是空间共同体，都实实在在地给了我们正面或者负面的精神遗产，我们也实实在在地背负着这些遗产继续自己的生活，而不管我们本人会是多么极端地自由主义者，也不管我们自己愿不愿意</p>
<p>从功利主义的角度上看，孔子的“以直报怨”的主张虽然看似公平，其实是有所偏袒坏人的，也就是说，如果我们实行这样的伦理，一定会鼓励犯罪，使社会变得越来越动荡不安。因为小偷承受的风险实在是太小了，由此我们看到，以直报怨的原则仅仅诉求当事人之间的公正，而在改善社会风气这一功利主义的目的上表现欠佳——上帝在人间主持正义，所行使的往往就是震慑性惩罚——上帝的道德观念除了社群主义倾向之外，还具有功利主义倾向。正义和公平再一次分道扬镳，罪与罚不应该等值，这被看作理所当然的道德观念</p>
<p>除非所有的赃物都被追回，否则仅仅是以直报怨的原则是偏袒坏人的。就算加上精神损失费，小偷也可以改变策略，去偷富人。</p>
<p>法律该不该具有威慑性？ 想必这个问题很少会有人提出质疑，但是道德该不该具有震慑性呢？如果道德也需要震慑力的话，自然容易对那些遭受道德谴责的人不够公平。那么有失公正的道德虽然在现实世界中无往而不利，但是它能够成为一种理想的道德范式吗？</p>
<p>支持震慑性惩罚显然是一种功利主义的态度，并非诉诸公平，而是出于维护社会秩序之类的目的。恶是有蔓延性的，所以才有斩草除根，除恶务尽的必要。</p>
<p>《尚书》中的《商书 盘庚》中盘庚和伍子胥都是把国家兴盛当做第一目标，而公平显然会对这一目标的实现构成阻碍。如果把国家兴盛和公平分别看作两项正义的话，正义显然是分大小层次的。这是一种结果主义的思维方式会导致一个颇不易回答的问题——牺牲无辜者的生命以维护集体利益，这么做是正义的吗？</p>
<p>在《旧约》中有这么一则涉及牺牲的故事，是说以色列的统帅准备攻打亚门人，于是向耶和华许愿，说只要耶和华帮助自己取得胜利，那么当自己平安归来之后，就会把家里第一个出来迎接自己的人献祭给耶和华，让他没有想到的是战胜之后第一个归来的是自己最爱的独生女。就在他左右为难之际，女儿却深明大义，勇敢地献出了自己的生命。</p>
<p>这个故事曾经让神学家颇感为难，于是引出了许多巧妙的解释。若从世俗的角度上看，牺牲一个无辜者的性命来保证整个部落的一场至关重要的军事胜利，这也许算不得什么错事。甚至还有霍布斯这样的哲学家，以这个例子来说明一位主权君王是有权利处死他治下的无辜臣民的。</p>
<p>自愿是自由主义的重要原则。但是什么才是自愿？不妨假设一位遭遇打劫的可怜人，如果在要钱还是要命之间选择，这还能被称为是自由选择吗？</p>
<p>两害相权取其轻，两利相权取其重。是同等性质的自由选择吗</p>
<h1 id="从奥米拉丝的孩子到巴厘岛的王妃"><a href="#从奥米拉丝的孩子到巴厘岛的王妃" class="headerlink" title="从奥米拉丝的孩子到巴厘岛的王妃"></a>从奥米拉丝的孩子到巴厘岛的王妃</h1><p>1973年。勒昆发表了一部幻想题材的短篇小说《走出奥秘拉斯的人》。描述了一个叫做奥秘拉斯的乌托邦，人间天堂，但是所有生活福祉都依赖于一个被藏起来的孩子，孩子被虐待和忽视，但是如果还孩子被拯救，爱护和关照，城市的福祉就会消失</p>
<p>桑德尔的《正义》引述了勒昆的这个故事，把它作为反对功利主义的一则生动鲜活的例证，认为反对边沁式的功利主义的人会诉诸“基本人权”以拒绝奥米拉斯的幸福生活</p>
<p>事实上，在勒昆的小说里，的确有一些人默默离开了奥米拉斯，他们“很清楚自己走向何方”</p>
<p>面对奥米拉斯的问题，也许很多人都会选择离开，尽管每个人都很清楚，自己的离开不会对那个可怜的孩子有任何的帮助，对奥米拉斯的居民们也产生不了多大的影响，唯一的实际后果就是使自己的生活变差。自己的离开只是一种表态，一种代价惨痛的表态，这就是原则主义的生活态度</p>
<p>耐人寻味的是，如果是实现签订了契约在无知之幕下，就像中彩票一样，人们都可以心安理得得享受了，公平但是未必道德</p>
<p>在小说中，勒昆对那个无辜孩子的生活处境的不惜篇幅的描绘足以使任何一颗善良的心抑郁许久，但如果我们抛开艺术的感染力不谈，假定那个孩子仅仅忍着轻微的痛楚，故事又将如何呢？</p>
<p>可想而知的是，会有更多人心安理得地继续在奥米拉斯生活下去，他们或许仍然会认识到，加诸在那个无辜孩子身上的不幸，无论是惨绝人寰的悲剧还是微不足道的小小不适，都使自己的生活在道德上有了瑕疵</p>
<blockquote>
<p>从这里可以看出来，本书就现实指导意义而言已经与现实生活产生了偏差。实际上，我们既不是狂热的虔诚教徒，也非慎独的君子。道德上有了这样的瑕疵实在正常不过，当然心中道德的标杆就另说了，不必那这里的道理来苛责自己这一点想必我不说大家也能默契地理解。</p>
</blockquote>
<p>就小说的艺术而言，这个故事属于典型的概念先行的作品</p>
<p>奥米拉斯式的道德抉择的确是一个很有挑战性的问题，它不仅挑战了边沁式的功利主义，甚至还可以拿来对罗尔斯的“无知之幕”发出质疑，在当前条件下，任何一个理性的人在“无知之幕”之下哦度应该投票选择的，虽然自己有可能成为那个不幸的牺牲者，但理性人不应该考虑小概率事件</p>
<p>然而更加耐人寻味的是，奥米拉斯的居民是因为“发现”了这个残忍的事实而良心不安，而在无知之幕下签订一个缔结奥米拉斯社会的契约却可以使人们心安理得地享受奥米拉斯的幸福生活，再也不会对那个牺牲者怀有任何的愧疚————因为他只是“中了彩票”，而每个人事前都自愿地投了注</p>
<p>这看上去相当公平。但是，我们可以说每个人基于这一契约而享有的幸福生活是道德的吗？————<strong>公平，但未必道德，甚至未必幸福</strong>（这个例子我觉得是把公平与道德分道扬镳的情况描述地较为清晰的）。因为至少在康德看来，奥米拉斯居民所享有的幸福并不与他们的德性匹配，而任何不基于德性的幸福都是毫无价值的。</p>
<p>当然，奥米拉斯的幸福新居民想来不会有太多人在意康德这种过于苛刻的幸福标准，只是径自心安理得地享受不幸福的幸福</p>
<p>在历史上，确实有一个人的身世像极了奥米拉斯的那个可怜的孩子，他就是六世达赖仓央嘉措</p>
<p>“诸神把世界托付给了他，他却想要回他自己”。仓央嘉措身上负担着全部藏地的兴亡荣辱，从这个角度上讲，他必须把活佛的角色好好扮演下去；但对他自身而言，似乎除了诗酒风流之外，一切都是不可忍受的痛苦。正是这样的冲突感给他的人生笼上了浓重的悲剧色彩，使后世的人寄予他无限的同情。但是仓央嘉措应该做什么呢？那些用尽一切办法阻止仓央嘉措的人难道错了吗？</p>
<p>真实的世界的确复杂很多，牺牲少数人以维护大多数人利益在很多人看来不仅可以接受，甚至是应当如此的，尤其当设计不计私利的“高尚的牺牲”的时候</p>
<p>比如说，战争中的杀俘问题。战俘有没有权利，这是一个很令人纠结的问题。可想而知的是，战俘当中必定有无辜者的存在，哪怕为数极少。但忙于作战的不对不可能花费大量的人力物力去做巨细靡遗的甄别工作，何况战争中伤及无辜总是在所难免。那么，在无力甄别战俘的情形下展开杀戮，这是不是一种故意的杀害无辜的行为呢？</p>
<p>那么，更进一步，故意屠杀敌国的平民，这在道德上是可以接受的吗？</p>
<p>丘吉尔对冲绳之战的结束场面记忆尤深，那个时候，走投无路的日军拒不投降，先是军官们在庄严的仪式中切腹自尽，随后，成千上万的日军排成队列，用手榴弹自尽而亡</p>
<p>所以，丘吉尔和杜鲁门都预计到，和具有武士道的日军正面交锋，会造成英美军队巨大的人员伤亡（这既是事实，也在一定程度上是同盟国首领为自己采取的决策所创造的说辞）</p>
<p> “广岛的原子弹”——如果在1945年可以做一次广泛的民意调查，问问世界上，如果两颗针对日本的原子弹就可以结束战争，多少人愿意？想来就算不是全票也绝对是压倒性的大多数，一旦打起来会造成英美军队巨大的人员伤亡，只消一两次的爆炸，战争就能全部结束，看起来真是一种奇迹般的解脱，得到了与会者的一致同意。“连一点其他的声音都没有”，而这实际上也拯救了敌人的生命，给了有武士道精神的人们台阶下，否则他们可能会战斗到最后一个人</p>
<p>平民，无论如何都不能被纳入职业军人的攻击目标</p>
<p>出于正义的目的不妨采用一些非常手段，但这本身就违背了正义规则，如果这也可以的话，那么战争的双方究竟谁才是正义的，难道只是五十步与百步之别</p>
<p>相应的辩护可以这样，战争把人带入了自然状态，在自然法的支配下，人可以无所不用其极。</p>
<p>这个估计有可能是准确的，但它以为着这样一个令人不快的道理：在生死攸关时，道德可以被置之脑后——保种图存才是最高的道德准则。道德的要求其实不外是基因的要求，一切文明的粉饰，根底不外是人类的生物性罢了</p>
<p>普通人更愿意接受的情景也许是这样的：奥米拉斯被一个独裁政府控制着，统治者都是一些铁石心肠的人，它们在确保私利之余确实也操心着国民福利，他们相信任何统治者都需要一些忠心的佞臣去做一些必要的脏事，关于那个孩子的消息被佞臣藏起来了，永远不被那些善良的人民知道。</p>
<p>事实上，这就是独裁政府的魅力所在——子民最大限度地避免了自己的道德责任，再也不用纠结于那些两难的抉择，同时安享稳定的生活，即使政府倒台，事情败露，也是由那些统治者和佞臣去承担责任，一切与己无关</p>
<p>的确有人支持这样的解决方案，譬如蒙田，自然界没有无用之物，即使是我们人性中的那些污秽之物——破坏了这些就是破坏了人类生存的根本条件。同样，任何政府都有一些必要的机构，这些机构不仅卑鄙，而且腐败，恶行在那里得其所哉，并被用以维持这个社会，犹如毒药被用来维护我们的健康。虽说这些机构有了存在的理由————因为我们需要它们，而共同的必要性掩盖了它们真正的性质。</p>
<p>也许我们有必要重新评价那些臭名昭著的政客和政府部门。他们为了公众利益不得不去做一些脏事，假设他们的卑鄙残忍狡诈确实提高了公众利益，而我们自己恰恰就是这一公众利益的受益者之一，我们该做出怎样的道德抉择呢？</p>
<p>在战争年代，人们更容易接受铁石心肠,不怕做脏事的领袖，当然也有一些人在任何情形下都坚持道德的准则,对他们来说，反抗固然要坚持到底，但是不能以任何人的生命为代价</p>
<p>孟子“行一不义，杀一无辜而得天下，皆不为也”，也就是说，如果让他们做哪怕一件不合道义的事，杀掉哪怕一个无辜的人而得到天下，他们都不会做</p>
<p>这样的问题，在坚定的原则主义者那里算不得太大的难题，而如果把问题换一个方式：假设必须要做一件不合道义的事，杀掉一个无辜的人，才能挽救天下人的性命，他们会做吗？假设奥米拉斯城的小孩的悲惨命运换来的是所有人的性命的话，该不该牺牲他呢？<strong>如果答案是应该的话，那就意味着结果确实重于原则，所谓基本人权在某种情况下是可以被忽略掉的</strong>。</p>
<p>下一个问题是，那些出走者认为在道义上应该救下哪个孩子，却面临着全程绝大多数人的抵制，不诉诸暴力则无法达到目标，那他们应不应该，或者在什么程度上诉诸暴力呢？</p>
<p>在回答这个问题之前，还有两个问题必须得到回答（1）人可不可杀人，是否在任何情况下都不可以杀人？ （2）谁有权利为奥米拉斯的那个无辜的孩子讨还公道</p>
<p>对于第一个问题，似乎只有在神学范畴里才能为“不可杀人”找到坚实的理据，譬如在《旧约》中，杀人的罪恶并不在其本身，而在于渎神。（因为神按照自己的模样创造了人）</p>
<p>这似乎就是问题的重点，然而事实上只要我们也甘愿冒一点渎神的风险，还是可以追问下去的，亦即为什么凡是渎神的就一定是不道德的？</p>
<p>上帝既然赋予了我们自由意志，人类就被授权通过自己的认知能力来判断自己是否应当信仰上帝。上帝是全能的，但是全能未必能构成你向他膜拜的理由</p>
<p>自由主义的“同意”原则在这里发生着作用，父母虽然没有能力先征得子女的同意再把他们降生到这个世界，但全能的上帝一定有办法先征得我们的统一再让我们来到这个世界，甚至他的全知完全可以预先洞悉我们的意愿，那么，我们为什么要对一些完全可以预先征得我们同意却不曾如此的事情承担责任呢，尽管交给我们的可能是我们梦寐以求的天堂</p>
<p>如此，只要我们保持“同意”原则的一贯性，渎神的罪恶也就失去了道德一句，而“同意”原则恰恰是自由意志最醒目的彰显，也就是说，只要我们对自由意志的人事保持神学上的一贯性，就有理由保持统一原则的一贯性</p>
<p><code>杀一人以存天下，只是两害相权取其轻，原本天下人一个也不该杀，只可惜我们被逼入这一个两难的境地，那就只好杀一人了，这是极端情况下的被迫的选择，没有任何道德权重可言。</code></p>
<p>这个问题恰恰带出了功利主义的适用范围的问题，理性人做选择时都会权衡利弊——但是一个人如果越出私域代替别人去做权衡利弊，算不算越俎代庖？这意味着，你在“杀一人”和“存天下”之间艰难权衡的时候，你其实没有任何的权利去决定别人的生死，无论对方是一个人还是所有人。</p>
<p>退一步讲，即便依据“最大多数人的最大幸福”这一功利主义的著名原则，这个生死抉择仍然不容易做。首先，遭人诟病的事，这一原则本身无法自洽，因为<strong>任何这类问题都不能包含两个最大，大多数人的幸福可能和最大的幸福相冲突</strong>，其次，即便两者不矛盾的时候，也有可能产生令人不易接受的结果。</p>
<p>康德“人不能以人为手段”。但是只要我们继续追问下去，人为什么不能以人为手段，那我们只能走入前述的所谓的基本人权的领域了</p>
<p>当今的西方国家陆续废除了死刑，似乎人在任何情况下都不应该剥夺他人的生命，但吊诡的是，战争行为在道德上依然是被许可的，这似乎说明了一个奇怪的道理，国界就是基本人权的边界——因为基本人权真是最高原则的话，国家之间便没有理由开战</p>
<p>可以构成辩护的理由是，因为对方侵犯了自己的基本人权，为了维护自己的基本人权——这样说来，最高原则不是基本人权而是对每一个人来说的“自己的基本人权”。每个人都没有天然的义务去尊重别人的基本人权——这当然不是那种绝对的原则注意的道德范式，因为它不主张在任何情况下都不可剥夺任何人的基本人权</p>
<p>如果你遇到这样一种情况，有人正在侵犯你的生命权，而你只有通过剥夺对方生命权的方式才能捍卫自己的生命权，你会怎么做呢</p>
<p>这看上去是个无比愚蠢的问题，然而圣雄甘地的建议是“他应该自杀，而不是反击”。我们当然可以不接受甘地的意见，但没理由怀疑他的真诚</p>
<p>比如说你和一个人在一个独岛上，食物有限，这也就意味着，你们每个人的存在，其存在本身就构成了对对方生命权的侵犯。每吃一口粮食都是在伤害对方，如果是道德的双方，可能都会把事物让给对方。但是理据何在呢，如果不是两个个体，而是两个国家处于这种关系之中，正义性会有任何不同吗</p>
<p>但是如果是个猩猩呢？你还会跟它客气吗？似乎所有的道德难题会瞬间被一扫而光。如果你是基督教的教徒的话，连君子远庖厨的恻隐之心都不必要了</p>
<p>或许我们的特殊性就在于我们是人，对他人的基本人权的尊重来自于我们对人类共同体的尊重，面对人类共同体的尊重则是从个人的同情心扩展来的，进而从实然变成应然，从客观事实固化为道德规范。这也就意味着我们至多说我们愿意接受这种道德，但没法论证这就是对的</p>
<p>人到底是什么？或者说我们的边界到底在哪？——为什么我们有的时候会给予非人类的东西以更多的情感</p>
<p>事实上——就算一只鹦鹉会说人话，我们也不会把它看作人</p>
<p>然而标准都是人定的，是人定的就必然摆不脱个人的主观性，这就是古希腊哲学家普罗泰戈拉的那个著名命题:”人是万物的尺度，是存在者存在的尺度，也是不存在着不存在的尺度”。不过既然是普遍的主管认同，就难免世易时移，没有永恒不变的标准，道德的标准同样如此。所有的道德标准都是世易时移的，是人在相互作用中主见磨合出来的，处于自觉或不自觉的认同。</p>
<p>即使是人，也有可能因为某种原因而突然变成非人——因为其已经灭绝理性</p>
<p>人类的道德感和禽兽的道德感之间的区别是本质上的不同呢？还是仅仅是程度上的不同。</p>
<p>当然我们既会把禽兽看得像人，也会把人看得像禽兽。</p>
<p><strong>即便有了清晰的标准，问题仍然难以解决。譬如对“人”的界定就是永恒不变的，其内涵就是我们当下的主流认识，那么至少可以肯定的是，牛不是人。但我们应不应该杀牛呢？杀牛，对一个人来讲，是否不存在任何道德瑕疵呢？</strong></p>
<p>这看上去是一个蠢问题，是的，许多人吃肉，不觉得这有什么不道德的。即使是宣扬三世因果六道轮回的佛教徒，也只会说吃肉是你在造恶业，会使你在轮回中饱尝恶业，即只会关乎你的切身利益但无关与你的道德。反过来，某些比我们高级的多的外星人，为了自身利益准备杀掉我们，这是否也不存在道德问题。</p>
<p>这是一个富有启发性的问题，我们之所以问心无愧地杀牛，仅仅是因为我们在牛面前是强者？如果说同类之间的残杀是不道德的，但是我们确定同类的标准拒绝是如此的主观，如此的游离不定，是否可以以力量等级为标准，在某个力量等级以上的强者视彼此为同类，认为彼此不可相残，而杀害被定义为另一种群的弱者则不必富有任何内疚</p>
<p>这会使我们归向臭名昭著的尼采哲学：一个善良的贵族应当毫无愧疚地接受千万人的牺牲，这些牺牲者必须将为奴隶。从尼采的意见中我们可以合乎逻辑地推断出，在同样具有感知能力和思考能力的物种中，能力较差者“理应”为能力较强者做出牺牲，正如猩猩或牛马“理应”为人类做出牺牲一样，如果一个人，一个高贵的人，对猩猩或者牛马表现出任何谦卑的姿态，那么他无疑是在自取其辱，自甘堕落</p>
<p>那么，接下来的推论将是令人不快的，<code>一个赞成对猩猩或者牛马可以生杀予夺的人，只要真诚地保持逻辑一贯性的话，就没有任何理由反对尼采的意见，进而对杀人问题的态度会宽容很多</code></p>
<p><code>但事情还有另外的一面——杀人就一定对被杀的人不利吗</code>？安乐死的支持者们肯定会表示异议，在敌人日复一日的酷刑折磨中的人多半也不会赞同</p>
<p>回顾《独立宣言》中那些激荡人心的语句：“我们认为下面的真理是不言而喻的：人人生而平等，造物主赋予他们若干不可剥夺的权利，包括生命权自由权追求幸福的权利”</p>
<p>那么，问题一，假设我们确证这些的确就是我们的基本权利，那么我们是否可以主动放弃这些权利。问题二，如果发生了这样的事情，即生命权，自由权和追求幸福的权利彼此冲突，我们应该何去何从呢</p>
<p>对于第一个问题，支持天赋人权的人一般会持反对意见：既然这些权利都是天然具备的，是与生俱来的，就像基因一样紧紧伴随人的一生，那么就算有人甘愿放弃也不可能做到。但是如果认可这种见解，那么天赋人权的道德色彩就会变得相当可疑了。譬如在生物学上，贪欲和情欲都是与生俱来的根深蒂固的，那么为什么就没有和生命权自由权等一样的道德权重呢？</p>
<p><code>我们显然不能因为自己天然是什么就认为在道德上应该追求什么。</code></p>
<p>天赋人权在事实上也许仅仅是：我们希望拥有这些权利，所以我们认为自己天然拥有这些权利，并且应当拥有这些权利，</p>
<p>其次，天赋特质就算不可改变，但至少可以抑制它的表现，譬如你天生是一个外向的人，但只要你有足够的动机去改变，就可以选择一种离群索居的生活</p>
<p>接下来，对于第二个问题，倘若天赋人权可以被放弃的话，一个心智正常且未收到任何逼迫的成年人有没有放弃生命权的自由权。如果他经过审慎的思考，认为放弃生命权才是自己追求幸福的唯一的办法，那么他是否能够以放弃生命权的方式来行使自己追求幸福的权利呢</p>
<p>反对者当然可以声称任何形式的生活都比死亡好，但至少哈姆莱特不这么想，他既想求死也畏死。他的想法其实是一种相当功利的思维方式，之所以不敢贸然去死，只是因为无法确定死后的世界是否比现实世界更坏。否则的话，倘若死亡真的是一个人的终点，那么事情就变的简单多了。</p>
<p><strong>而事实上，我们还会遭遇两个问题（1）如果一个人的生命不是完全属于自己，亦即他对自己的声明没有完全的所有权，是否也就没有足够的权利来决定自己的生死呢？（2）哈姆莱特式的功利主义权衡真的站得住脚吗，，对利和害的内心感受真的就是生命的全部吗？</strong></p>
<p>第一个问题是一个相当常见的意见，那么，当我们所信奉的神灵，所敬拜的祖先或者所属的组织准许我们寻死，甚至通过什么手段或代理人夺取我们的声明，这在道德上是可被接收的吗</p>
<p>神灵和祖先助人求死的事情在古代也不少见。范文子有意自杀，但限于时代观念，只能经由祭祀这样的正当途径，求得祖先神灵的理解和帮助。</p>
<p>对于第二个问题，对利与害的内心感受是否真的就是生命的全部，这就要从功利主义的出发点说起了</p>
<p>在功利主义者看来，人就是一架时刻权衡着快感与痛感的机器，导向快感的就是善的，导向痛感的则是恶的。道德或者正义能否这样被还原到心理层面呢？作为功利主义的反对者，诺齐克没有考虑到“快乐箱”的存在（快乐箱的问题我专门写过一篇文章）</p>
<p>当诺齐克在政治哲学或者伦理层面上反驳功利主义的时候，他的推理至少在纯粹的哲学层面上是站不住脚的。</p>
<blockquote>
<p>假设有快乐箱的存在的话，我个人是非常愿意进去的</p>
</blockquote>
<p>从理论上继续分析，就会发现，只有当我们站在机器之外，才能像诺齐克这样评价机器里面的生活，因为一旦我们进入了机器，环境就变成了我们所相信的真实世界，我们便只有在机器内部来认识自己以及围绕自己的这个生活。于是我们将不会觉得自己在过着一种虚假的，被机器操纵的生活，<strong>我们将由衷地相信自己的每一个决定都完全源于自己的自由意志</strong>，我们对爱和甜蜜的感受将和机器之外的感受同样的真实，我们也不可能想象到这是一个人造的世界，在这个世界之外还有着“更深刻或者更重要的东西”，就像我们不可能想到现实世界之外是不是还有一个更加真实的世界，在那个世界里还有许多“更深刻或者更重要的东西”</p>
<p>人的认知能力有多大，世界就有多大，我们不可能认识到我们的认知能力所无法达到的疆域。我们所有的认知能力，在进行所有的认知活动时，所引发的所有的反馈，确实都可以被分为快感和痛感两种。在这个意义上讲，我们“感受到”的生活就是我们全部的真实生活。反过来说，我们的生活不可能超出我们的感受之外</p>
<p>那么，作为一个功利主义者的哈姆莱特，只要能够调查清楚死后世界的真实信息，就完全可以再“生存还是毁灭”的纠结中轻松地做出抉择了</p>
<p>在分析过“人可不可以杀人，是否在任何情况下都不可以杀人”之后，我们该着手第二个问题了，即“谁有权利为奥米拉斯的那个无辜的孩子讨还公道”</p>
<p>我们先假定那个孩子已经长大了，是一个心智健全的成年人，那么他本人的同意就是我们救他出火坑的必要条件。如果得不到他的同意，我们该不该向他伸出救援之手呢？</p>
<p>假定赵匡胤的灭南汉之举确实是拯救了南汉之民，那么，赵匡胤的这番作为究竟有着怎样的道德权重呢（虽然他自己的道德色彩并不会比南汉更好）</p>
<p>对于赵匡胤建立宋朝的道德色彩问题，我们不必争论这个论断的是非对错，无论如何，从中引出的一个疑难问题就是：如果对独立主权给予充分尊重的话，那么，打破对方国家的信息封锁这一行为本身是否就已经构成了对对方主权的侵犯呢</p>
<p>但是，对主权的侵犯是否一定就和正义性水火不容吗？或者说<strong>主权问题到底是不是原则问题</strong>。设想在无政府状态下的自然村落里，你和邻居的关系就相当于两个独立主权国的关系，他的唯一的任务就是虐待妻儿，他的控制能力是如此之强以至于妻儿从来都没有想到过这个世界上还能有比这个更好的生活。假如你是一个有正义感的人，你会怎么做？</p>
<p>巴厘岛——三位王妃殉夫——在所有巴厘岛的人心中，她们明明是走上了一条被人艳羡的幸福之路，她们是完全自愿的，热情地追求着来世的福祉，对她们来说是一种无上的光荣，谁能证明她们错了？</p>
<p>只要利益是主观的——那么在巴厘岛这个社群内部，虽然死掉了3个无辜者，但这不但不违反自由主义的通则，甚至还会取悦最苛刻的功利主义者，因为这样的行为毫无疑问取悦了“最大多数人的幸福”，这甚至还是一种十足的帕累托改进：即在增进福祉的时候，并没有任何人的利益受到损害</p>
<p>“人吃人是错的”，这样一个看似不言而喻，简单到无可附加的命题，一旦深思起来，的确是难以解决的</p>
<p>历史地看，把吃人当作错事，只是一时一地的道德观念罢了，是人类在“文明化”之后方才固定下来的一种认知，天真的野蛮人可不这么想。</p>
<p>在推进理性以揭开启蒙时代的时候，理性已经走得过于极端，以致于不近人情了——任何一种思想主张如果想要深入人心，理性上是否圆滑无碍一点都不重要，重要的是要合乎人之常情。<strong>很多情况下，甚至是一切问题上，是情绪上的厌恶程度决定了道德的高度</strong></p>
<p>进入文明社会之后，吃人被列为禁忌，人们对杀人却有着相当的宽容，这两者的本质在哪里呢？</p>
<p>如果为了正义的目的可以杀掉敌人，或者摧残敌人的尸体以达到泄愤或者威吓的作用，为什么就不可以吃掉敌人呢？</p>
<p>当然有人质疑，一旦吃了人，原本正义的目标也就收到了玷污，甚至不再值得维护了。但这样的质疑在逻辑上是站不住脚的：我们正在为“人吃人是错误的”寻找理由，不能将其预设为前提</p>
<p>自然状态直到现在仍然是正义问题的一个思考难点</p>
<p>在道义的大旗下，人们便不再觉得残忍的行为有多么难以接受了</p>
<p>问题<br>    1）如果整个社会风尚都赞同甚至冲上某种吃人的行为，那么吃人可不可以算作是道德的？<br>    2）在凶世末年，人类社会退化到自然状态，道德和法律是不是也不应该有约束力了？<br>    问题2正是现实主义的合乎逻辑的推论——譬如时至今日，仍有很多人认为，在国际事务这种自然状态下，”没有永远的朋友，只有永远的利益“，弱国无外交。道德和正义是没有任何地位的——自然状态和文明社会的冲突。</p>
<blockquote>
<p>2个德国工程师在相互协议的情况，一个吃了另外一个——按自由主义的标准，这种行为是没理由被禁止的，按社群主义的观点去解释，不同于巴厘岛王妃献祭，那个是深深扎根于自己的社群文化的，这个却有悖于自己所在的社群伦理——并不是他要对具体的那个人负责，而是因为他伤害了我们的感情——这背后是在是一种强权的逻辑：我们是大多数，仅此而已。试想，我们完全处于高尚的情操以及最基本的人道主义精神挺身而出，施以援手拯救王妃，那么当我们这么做的时候，是否也伤害了所有巴厘人的感情呢？而它们又应该以怎样的手段来处置我们这些僭越的渎神者呢？</p>
</blockquote>
<p>当然我们认为应当给人的生命以最大程度的尊重，我们会响应康德的主张，相信人只能是目的，不能是手段。这正是普世性伦理之所以难以成立的一大症结，只要人们对生命的本质存在歧见，只要今生和永生无法调和，那么无论是“己所不欲勿施于人”康德的定言令式或者罗尔斯的无知之幕，功利主义的权衡计算或者是自由主义的行为通则，任何规则都不可能放之四海皆准，我们除了无可奈何地接受那种令人生厌的道德相对主义或者文化相对主义之外，再也没有别的方法</p>
<p>凡此种种会容易使我们倾向于沃尔泽的意见，追寻一种普遍的正义理论是不可能的，谁也没有办法跳出自己的历史与文化。那么，只要一个社会的运作方式吻合该社会成员的普遍共识，这个社会就是一个正义的社会。这就意味着，我们不可能通过哲学来确定正义原则，而只有通过文化阐释。而文化，我们知道，是永远摆脱不了相对性的</p>
<p>但是，如果按照他的这个标准，我们可以认定巴厘岛虽然存在着令欧洲“文明社会”忍无可忍的人殉现象，但就其自身来说是完全合乎正义的————这绝对不是一个会令我们大多数人欣然接受的结论，就连沃尔泽本人也会感到踟躇，所以他提出了一个“弱的普遍性原则”，认为存在着很少的一些真正具有普遍性的权利，是所有的社会都应该遵守的，譬如无论在任何社会，种族灭绝和奴隶制都是不正义的</p>
<p>然而事实上，沃尔泽的这些“最低标准”恰恰使他落到了自相矛盾的境地，他自己也不曾跳出自己的历史和文化。是的，至少古代的雅典和斯巴达人不会接受他的标准，亚里士多德也一定会起而与之论战</p>
<h1 id="自由意志的两难"><a href="#自由意志的两难" class="headerlink" title="自由意志的两难"></a>自由意志的两难</h1><p>公正原则即“以德报德，以直报怨”原则，存在一个难以确定的原则——如何确定“等值”</p>
<p>如果一个一心求死的抑郁症患者谋杀了一个朝气蓬勃热爱生命前途无限的青年，那么死对他来说是个惩罚吗？就杀人凶手的个人感受而言，能够被处以极刑不仅算不上惩罚，兼职就是一种求之不得的福利</p>
<p>也许这名杀人凶手本人也是一名受害者，甚至说这个杀人凶手才是正常不为人知的阴谋中唯一被针对的目标——一位变态杀人狂想满足自己的癖好——不想受到法律惩罚——安排了一切的可能成为杀人凶手的环境</p>
<p>的确即使一生在这样的环境里长大，这个孩子不必然变成一个厌世的杀人凶手，但其或然性“必然”远远大于生长在阳光环境下的同龄人。那么，他为自己的谋杀行为所需要付出的“等值”的代价究竟是什么呢？</p>
<p>这个人的犯罪行为，或就那点而论，他生命中的大部分行为是自由的吗</p>
<p>这个问题还会把我们引入一个更加令人困惑的领域：“人应该在何等程度为自己的行为负责”。一般来说，这个问题一取决于回答者的社会地位，权贵和富人喜欢喜欢“有付出才有回报”“是金子总会发光”这类论调，*<em>穷人们如果还不曾被话语权的垄断者们彻底蛊惑的话</em>，往往会对权贵和富人们的侵略性姿态感到刻骨的仇恨和深沉的无奈*</p>
<p>约翰格雷（19世纪的社会空想家）——“我们很愿意承认，对于一个由于他无力判断的情况而偶然处于压迫者地位的人，哪怕怀有一点点的敌意，都是非常不公平的”</p>
<p>可是有哪一个压迫者不是“由于他无力判断的情况而偶然处于压迫者地位”的呢？一个人的生命中究竟有多少成分绝对不属于“命运的安排”</p>
<p>让我们再看看事情的另外一面：维多利亚时代的英国曾经流行过一种“矫治哲学”，它在相当程度上被贯彻到司法实践中。我们对罪恶要做的主要不是惩罚而是教育，这才是监狱最恰如其分的职能</p>
<p>教育和惩罚，那种方式才更加符合公平原则呢？要想回答这个问题，我们必须直接面对哲学史上最具争议的巨大核心问题之一：人到底有没有自由意志</p>
<p>我们之所以认为人应当对自己的行为负责是出于对自由意志的认同。但是，站在今天的知识背景来看，人似乎是基因和环境的产物，那么我们真的拥有我们自以为的自由意志吗？假设我们没有，或者在相当程度上没有自由意志，又该如何对自己的行为负责？</p>
<p>古希腊哲学家留基波“没有任何无缘无故的事情，万物都是有理由的，并且都是必然的”</p>
<p>《庄子》的影子那个故事很容易让我们想起佛教的缘起法。简言之，就是发现了这个世界<br>的基本规律就是因果律，没有无因之果，也没有无果之因，万事万物都陷入这个因果的链条中挣脱不出。所谓陷入因果律中，也就意味着人生是不由自主的，是受所谓“业力”主宰的。不由自主地想要自主，陷入因果律而想要跳出因果律，受制于业力而想摆脱业力的束缚，这才有了真如实相寂静涅槃等理论</p>
<p>因果论必然导致宿命论，而宿命论该如何与自由意志相协调呢</p>
<p>要解决自由意志的问题，就必然绕不开因果律。因果律的问题无论是哲学上还是神学上都是一个很经典的两难问题，承认或者或者不承认因果律都很麻烦</p>
<p>首先是第一因的问题，有没有第一因，第一因是什么，没法解决</p>
<p>其次是承认了因果律就等于承认了宿命论，也就等于否定了自由意志，否定了自由意志也就意味着我们不该为自己的一切所作所为负责。但承认自由意志的话，就有把人置于上帝之上的嫌疑。这是哲学和神学史上纠结甚久的一大经典难题，相关论述俯拾皆是</p>
<p>“父啊，赦免他们！因为他们所做的，他们不晓得”</p>
<p>一个铁匠在打铁，铁块突然从炉子里面跳出来，要求铁匠一定要把它铸造成干将莫邪这样的宝剑，铁匠一定会认为这是一块不祥之铁</p>
<p>人也是一样。现在我就把天地作为大熔炉，把造化当做打铁匠，随他把我变成什么样吧</p>
<p>又或者“自由意志”这个说法本身就很成问题，就像霍布斯所论说的：“自由意志这个词就像圆四角形一样并不成立”。当然霍布斯这里所驳斥的自由是指那些“不收反对阻挠”的以外的任何自由</p>
<p>人生而为人到底是必然的还是偶然的？</p>
<p>斯宾诺莎：偶然性只是人类“无知的托词”是的，之所以我们会觉得一件事情的出现是偶然，只是因为我们缺少有效的观测手段罢了</p>
<p>康德在纯粹理性上悬置了自由意志，但是为了捍卫道德，在实践理性上不得不预设了以自由意志以作为道德的前提。但是很现实的问题是，我们的道德和法律却不能有哪怕一分钟的闲置。那么，可想而知的问题是，我们不再可以对善与恶的责任人理直气壮地加以飙涨或者谴责，法律判决会失去扎实的正义依据</p>
<p>所以，借用基督教的伦理观，我们应该憎恨罪恶本身，而不是犯下这些罪恶的人，基于这个理由，刑法的意义也就应当在于维护社会秩序，而不在于寻求公正了</p>
<p>在文明的初创状态，对陌生人进行抢劫一般都被认为是颇有光彩的事情</p>
<p>杀人如此，自杀亦然。涂尔干在《自杀论》里分析不同的社会背景对自杀者的影响，以统计数据说明，在有着极接近之文化背景的天主教，新教和犹太教社会里，新教徒的自杀比例最高</p>
<p>“宗教之所以使人避免自杀的欲望，不是因为宗教的某些特殊的理由劝告他重视自己的身体，而是因为宗教是一个社会，构成这个社会的是所有信徒所共有的，传统的，因而也是必须遵守的许多信仰和教规”。这些集体的状态越多越牢靠，宗教社会的整体化越牢固，也就越是具有预防的功效。信条和宗教仪式的细节是次要的。主要的是信条和仪式可以维持一种具有足够强度的集体生活。因为新教不像其他的教派那样稳定，所以对自杀不能起同样的节制作用。</p>
<p>假设我们抓住了一个处于杀人越货被奉为圭臬的帮会里的人，如果仅仅处于寻求公正的目的而处置他，他又该在多大程度上为自己杀人越货的行为负责呢？养成杀人越货的癖好，这在多大程度上是他自己的错呢？我们又该不该为了那些不属于他的错而惩罚他呢？在我们寻求公正的时候，是否应该向该帮会的所有成员复仇呢？尽管该帮会的其他成员丝毫不曾侵犯到我们。这样看来，株连反而比“罪止及己身”更加符合公平原则</p>
<p>彻底的个人主义者古往今来都很少见——违反了人的天然的心里定势———我们总是把自己放在群体里来认识自己的。尤其是在积极的一面，一个从未对本民族做过任何贡献的人也会欣然接受民族自豪感。人，在纯粹的世俗意义上讲，的确如马克思所说———人是“一切社会关系的总和”。那么人的社会关系该不该，又该在何等程度上，为了人的善恶承担责任呢</p>
<p>亚当斯密认为“当我们的敌人显然没有给我们造成伤害的时候，当我们认为他的行为完全合宜的时候，即处于他的情景，我们也会做出同样的事的时候，如果我们村有一点最起码的公正和正义之心的话，就不会产生任何愤恨之情了”</p>
<p>这样的话，不但我们可以毫无怨言地接受命运的任何安排，甚至可以在美学意义上悠然欣赏人间的一切的不公不义。是的，所有的人生都可以被看作是叔本华所谓的第三种悲剧。</p>
<p>叔本华——三种悲剧<br>1）总有一两种穷凶极恶的人<br>2）盲目的命运，也就是偶然和错误<br>3）仅仅是有剧中人的位置不同造成的</p>
<p>叔本华认为第三类悲剧最为可取，因为其并不是把不幸当作是一个例外，或者是什么罕见的情况，而是把它当作一种轻易的，自发的，从人的最自然的行为和性格中产生的，近乎于人的本质所必然产生的东西，这样以来不幸也就和我们距离到可怕的程度了。在这种剧里，主人公连控诉不平都做不到，因为他实在怪不了任何人。</p>
<p>在红楼梦中，由于种种原因“金玉良缘”终于胜过了“木石前盟”，又哪有蛇蝎之类的人物会从中作梗呢？比局的发生，不过就在通常的道德，通常的人情，通常的境遇之间。那么我们应该到哪里去寻求正义呢？</p>
<h1 id="原罪的两难"><a href="#原罪的两难" class="headerlink" title="原罪的两难"></a>原罪的两难</h1><p>《新约》中耶稣说人若不像小孩子便进不了神的国。渴望冲破禁忌的冲动</p>
<p>婴儿真的是纯洁无暇的吗？并不是，婴儿没有任何禁忌，他们会哭着要有害的东西，会对不顺从的大人抱以怨怼，还会充满嫉妒地对待抢奶的兄弟，可以赤裸裸地表达他所能表达的一切欲望和情绪——<strong>在这样的前提条件下，原来所有的犯罪行为现在均不构成罪恶，是社会的道德禁忌使之成为罪恶</strong></p>
<p>圣奥古斯丁在写忏悔录时回忆道，自己曾经，既不是被迫作恶，也不是无意识作恶，而是“毫无目的，为作恶而作恶”。他其实搞错了一点，他偷梨子却拿去喂猪这样的行为，包括所有人同样性质的冲动，其实并不是偷窃或者犯罪的冲动，不是追求耻辱本身的冲动，而是一种试图冲破禁忌的冲动，那渴望冲破的禁忌的冲动又是从何而来呢？</p>
<p>婴儿本身没有任何禁忌，可以赤裸裸地表达他所能表达的一切欲望和情绪。假如奥古斯丁真的恢复了一颗婴儿的心，大概不会发生这种事了，因为其不被任何禁忌所束缚，也就自然消弭了这种突破禁忌的快感，但是因之而来的是如果他在商店看见了美食，在大街上看见了美女，他应该也会毫不犹豫地作出违法的事。这样看来，杀人抢劫强奸，就像婴儿吃奶一样，本身不构成任何罪恶，是社会的道德禁忌使之成为罪恶。除非我们像奥古斯丁一样认为罪恶已经在婴儿身上充分地表现出来了</p>
<p>种种难题似乎使我们不得不求助于神祇，因为若不引入神祇的话，我们对正义的寻求也许永远禁不起刨根究底的追究。但是一旦引入神祇，我们又会陷入自由意志的两难。</p>
<p>中国的传统神祇具有和古希腊的奥林匹斯诸神一样的神人同性的特点，即不足以承担为世间贯彻正义的使命，看来只能引入至善至公并且全能的上帝，总该可以了吧</p>
<p>是的，即使在彻底的无神论者那里，看来也会热内有必要编织一种高贵的谎言，就像伏尔泰的那句名言“即使上帝不存在，我们也需要创造一个上帝，即使你只统治一个村庄”</p>
<p>上帝若是全能的话，他就不可能受限于理性，否则其行为模式就有可能会被人们推测出来。也就是说一个人或者可能积德行善而受罚，或者肯呢无缘无故而受赏，上帝的旨意完全是不可揣摩的，给人的永生与永罚完全取决于其的不测之威。</p>
<p>我国古代统治阶级的政治传统也是拥簇不测之威的，制度可以规范，赏罚可以分明，但统治者的心思不能被轻易捉摸。</p>
<p>与之对照的是，古希腊人的神明观念恰恰相反，他们迷恋几何学的秩序和简洁，相信日月星辰之所以会有规律地运行，正是因为其背后有着完美的神明意志在推动着。在这里，任意性反而被认为是不够完美的体现，不该成为神的属性。但是，随着知识的演进，我们可以越来越精确地计算出日月星辰的运动轨道</p>
<p>具有任意性的上帝怎么能说是至公的呢？这就不是人类的智慧所能所能揣度的</p>
<p>斯金纳做过许多这类实验，观察出低等动物具有和人类一样的迷信行为。此时若站在唯物主义的立场回顾费尔巴哈的那个著名论断“宗教根源于人和动物的本质区别：动物没有宗教”。那么，任何一颗多愁善感的心都难免会泛起一丝悲哀</p>
<p>那么在信仰的表达上，风雨晦冥，生老病死愈是无法把握，生活的不可控感越强，祭祀和崇拜也就越是程序化，所以对于那些希望以宗教信仰来维护社会公平的主张者来说，这是一个难解的悖论，宗教信仰可以维护社会稳定，但难以追求社会公平。</p>
<p>所以，在神学政治里，对公平的追求有必要寄托在彼岸世界。用奥古斯丁的话来说，如果现实世界报应不爽，那么岂不是没有了最终审判的必要？当我们在现实世界中看到好人歹命，恶人富贵无边，这只是我们人类眼中的不公，神却不一定这么想，他的安排一定有他自己的道理，否则岂不是可以被人的浅薄心智加以测度了吗？</p>
<p>核心就是，天威难测</p>
<h1 id="康德的失误"><a href="#康德的失误" class="headerlink" title="康德的失误"></a>康德的失误</h1><p>种种关于正义的理论都在刨根论底的追问之下都显出了或多或少的尴尬，也许我们该换个思路，从现有的道德秩序入手，在各个国家和民族当中找出那些最基本的普世共同遵守的规则(正义的公约数)。这些规则不应该是一些具体的目标（譬如敬神，守信，助人为乐），而最好是某些抽象的公式（譬如康德的绝对律令，米塞斯的行为通则，罗尔斯的无知之幕）</p>
<p>“已所不欲，勿施于人”应当是一项很好的准则了，但是实际情况并不这么简单。臧洪杀掉爱妾给守城卫士吃肉，我们可以对他发出这样的质问。但是臧洪是当时著名的“天下义士”，是天下人的道德楷模，赞美他敬仰他得人也不乏知书达理，大义凛然的一时俊彦，她们又怎么会不晓得这句孔夫子亲口教导的至理名言呢</p>
<p>他们当然晓得这个道理，但理由有二 1）身份有别 2）仁善也是有等级的</p>
<p>己所不欲，勿施于人本身也不是一个纯粹的公式，而是在其他若干正义原则之下伴随进行的，而想要彻底驱除这些干扰——<strong>康德的纯粹实践理性的基本法则</strong>——“要这样行动，使得你的意志的准则任何时候都能同时被看作一个普遍立法的原则”</p>
<p>为了给自己寻找一个最简单的，最可靠的办法来回答不兑现的诺言是否合乎责任的问题，我只需问自己，我是否也愿意把这个通过假诺言而解脱自己困境的准则变成一条普遍规律，我是否愿意这么说，在处境困难而找不到其他解决办法时，每个人都可以作假诺言？虽然我愿意说谎，但是我也不愿意变成一条普遍的准则，因为这样做会反过来毁了这个准则</p>
<p>但是这一个纯粹的实践理性的基本法则也引来过一些相当棘手的问题。譬如你受托保管别人的财产，你改不改中饱私囊呢？应用定言令式的话，如果所有受托保管别人财产的人都去贪污，也就不会有任何人委托他人保管财产了，贪污这个规则也就自我毁灭掉了。但是，这个论证是以私有产权为前提的，如果换到公有制下，委托的财产就算被贪污了，委托人还是有可能继续招人委托财产，因为财产不是自己的</p>
<p>骗人不一定就是假话，也可能是用真话骗人</p>
<p>放弃了对主观性的辨析而走上了寻找客观性的普遍规律之路，这应当是康德的一大失误。</p>
<p>上帝在洪水之后说“凡活着的东西，都可以作为你们的食物，这一切我都赐予你们，如同菜蔬一样”</p>
<p>幸福概念所包含的因素全部都是经验的，它们必须从经验中借来。幸福并不是个理性概念，而是想象的产物</p>
<p>有一个学生在听普及里的的讲学之后问到，学几何学有什么好处？于是欧几里得叫进来一个奴隶“去拿三分钱给这个青年，因为他一定要从他所学到的东西里得到好处”</p>
<p>古希腊伟大的戏剧家欧里庇得斯——继承了大量的遗产买了大量的书，整天在自己家里埋头看书，很少参加公共事务，他虽然因为戏剧成就而被我们铭记至今，但这对于他而言，只是一个美丽的副产品罢了——更何况，如果他不曾创造任何一部戏剧，难道就有什么被人指责的地方吗？更为吊诡的是假如他积极上进，反而伤害了其他人的利益，资源永远是有限的</p>
<p>我们再假定这个孩子具有超长的音乐天赋，即便不加以任何培养，也会成为一个比古往今来的所有的音乐家更加耀眼的人物，但是在看漫画书和展示音乐才华之间，他选择了前者，这可能伤害到谁吗？显然不会，只需要父母多付出一些辛苦，但只要父母出于爱心甘愿付出更多的努力，这也就没什么再可挑剔的了</p>
<p>再者，严格来说，看漫画同样为社会做了贡献，因为这会为漫画的事业发展提供动力，除了对漫画的作者提供经济福利之外，还让他们体会到了被人认同的快感。</p>
<p>这时，我们不妨参考一下哈耶克提出的几个问题”职业网球选手，同那些将时间用于改进这些运动的富有的业余爱好者相比，难道就真的那么显然是对社会的更优作用的成员吗“</p>
<blockquote>
<p>穆勒：我们不能认为仅仅因为这一点，即对他人的利益造成或显或隐的损害，就足以称为社会干涉的正当理由，更不能认为这样的干涉永远都是正当的，在许多情况下，一个人在合法手段追求某个合法目标的时候，难免会造成其他人的痛苦或损失，也难免会截夺了其他人应当享有的好处。这种发生在个人利益之间的冲突通常是由糟糕的社会制度引起的，只要制度不变，冲突便不可避免。我们认为正常的情况下这种竞争是利于社会进步的，只有当这些人采取了不正当的手段，社会才该出面干涉</p>
<p>但也有一些利益冲突是在任何体制下都会发生的：一个人无论是谋得了一份热门职业，还是通过了一场严苛的考试，只要他是在竞争性的资源中超过了对方，他就是从别人的损失，失望以及白白浪费掉的汗水当中收获了自己的利益</p>
<p>但是人们普遍都会承认，为了促进人类的普遍利益，这种事情不该成为我们前进道路上的障碍。换句话说，社会并不认为那些在竞争中不幸落败的人在法律上有任何免于痛苦的权利，而只要当人们用上了一些不被普遍利益所允许的手段——譬如欺诈，背信弃义或者强迫——来获取成功的时候，社会这才应该出面干涉</p>
</blockquote>
<p>在穆勒的观念里，自由原则一方面以”不损害他人利益“作为唯一的行为准则，一方面又承认了基于这一准则的行为难免会损害他人利益，尽管这种损害是”正当“的。这的确是一个功利主义者眼中的自由原则，后者意义上的损害之所以正当，是因为”为了促进人类的普遍利益“。但如果我们继续追问下去的话，什么是人类的普遍利益呢，这只会得到见仁见智的答案</p>
<p>事实上，我们只要稍微多想一想，就会自然地站到康德的对里面去，因为康德的这番道理在相当程度上剥夺了个人选择的自由，而且通不过他自己给的定言令式的考核</p>
<p>即有所追求，也有能力去完成自己的追求，这应该是很多人对生活的完美期冀。</p>
<p>人们不可以不劳而获，或者说不劳而获是可耻的，但是享受遗产，这到底有什么不道德可言呢？    </p>
<p>现在，我们可以假想端木叔是一个天资聪颖的人，只要他肯参加工作，他一定能成为第一流的政治家，第一流的工程师或者第一流的税收，但一个人仅仅因为拥有某一方面的特长就必须发挥这一特长吗，无论他有没有更想要的生活？如果按照康德的论述，一个人的天资或者特长尽管有可能成为他的幸福生活的源泉，但同样有可能成为他无法追求自己想要的生活的束缚</p>
<p>康德的伦理学是一种“责任伦理学”，认为道德价值与幸福无关，而仅仅在于履行责任。那么，一个天然的利他主义者，一个会从助人为乐当中体会到快感的人，他处于“爱和同情”而做的事情没有任何道德权重，而仅仅是一种爱好罢了，就像对荣誉的热爱一样</p>
<p>事实上，任何一种经过理性的审慎权衡而得到履行的责任，都是一种票号，一种情感上的偏好，因而也都是逐利的————换句话说，是追求幸福的，而道德价值与幸福无关的说法是不可能成立的。康德的谬误就在于把道德当做了理性问题，而道德本该是情感范畴的。</p>
<p>孟子的舍生取义和秦桧的舍义取生尽管表现形式完全相反，但只要满足理性，资源的前提，那么就可以说他们都是趋利的。这既是广义的利益，也是真实的利益，只有这种意义上的利益才能够真正增进人们的福祉。相反，GDP的数字与人的福祉不存在任何直接关系</p>
<blockquote>
<p>是的，无论是物质财富，还是精神财富，到底”值多少钱“，仅仅取决于我们有多么看重它们</p>
</blockquote>
<blockquote>
<p>那么，只要我们认可利益／幸福的主观性，认可理性的审慎抉择意味着对不同程度的利益／幸福的权衡与取舍，也就会在任何一种哪怕声称与利益或者幸福全然无关的正义理论里发现利益或者幸福的踪迹，那么我们就会越过诸多大能，回溯到一种相当古老正义理论，这是一种相当刺耳，相当为人所不齿的理论——正义，就是强者的利益</p>
</blockquote>
<h1 id="正义的两个来源：强者的利益与人性的同情"><a href="#正义的两个来源：强者的利益与人性的同情" class="headerlink" title="正义的两个来源：强者的利益与人性的同情"></a>正义的两个来源：强者的利益与人性的同情</h1><p>刘备杀张裕：谁碍着我的事，我就除掉谁</p>
<p>卧榻之侧，岂容他人鼾睡？宋太祖赵匡胤的名言，彻底揭下了虚伪的面纱——人的欲望是无穷无尽的，不知满足是人的天性——实际上只是人的装腔作势罢了——贪婪是生物进化的必然本性。骆驼的驼峰若是只能储存一天的用水，它就应付不了沙漠的环境，也许对于现在的生活环境来说，骆驼只需要一周的储水量，但是谁也不知道未来会发生什么变故。这就像2012中揭示的残酷性，如果环境不发生任何变化，那么知足常乐的人也会很好地生存下去，而且一旦灾变来临，只有那些最有权势，最有财富的人才有最有幸存的机会。</p>
<p>我们永远也不知道明天会发生什么，所一般来说，储备资源的能力越强，幸存的概率越高。除非我们像圣经里讲得那样得到上帝的承诺，不必为明天储备，否则我们就总会在自己的能力范围内尽可能多地储存一些，以备不时之需，就像幸存到今天的所有生物都会做的那样</p>
<p>这是一个生物性的事实，不带有任何道德意义，只有当来自不同社会习俗的我们戴着不同的道德眼镜来看待,它才会显示出不同的道德性状</p>
<p>譬如一个正常的男人，他对自己的妻子是爱欲，对别人的妻子是淫欲，在生物性的角度上看其实是一个东西，只是我们的婚姻制度界分出了这两种截然相反的道德概念</p>
<p>人们不愿意接受这个残酷的真相，总希望爱欲和淫欲“在事实上”而不仅仅在道德上是不一样的东西——于是辛苦构思出许多深奥繁复的哲学义理与似是而非的心灵鸡汤。天理和人欲之辩就是最著名的一例。</p>
<p>人欲和天理不过是同一回事，关键是要把握分寸</p>
<p>侵略问题是贪求的一种高端形式——分寸问题也会相应地更加敏感和复杂——古代的开疆拓土普遍被认为是一种激荡人心的荣誉，无不让人心弛神往，似乎一点也没有让人难以感到其中不妥</p>
<p>现代心理学关于从众现象的大量研究告诉我们，只要善于利用从众心理，那么颠倒黑白，指鹿为马实在是再容易不过的事，事实上这也正是极权政府常作的事。而最能动摇这种丛中的稳定局面的，莫过于个别强硬的少数派的出现，所以这这种“星星之火”必须被扼杀在萌芽中。</p>
<p>钱钟书批评老子所谓师法天地自然，不过是借天地自然来比喻罢了。这种出位的异想，旁通的岐径，在写作上叫做寓言，在逻辑学上叫做类比，可以晓谕，不能证实，更不能作为思辨的根据。</p>
<p>师法草木就可以吗？“松柏之下，草木不殖”，“种豆南山下，草盛豆苗稀”。可见草木为了争夺空间也不手软，其强硬程度不减鸟兽鱼虫。如果圣人看到了这个现象，恐怕就算取法草木，也不会去学草木的”柔脆“吧</p>
<p>以今人的智慧，会晓得自然界的和谐状态是亿万年残酷血腥的生存竞争中所达成的一种动态的平衡，狼还是会吃羊，狮子还是会以爪牙捍卫自己的神圣领地，人类也从来不曾爱人如己。如果人类的政治当真需要效仿自然法律，那么弥罗斯人在雅典使者面前也就无话可说了</p>
<p>然而更为严峻的问题是，这一规律在人类社会里确确实实地存在着，并且是作为一种”自然“规律根深蒂固，难以磨灭地存在着，这才是正义理论所要面对的真实预设质疑，而不是那些美丽而虚幻的独立，自由和平等</p>
<blockquote>
<p>荀子在两千多年前隐约地捕捉到了问题的真谛————其时他思考礼的来源，得出了如下的结论：”人生而是有欲望的，当欲望得不到满足的时候，人必定会追求满足，当这周追求超过了一定的限度时，就必定会产生纠纷，纠纷带来混乱，混乱带来耗竭，古代君王憎恨这种混乱，所以制定礼义来设置限度，在限度之内满足人的欲望“。当然，礼义的制定并不是古代君王的个人行为，但重要的是荀子的前半段话，它使我们知道，礼义源自博弈道德源自欲望，而所谓的限度或者分寸并非任何一种自然现实，而只是博弈中变动不居的疆界，并且当地球上只有一个人的时候，是不产生任何道德问题的</p>
<p>（这段话语言凝练精辟，真的是很了不起）</p>
</blockquote>
<p>正义的标准是以同等的强迫力量为基础的——强者能做它们有权利做的一切事，弱者只能接受——在强弱悬殊的关系中是远远谈不上什么正义的</p>
<blockquote>
<p>首先我们可以确立现阶段生物的首要原则是尽可能地掠夺资源为己所用，因为不这么做的全部被自然淘汰了。人们说做不正义的事是利，遭受不正义是害，遭受不正义的害超过不正义所得到的利，所以人们在彼此交往的过程中两者都承受过，那些不能做到只尝甜头不吃苦头的人，觉得大家最好成立契约，既不要不正义之利，也不受不正义之害，从这时开始才开始制定法律签订契约</p>
<p>它们把守法践约叫做合法的，正义的，这就是正义的本质和起源。正义的本质就是最好和最坏的折衷——所谓最好，就是干了坏事而不受惩罚，所谓最坏就是受了罪而没法报复，正义是两者之衷，它之所以被大家所接受，不是因为本身真正善，只是因为这些人没有力量去干不正义，任何一个真正有力量作恶的人是绝对不去签订契约的。当然这也不一定就是说他们一定会作恶，只是说他们不会按照人们惯常的思路去行事。</p>
<p>woc，突然想到这种情况推衍到极致，不正是上帝的”天威难测“吗？这么说关于正义的推论研究到了最后，反而成为了有神论的一个有力支持</p>
<p>那些做正义事的人并不是出于心甘情愿，而仅仅是因为没有本事做恶——开始思考我们这些所谓的人类原则的本质——比如说你是个农民，你去收庄稼的时候，蔬菜告诉你让你按照它们的规则，不允许你去杀它们，你肯定会想这tm不是搞笑吗？——为什么，还不是因为力量太过悬殊</p>
</blockquote>
<p>在强弱悬殊的关系里是谈不上正义的，一切遵循自然法则。人的智力和体能都远胜于鸡鸭，所以除非受到某些特殊的宗教禁忌的限制，否则人吃鸡鸭是谈不上任何不正义的罪恶感的，人类天然认为自己对鸡鸭拥有生杀予夺的权柄。上帝之于人类，其悬殊远大于人类之与鸡鸭。所以虔诚的信徒不会斗胆向上帝要求公平</p>
<p>让我们对照一下洛克对财产权的经典描述：谁在树下捡到的橡实，谁就已经确认把他们拨归己用。假如那颗橡实也有智慧的话，大概不会认可这种理论，无神论者大概也不会认同父母对自己的所有权。那么，仅仅因为创造，或者因为创造和救赎，就可以顺理成章地使上帝“有权拥有以色列人”吗</p>
<p>权利导致腐败，绝对权力导致绝对腐败。在强弱悬殊的关系中，强者对弱者理所当然地拥有绝对权力，那么除了至公至善的上帝，任何强者的绝对腐败都是可以预期的了。在强弱悬殊的关系中，强者对弱者的”绝对腐败“在强者看来往往并不是恶，而是理所当然的事情。譬如在柏拉图和亚里士多德这般卓然的智者看来，有些人天生就该是做奴隶的，他们和家畜只有极其微小的区别。在强弱悬殊的时候，”绝对服从“甚至会被服从者被自己看作是一种可歌可泣的崇高品德（单指对上帝）</p>
<p>因为与世俗伦理的巨大冲撞，亚伯拉罕问题引发出了许许多多的神学辩论。人们总是试图调和世俗的伦理与超世俗的信仰，但是，几乎任何一种调和之论都会导致新的两难境况</p>
<p>譬如，如果说亚伯拉罕相信上帝的至善至公，于是推断上帝肯定不会做出让自己杀掉亲生儿子的事情。那么，这么一来意味着亚伯拉罕的献祭仅仅是一种装模作样，因此他不配义人这个称号。而来意味着上帝始终依据理性原则办事，这然就抹杀了上帝行事的任意性，也就抹杀了恩典的意义</p>
<p>再说，如果亚伯拉罕寄希望于儿子以撒因献祭牺牲而获得天堂的永生，那么这一来与《旧约》的普遍观念违背，而来意味着以撒之死不仅不是损失，反而是某种甚大的利益，那么所谓对亚伯拉罕的考研也就无从谈起了</p>
<p>上帝要求人的绝对服从，而在另外一种强弱悬殊的关系里，人也要求狗的绝对服从。虔诚是人对上帝的美德。虔诚是人对上帝的美德，忠诚是狗对人的美德。人若是与上帝势均力敌，亚伯拉罕就会成为同胞们的笑柄，狗若拥有了人一般的智力，恐怕也会向主人造反。</p>
<blockquote>
<p>是的，只有当强弱对比缩小的时候，博弈才会产生，各自争取各自的利益，在反复磨合之后终于达到某种程度的妥协，所谓的天赋人权从来都不是天然存在的，而是在这样的博弈过程中艰难争取来的。这样的关系正是正义的一大基础，亦即将他人或多或少地当做对等的人加以看待，契约观念正是由此产生的</p>
</blockquote>
<p>上帝是无求于人的，并且上帝与人强弱悬殊，所以上帝与人签订契约是出于自然的恩典，然而在世俗领域，这样的契约是不可想象的。道理正如格劳孔所说“任何一个真正有力量作恶的人绝对不会愿意和别人签订什么契约，答应既不害人也不受害——除非他疯了”</p>
<p>格孔劳言语中的所谓的作恶，是站在旁观者的角度而言的。而在立约的双方，没道理觉得自己作恶的。所谓的恶只在对等者之间存在，亦即先有了对等身份的人士，而后才有对恶的评估。和鸡鸭，奴隶，夷狄讲正义，这是无比荒谬的</p>
<p>正义的核心是公平，而公平必然意味着对等，不对等则无公平可言。譬如奉行“己所不欲勿施于人”的儒家为什么没有设身处地地为女人想想，为什么要剥夺她们参政的权利</p>
<p>这在儒家人士眼中看来无比荒谬，女人当然没有参政的权利，因为牝鸡无晨，男女各有天知，这是自然秩序。亚里士多德也有同样的古老智慧，他认为灵魂在本质上含有两种要素，一为主导，一为附从，前者表现为理性，后者表现为非理性。这两种要素在不同的灵魂中有不同的组合，所以有些人天生就该成为统治者，有些人天生就应该成为从属者，奴隶完全没有理性，女人和儿童有不多的理性。这一类理论被称为，<strong>合法性神话</strong>，是由是群体为巩固自己的优势地位而编造出来的。</p>
<blockquote>
<p>但是合法性神话的创造者和鼓吹者也不一定都是骗子，也不乏孔子和亚里士多德这样饱含真诚的智者。如果我们不是站在较晚以及较新的道德立场来回望他们的话，我们很可能也会发自肺腑地赞同他们的道理。</p>
</blockquote>
<p>平等从来都只是平等者内部的平等。相应的，公平也只是平等者内部的公平，尽管平等者的范围会世易时移</p>
<p>譬如洛克在1690年出版的《政府论》，至今仍是西方政治体制的重要理论基石之一，书中论述人是自由平等和独立的吗任何人不得侵害他人的生命健康自由或财产。他的推理过程是这样的：人是上帝的造物，上帝既然赋予人们同样的能力，使人们在同一个自然社会里共享一切，那么人只能从属于上帝，而彼此之间不能有任何的从属关系。</p>
<p>在洛克的眼中，我们都是高等动物，不该彼此利用，但低等动物因其比我们低等，所以我们有权利用它们，上帝对我们也是同理</p>
<p>亚里士多德：虽然正义就是平等，但是这个平等要分为“数量平等”和“比值相等”，不同人的权重是不一样的。穆勒都认为：在一个民主社会里，知识精英应该比平等大众享有更多的投票权，而不应该只是简单的一人一票。</p>
<p>所以我们才会看到，女人不是与我对等的人，所以我所不欲的可以施于女人，同理适用于奴隶。己所不欲勿施于人甚至算不上一种被社群主义支持的共同体内部的伦理标准，但只是阶层内部的伦理标准罢了。一个人想要获得这样的伦理待遇，就有必要先使自己成为该阶层的人。</p>
<p>如果我们认同弱国无外交，那么我们也很难否认在人际关系中“弱者无伦理”</p>
<p>在这样的情形下，假若一个学习过康德哲学的如家人事正在考虑要不要阻止一位女性参与政务，他会应用的定言令式不会是“我是否愿意使禁止他人参政成为一条普遍规律”，而会是“我是否愿意使禁止女性参政成为一条普遍规律”。我们当然可以责备他忽视了“人人平等”这个前提，但他也有十足的理由反驳我们“男主内，女主外，这毫无不平等可言，有些事只是两性不同的天职使然，如果我是女人，我也甘愿大门不出，二门不迈地相夫教子。难道你认为让乌龟和兔子赛跑，让猫和牛一起拉犁才是公平的吗？”</p>
<p>事实上，今天我们执行那些保障妇女，儿童权益的法案正是基于同样的理由，只是程度不同罢了。我们不会认为在重体力劳动领域让女人和男人同工同酬是公平的。而古人基于他们当时的认知，认为女人不适合参政也是看上去无可厚非的。即使今天以纯科学的眼光来看，男人三妻四妾也是最适合基因复制的，男人花心而女人专一这实在是基因使然，而一夫一妻是文明化的结果，是从前作为弱者的女人一步步从男权世界里争取而来的。</p>
<p>诚然，只有当我们有了对等的意识，才有可能向对方争取权利，当然我们也可以期待恩典，慈悲，怜悯，施舍，正如漫长历史中老百姓对君王的期待那样</p>
<p>公正除了建立在身份对等这个前提下，还有其天然的社会原因和心理原因。正义的观念，一方面从社会本能，一方面从平等的观念中产生</p>
<p>平等的观念来源于其对立面“不平等”，我们只有在不平等的状态下才会呼吁平等。</p>
<p>“公正”除了建立在“身份对等”这个前提智商，还有其天然的社会原因和心理原因。所谓天然的社会原因，看上去是一个自相矛盾的概念，实则我是用这个概念来指称群居动物在自然状态下所特有的生物性</p>
<p>卢梭《论人类不平等的起源和基础》“谁第一个把一块土地圈起来并且想到说：这是我的，并且找到一些头脑十分简单的人居然相信了他的话，谁就是文明社会的真正奠基者”收到了后来的马克思主义者们的大肆赞扬</p>
<p>如果仅仅从其对私有制的比喻意义来看的话，这一观点还算有几分道理，但是，如果我们就文本本身加以理解的话，借助卢梭所不曾学习过的现代学术，我们反而会发现，这与其说是“人类不平等的起源”，不如说恰恰就反应了人类天然的关于平等的心理机制。仍然是蒲普东切中了问题的要害：正义观念一方面从社会本能，另一方面从平等的概念中产生</p>
<p>平等的概念来源于它的对立面，即不平等。不是因为平等状态被打破了而产生了不平等，而是因为有些人出于对不平等状态的不满而产生了对平等的幻想。“不平等”是一种天然的生物秩序，</p>
<p>在群居动物的社会生活里，所有权是必然存在的，否则的话，群体生活便无法想象。在逻辑上，只有率先拥有了“所有权”，才会接踵而来“公平”的问题，无所玉泉则无所谓公平的问题。只要某种资源是稀缺的，就必定会存在所有权的问题，也就相应地存在公平问题。资源的稀缺性必定导致竞争，公平总是在这种博弈的过程中艰难地争取来的</p>
<p>但这个说法看上去会被一种普遍存在的现象所颠覆————人类是充满同情心的，这正是公平的一种心理基础</p>
<p>同情心似乎是与生俱来的，孟子“恻隐之心”。在同情心上我们似乎看到了所谓天良，即先天具有的良知。但首先要澄清的是，所有的先天禀赋都不具有道德属性，在道德上是中性的。无论我们说人性善，性恶，都是以后天的道德观念来评价先天的生物性禀赋。这种评价总是缺乏一致性，譬如我们总鄙视对金钱的贪欲，推崇对知识的贪欲。佛法首推戒贪，但是不懈的追求佛法难道不是一种更大的贪婪吗？</p>
<p>费希特很好地为我们揭示了同情心的作用范围，这似乎有点不可思议看上去明明更值得同情的人，远远更加值得同情的人，反而得不到同情，这是怎样的心理机制使然呢</p>
<p>人的同情心是如此不同。当然人们的同情心也有可能会拓展到所有的人，但肯定不会对所有的人都一视同仁，而是对本群体的人给予的同情最多，对那些最远离本群体的人给予的同情最少，这也正是中国儒家的仁学所讲的“爱有等差”的道理。</p>
<p>道德标准的形成阶段（不可跨越的）<br>1）小孩子判断一件事是非取决于事后是否会被打<br>2）自我中心开始形成，判断是非的依据就是单纯的个人好恶<br>3）开始重视别人的态度和利益，能让别人开心也是好事<br>4）有了责任和义务的意识，乐于维护现有的社会秩序和法律规范<br>5）承认社会上既有合法不合情理的事，也有完全相反的<br>6）良知完全驾驭于任何社会习俗和法律法规之上</p>
<p>至于圈内人偏袒效应，正是我们每个人再熟悉不过的，所谓集体荣誉感，爱国主义，心理机制上的根源都在这里。在普世范围内，多数人都会认为爱国主义是一种美德，许多国家的人都为自己的国家而感到自豪</p>
<p>但是爱国主义的理由并不总是像我们想象的那样伟大，随机找来一群人，随机分为两组，爱国主义就会自然产生。</p>
<p>一个更加有趣的现象是，在利益受到威胁时，人们对本群体利益的敏感程度甚至会高于对个人利益的敏感程度。精明的政客都会知道，如果想要煽动群众，苦口婆心地去描述后者作为个人将会遭受的不公正待遇，其效果明显不如去描述其作为一个群体将会遭受的不公正待遇</p>
<p>这种“神圣而又必然的复仇法则”————如果我们将斯密的神仅仅视作一种修辞手法的话，那么这就意味着人类的一种天然的心理机制了。这样的同情心，如果我们有能力将之完全实现的话，无疑是会相当快慰的。普通人缺乏这样的能力，所以这种快慰往往只是属于超人或剑侠的，也就是说，存在于大众心理期待的投影中</p>
<p>通俗文学之所以流行，一个必不可少的因素就是要以最直接的手法来迎合大众心理的普遍诉求，让读者不假思索地欣然接受（这同样也是通俗文学之所以不是“高雅艺术”的一个重要原因）</p>
<p>是的，在今天这样一个文明程度如此之高德时代，我们心中的复仇法则依然“神圣而又必然”。如果舍弃了这一点而奢谈正义，就将会遭遇所有违背人性的美好理论所遭遇过的那种困难</p>
<h1 id="人的真实与必然的处境：不自由，不独立，不平等"><a href="#人的真实与必然的处境：不自由，不独立，不平等" class="headerlink" title="人的真实与必然的处境：不自由，不独立，不平等"></a>人的真实与必然的处境：不自由，不独立，不平等</h1><p>人类的上述心理特质尽管与崇高无缘，却可以从社会生物学的角度得到相当有说服力的解释：这会使人类更好地适于群居生活，从而在大自然严酷的生存竞争中幸存下来</p>
<p>相比野兽而言，人类没有任何的优越性可言，没有锋利的牙齿和尖锐的爪子。《列子杨朱》认为人的核心竞争力在于智慧，亦即“任智而不恃力”。《吕氏春秋·恃君》认为关键在于人类可以群居</p>
<p>亚里士多德认为：我们具有发达的语言机能——所以能比其他群居动物所能结成的团体达到更高的政治组织形式。人类所不同于其他动物的特性就自于他对善恶和是否合乎正义或其他类似观念的辨认，人类超长的语言能力造就了超常的群体协作能力。但只要存在群体生活，就会出现社会分层。这一个事实会使我们队那种自启蒙时代以来就流行于世的某种论调感到困惑，譬如洛克的“人类天生都是自由，平等和独立的”是迄今以来的许多争议理论的基本预设</p>
<p>但是，如果我们认可人类是一种群居动物的话，那么看看我们的同伴，亦即其他的群居动物，无论是狼群还是猴群，我们都观察到了太多的等级秩序</p>
<p>事实上，那些未经人事的小孩只要彼此接触过之后，也会自然形成一些规则，形成了简单的社会规范。</p>
<p>一个集体的形成，个人一般都会表现出自己对群体的价值，既然每个人的能力，偏好，热心程度不同，对群体的贡献也不同，地位分化也不一样“。而小群体扩大以后，就会形成复杂的分层系统。法出于礼，礼处于俗”</p>
<p>作为群居动物的人类，自从出生之后就生活在一个分层井然的社会秩序中，不是作为个体，而是作为社会网络中的一个节点而存在的，不独立，不自由，不平等。</p>
<p>这里只有“自由”的概念需要稍加辨析，因为自由在哲学的历史上，从来都是一个充满歧见，飘忽不定的神秘字眼。人们往往会把五花八门的概念理所当然地归于自由或者自由主义的名下。简而言之，自由是一种不受他人武断意志的强制的状态。“一个生活在人群中的人，只能希望逐渐接近这种状态，而不能完全接近它”。因此“一个自由政策尽管不能完全消灭强制及其恶果，但是应该尽量将其缩小至最低限度”</p>
<p>自由是强制的对立面，只要一个人的行动是不被强制的，他就是自由的</p>
<p>这的确是一种相当精到的描述，也是一种如此美好的期待，一种值得人们为之努力的方向。但当我们将实现从未来转向过去的时候，不得不承认即便是这种强制减到最低限度的自由，在人类的自由状态下也是存在的。也就是说，我们这里所考察的所谓“天赋人权”的种种内涵————独立，自由，平等————都不是人类天然具有的，反而是不独立，不自由，不平等的层级秩序才真的称得上“天赋”</p>
<p>在一个集体情境之中，权利的分化引出了两种不同的力量，一个是有助于把群体推向努力方向一致，另一种是否认现有权利的合法性，促进反抗和分裂</p>
<p>社会契约论——就民主这个词的严格意义而言，“真正的民主制从来就不曾有过，而且永远也不会有，多数人统治而少数人被统治，那是违反自然的秩序的”</p>
<blockquote>
<p>自然秩序本身不具有任何道德意义，也就是说，少数人统治多数人，甚至一个人奴役所有人，在自然秩序的层次上讲，既无所为善，也无所谓恶，一切的道德评价都是我们给予任何“现行的”道德标准所做的衡量标准。</p>
</blockquote>
<p>但是我们有信心坚持自己的正确性吗？——巴厘岛的居民们相信让三位王妃蹈火殉夫是再正常不过的，有的基督徒认为无条件服从上级是基督徒的重要美德。道德的准绳是如此的世异时移，几百年后的我们看我们现在的坚持会不会就像今天的我们看80年代的巴厘岛人呢？</p>
<p>当我们以为坚守了良知的时候，我们到底在坚守什么？道德准绳是如此的世异时移，以至于我们不由得设想：几百年的人们看我们今天的坚持，会不会就像我们今天看上个世纪的人们一样呢？</p>
<p>就人类的天性而言，独立自主自由的预设是统统站不住的——人类实际上追求的是两种：对独立自由平等的追求，另一个是对奴役，被主宰，和不平等的追求。究其原因，就是人类对稳定性或确定性的需要以及嫉妒心的作用。</p>
<p>人的天性是喜欢稳定而厌恶改变的——<strong>一个人面临的选择越多，维持现状的吸引力就越大
</strong></p>
<p>举一个例子来看，为什么这么多的人会对历史的翻案文章深恶痛绝呢？这些人还总是乐于怀疑文章作者到底是何等居心？许多人肯定会讲岳飞现在已经是我们民族精神的象征了，是一个激励着一代代人的精神符号，即使真有什么新材料出现，搞这种研究有什么意义呢？难不成要把我们的英雄一个个地毁去？</p>
<p>历史学家的心里往往装着一些不确定的只是，具有确定性的只是某种方法论罢了。这就导致了他们心里的那种不确定性要比普通人更强，但他们可以较好地承受这种不确定性，这是多年来的专业训练的结果，是普通人并不具备的。</p>
<p>但是，若其他条件相同，普通人对幸福的感受必定比这位历史学家更强，也更轻易，因为所谓的心理陷阱，其实只在少数的时候才对人们的决策产生负面的影响</p>
<p>儒家的理想圣君周文王有一种特殊的新闻模式，即“不识不知，顺帝之则”，不去想，不去懂，完全按照天帝给出的准则办事，因此而深得天帝的赏识。这仿佛是《旧约》中义人模式的翻版，但只有当一个人陷入严重的惶恐不安的时候，才会晓得这是一种何等值得企慕的心灵高度</p>
<p>当生活中面临一些重要决策时，如何消除不确定性就会变成相当严峻的问题</p>
<p>对选择的恐惧，对不确定性地恐惧，是人类与生俱来的心理机制。宗教————如果站在无神论者的立场————不是起源于无知，而是起源于对不确定性的恐慌</p>
<blockquote>
<p>论证是否严密从来不是问题的关键，人们只是需要更加赏心悦目的理论罢了</p>
</blockquote>
<p>人类有两种方法来缓解这种由不确定性带来的恐慌：宗教和信念。宗教在社会功能上的最本质的意义是通过特定的仪式行为来提高群体凝聚力，即把个体更好地融入集体之中</p>
<p>幸福这种事只有盖棺才能定论，命运是如此的诡谲难料，确定性对于人类来说实在是稀缺的资源。“当一个有福的人还没有死的时候，切不要说他是幸福的”</p>
<p>或许可以由此推论的是，从消极的一面来看，对于一切为臻成熟阶段的民族，专制政府是一种正当的统治形式————这是穆勒的意见，显然他不把自己理想中的自由主义原则当做一种普世性的原则。所以穆勒才会支持殖民主义，支持英国人对东方民族的统治。看来殖民主义与民族主义虽然看上去处于对立的两极，实则观念的根源却大有共通之处</p>
<p>从积极的一面来看，在道德意义上，父家长制未必尽如自由主义者所见的那般卑劣。君长爱民如子固然有很温情脉脉的一面，人民尊君长为父也并非一定对不起膝盖和脊梁。宋儒曾把君主官吏和百姓的关系比作父母，保姆和子女的关系，假定这一类比不曾有任何失实的话，那么敬爱并服从于保姆和父母在人格上的确不失尊严。</p>
<p>可资参考的事，新渡户稻造在《武士道》提出专制和父权政治是有区别的：“在前者的情况下，人民只是勉勉强强服从，反之，在后者的情况下，则是带着自豪的归顺，保持着尊严的顺从，在隶服中也是满心怀着高度自由的精神的服从”</p>
<p>但必须承认的是，服从确实可以无妨于自豪和尊严————对宗教有基本常识的人都不会否认这一点</p>
<p>无论存在着多少的龃龉和争议，至少人们更愿意相信“道”是永恒不变的，非认识主义的伦理立场————即认为道德问题不是事实问题而是态度问题。尽管在学术上可能是正确的，但绝对不会是普罗大众所喜闻乐见的。那么，在单纯心灵的想象中，永恒不变的道当然不应该仅仅是一种地方性知识，而是放之四海皆准的真理。</p>
<p>对于今人而言，由此可以想到的是，作为一切伦理和政治哲学之根底的基本人性应当是普世共通的，文化则属于地方性知识。那么，人性基础和文化基础，哪一个才是最基础的根底呢？</p>
<p>这应该是一个不难回答的问题，所以我们必须考虑这样一个基本事项：同样作为人类的成员，东方人和西方人在心理机制上并无二致。那么，我们对父家长制有一种由衷的向往，西方人其实是也存在同样的向往，只是表现形式不同罢了</p>
<p>道理一望便知，因为他们也会面对同样的不确定性的问题。东西方的差异只是层级观念的差异，一个是在上帝面前人人独立自由平等，一个是在父家长面前人人独立自由平等</p>
<p>我们发现完全无法在事实上反驳“正义就是强者的利益”。这也就意味着，弱者如果想要获得强者的利益，只能让自己变成强者，和之前的强者成为身份对等的人，在身份对等的情况下追求公平。独立自由和平等都不是人性的预设，不应该成为任何正义理论的预设，反而是正义理论应该追求的目标。</p>
<pre><code>这才是问题最难解的地方，因为对于人类的生活来说，如果正义本身是‘作为公平的争议’，那么公平本身并不是人类生活所需要追求的终极目标——生活的幸福感才是终极目标，公平而是达到这一目的的手段。然而这些手段必然会带来一些人们根本不想要的东西，譬如未选择承担责任或根本无力选择，以及无所适从感，生活的不确定性的加剧，缺乏终极的心里皈依
</code></pre><p>换句话说，人类天生就是有奴性的，在心底总是敏感而脆弱的，对公平的追求总是难以一贯而之。从这种意义上来说，即使对公平的度量可以完全借助于精确的数学运算，普遍的公平恐怕也不是一件可欲的事。事实上，人们从来追求的就不是某种普世意义上的公平，都只是在一个模糊而狭窄的界限内追求各自的“适度的公平”</p>
<h1 id="伟大的嫉妒心"><a href="#伟大的嫉妒心" class="headerlink" title="伟大的嫉妒心"></a>伟大的嫉妒心</h1><p>平等的出处一点都不高贵，似乎完全体现不出人作为人的道德尊严，所以霍尔姆斯才说“我一点也不敬重追求公平的热情，在我看来，它似乎只是将嫉妒理想化了而已”</p>
<p>别人的不幸为什么会给我们带来快感呢？这是一个古老的美学问题。据卢克来修自己解释，这不是因为我们真的对别人的不幸感到快乐，而是因为我们庆幸自己逃脱了类似的灾难。</p>
<p>但也有另外的解释，是将这种快感归结于我们从远古祖先那里继承过来的嗜血和残忍的欲望</p>
<p>美学家们一直对这个问题争议不休，但无论如何，人类这种幸灾乐祸的心态不管被怎么解释，总归是一种普遍的客观存在，我们就是喜欢看别人倒霉。</p>
<p>如果偏偏别人过得比我们好，那么斯威夫特的词句就开始熠熠发光了：我们会嫉妒他们，巴望他们倒霉，越早越好</p>
<p>从哲学角度来看，《鲁滨逊漂流记》实在是一部耐人寻味的小说。如果要问，它究竟给了人们怎样的哲学启发，现代读者很容易会赞同书中所传达的“知足常乐”这一经典的心灵鸡汤式的“人生感悟”</p>
<p>这并不奇怪，我们的大众文化一向都喜欢把任何思想形式尽力向着“知足常乐”的方向理解，无论是西方文学，国学经典，还是佛学义理，基督学神学，都在不遗余力地早就着千人一面的效果</p>
<p>在社会生活中，一颗无甚实用价值的钻石为何可以价值连城，这是孤岛上离群索居的人永远也无法理解的。在社会生活中，出于虚荣的需要就是一种真实的需要，无可辩驳的</p>
<p>嫉妒心的作用有时会收到忽视。罗尔斯的正义论就是如此，在他对正义的预设中，嫉妒心是被排除在外的，在他看来，一个理性的人不会受到嫉妒心的影响。</p>
<p>罗尔斯的差别原则“资源分配的不公平之灾一种情况是允许的，这种不平等对社会上境况最差的人也是有利的。”这其实是采取了功利主义的计算方式，没有把嫉妒心计算在内。</p>
<p>谁都不可否认社会在进步，不可否认我们的生存状况在变好，至少比石器时代要好很多————但很少有人会做这样的比较。人们自然的心理机制就像以下这个场景所揭示的：有100元给你和另一个人分，分配方案是他拿99元，你拿1元，但你可以选择：要么接受，要么干脆取消交易，谁也拿不到一分钱。被问到这个问题的人，绝大多数都选择了后者，尽管前者仍然是有净收益的</p>
<p>程序正义解决不了嫉妒心的问题，两败俱伤的结果仍然会是最常见的</p>
<p>财富的基本功能是满足一般意义上的生活需要，而其一则“重要功能”是为了招人嫉妒或者追赶自己所嫉妒的人。</p>
<p>平心而论，嫉妒与其说是康德所谓的“一种反人类的恶习”，不如说它正和贪婪一样，其本质只是一种生物性的事实而已，是基因客观存在的一种求生倾向。缺乏嫉妒心的动物会被自然律轻易淘汰，实际上，嫉妒心的道德价值是被认为赋予的，是被放在社会规范下加以衡量的产物。然而任何可能形式的社会都会有相当多的资源是高度稀缺的</p>
<p>在嫉妒心表现在学习和工作上时，往往是收到鼓励的，称之为上进心或者是拼搏精神，虽然在概念上我们可以强做区分，但不可否认的是，其实嫉妒和竞争两者的心里动机没有区别</p>
<p>基因的目的有多明确，生命的目的就应该有多明确</p>
<p>人天生就是追求不平等的，所以才会追求平等</p>
<p>但是事情还有另外的一面，人是群居动物，一个完全没有利他之心的人很容易受到群体的排斥，很难一个人在严酷的自然环境中生存下来——利他倾向和利己倾向是与生俱来的，同情心就是一个显例</p>
<p>再者，群居生活必须由一定的规范，也必然会自发形成一定的规范，这种规范就是道德，就是最自然地正义。从这层意义上讲，任何群居动物都是具有道德感的，如果哪个成员做了“不道德”的事，一经发现，理所当然会受到惩罚，只有这样才会形成井然有序的群体，才能发挥出分工协作的优势。所以“不道德”也可以表现为“出轨”或者“犯规”</p>
<p>于是，一方面是每个群体成员作为群居生物的一员都有规矩要守，另一方面是基因所注定的嫉妒心使大家势必要做横向的攀比和比较，这两种力量合流的结果就是“规则之下的竞争”</p>
<p>这在动物世界里一般表现为单打独斗以及当对手仰面朝天表示屈服时不再穷追猛打，在人类社会则表现为骑士精神以及取之有道的君子之风。当然并不是说只有骑士和金子才有这种做派，只不过他们有足够的身份和话语权特意标榜自己而已</p>
<p>嫉妒心不仅是社会发展的动力源泉之一，也是人类争取平等的心理动机。我们会在生活中轻易地得到如下的经验：你会为朋友某甲拿了设计大赛的金奖而由衷地喜悦，也会为朋友某乙出色的短跑成绩而跟耿耿于怀，原因很简单，你自己也是一名短跑运动员。如果你只是市一级的选手，那么你一般不会嫉妒世界冠军，也不会嫉妒退了役的前辈名将。也就是说，嫉妒心永远被限定在“平等”的范围内</p>
<p>在独立，自由，平等三者之中，先有了平等，才会有独立和自由。这里的先是逻辑意义上的先。你之所以会认为自己是自由的，是不该被对方的专断意志强迫的，是因为你首先人事到你和其他人是平等的；你之所以认为自己是独立的，是享有完整主权的，同样是因为你首先认识到你和其他人是平等的。平等既是独立，自由的逻辑基础，也是嫉妒心的永恒的诉求</p>
<p>王侯将相宁有种乎 陈胜吴广这句极富煽动力的口号所表达的正是对平等的一种朴素认知</p>
<p>晚唐诗人罗隐评价刘邦项羽的“英雄之言”：想来他们未必没有退逊之心，正廉之节，大约是看到了其实黄的靡曼骄崇，然后才起了上述念头。刘项这样的英雄人物尚且如此，何况常人</p>
<p>如果没有这样的平等意识，不把对方看作是和我一样的人，而是看作高于自己的这个等级的存在，那么即便收到对方的虐待，往往只会激起敬畏之情而不是感到自尊受挫</p>
<p>这样看来，平等的出处一点都不高贵，似乎完全体现不出人作为人的道德尊严，所以霍尔姆斯才说“我一点也不敬重追求平等的热情”，在我看来，它似乎只是将嫉妒理想化而已。</p>
<p>对平等的热情确实只是嫉妒心的理想化而已，确实会对社会造成一定程度的危害，正如它同样会促进社会的发展一样。</p>
<p>无论如何，嫉妒心总是趋势弱者向强者看齐，反其道而行之的例子不是绝无仅有，但绝对是凤毛麟角。但显而易见的是，绝对的公平，无论是结果公平还是起点公平，事实都是完全不可能的。所以里来的结果平等和起点平等之争完全争错了方向，对平等的追求实则是对规则的追求，是试图建立一些规则，以便在规则面前“人人平等”，而规则意识之产生是人类在自觉或者不自觉中反复博弈的结果</p>
<p>我们最熟悉的一项规则就是法律。当然我们也可以把金钱设置成规则。社会秩序正是从许多如此这般的规则经纬交织起来的</p>
<p><strong>规则不是可以被任何争议理论合乎情理地推演出来的，因为它取决于人们的偏好，而人们的偏好总是随着社会结构和社会风气的变化而迁流不居</strong></p>
<p>只有嫉妒心是永存不灭的天性，它促使人们产生平等的意识，并且萌发对公平的追求，后者又使人们意识到自己的独立与自由，在向强者看齐的过程中博弈出自己的全力。而这，在多大程度上是嫉妒使然呢？</p>
<p>所谓正义，不过是在世人的磨合，博弈中诞生出来的一种观念茶品，就像一块浑金璞玉，在如此这般的言辞的利刃中如切如磋，如琢如磨，越发被打磨成一个浑圆的球形</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>正义</tag>
        <tag>公正</tag>
      </tags>
  </entry>
</search>
